# Bilder {#sec-images}

## Zusammenfassung {.unnumbered}

Unsere wichtigsten Lernziele in diesem Kapitel sind:

...

## Experimentaufbau {.unnumbered}

### Hardware {.unnumbered}

In den Experimenten dieses Kapitels verwenden wir ein einfaches Display, das wir an unseren Master Brick anschließen. Das Display kann einzelne Pixel weiß aufleuchten lassen und damit einfache Bilder und auch Texte darstellen. Insgesamt stehen uns 128 x 64 Pixel zur Verfügung, also 8192 einzelne Bildpunkte. Damit können wir arbeiten.

Die vollständige Hardwareliste für dieses Kapitel sieht so aus:

-  1 x [Master Brick 3.2](https://www.tinkerforge.com/de/doc/Hardware/Bricks/Master_Brick.html)
-  1 x [Distance IR 4-30cm Bricklet 2.0](https://www.tinkerforge.com/de/shop/distance-ir-4-30cm-v2-bricklet.html)
-  1 x [OLED 128x64 Bricklet 2.0](https://www.tinkerforge.com/de/doc/Hardware/Bricklets/OLED_128x64_V2.html)
-  1 x [Montageplatte 22x10](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-plate-22x10.html)
-  2 x [Brickletkabel 15cm (7p-7p)](https://www.tinkerforge.com/de/shop/accessories/cable/bricklet-cable-15cm-7p-7p.html)

### Erste Schritte mit dem Display {.unnumbered}

Wie immer geht es zuerst in den Brick Viewer. Verbindet euch mit dem Master Brick und ihr solltet die angeschlossenen Geräte sehen können. Den Infrarotsensor kennen wir bereits aus dem letzten Kapitel. Wir konzentrieren uns deshalb auf das neue Display, das ihr im Tab "OLED 128x64 Bricklet 2.0" findet.

Die Oberfläche für das Display seht ihr in @fig-images-brick-viewer-oled-display. Im Wesentlichen kann das Display drei Dinge:

1. Es kann einzelne Pixel ein- und ausschalten
2. Es kann den gesamten Inhalt löschen
3. Es kann Text anzeigen, was ein Spezialfall von Punkt 1 ist

![Im Brick Viewer können wir auf dem Display Text anzeigen oder zeichnen.](images/brick_viewer_oled_display.png){#fig-images-brick-viewer-oled-display .lightbox}

Alle genannten Funktionen können wir direkt im Brick Viewer ausprobieren. Mit der Maus können wir auf der schwarzen Fläche freihändig zeichnen und unser Resultat mit "Draw on Display" auf das Display übertragen. Mit "Clear Display" löschen wir den gesamten Inhalt wieder. Alternativ können wir Text in das Textfeld eingeben und mit "Send" anzeigen lassen.

Für Text können wir die Position über die Angabe der Zeile (Line) sowie der Position in der Zeile (Pos) bestimmen. Im Dropdown seht ihr, dass die Zeilen von 0 bis 7 und die Positionen von 0 bis 21 nummeriert sind. Das Display teilt die 128 Pixel Breite in 22 Zeichenpositionen und die 64 Pixel Höhe in 8 Textzeilen auf. Die eingebaute Schrift nutzt ein 5x8-Pixel-Raster pro Zeichen und fügt passende Abstände ein.

::: {#fig-images-display-drawing-vs-text-brick-viewer layout="[[1,1]]"}

![Mein Versuch, den Titel des Buches mit der Maus zu zeichnen.](images/brick_viewer_oled_display_drawing_hocs.png){#fig-brick-viewer-oled-display-drawing-hocs .lightbox group="brick-viewer-oled-display"}

![Das Display unterstützt auch die direkte Textausgabe.](images/brick_viewer_oled_display_text.png){#fig-brick-viewer-oled-display-text .lightbox group="brick-viewer-oled-display"}

:::

In @fig-images-display-drawing-vs-text könnt ihr den Unterschied zwischen meinem kläglichen Versuch, den Titel des Buches mit der Maus zu zeichnen, und der Textausgabe sehen. Das Display ist zwar nicht besonders groß, aber für einfache Grafiken und Texte reicht es allemal. Wie ihr seht, ist der Text "Hands-On Computer Science" zu lang für eine Zeile und wird daher abgeschnitten.

::: {#fig-images-display-drawing-vs-text layout="[[1,1]]"}

![So sieht meine Zeichnung auf dem Display aus.](images/oled_display_hocs_drawing.jpg){#fig-oled-display-hocs-drawing .lightbox}

![Es geht auch direkt als Text, allerdings abgeschnitten.](images/oled_display_hocs_text.jpg){#fig-oled-display-hocs-text .lightbox}

Gezeichneter vs. getippter Text auf dem Display.

:::

## Pixel {#sec-images-pixels}

Nachdem wir das Display im Brick Viewer ausprobiert haben, wollen wir uns die Funktionen auch in Python anschauen. Dazu stellen wir wie immer die Verbindung her und erzeugen eine Instanz des Display-Objekts:

```{python}
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_oled_128x64_v2 import BrickletOLED128x64V2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
oled = BrickletOLED128x64V2('25zo', ipcon) # <1>
oled.clear_display() # <2>
```

1. Denk dran, eure eigene UID einzutragen.
2. Wir löschen den Display-Inhalt, damit wir mit einem leeren Display starten. Die Funktion `clear_display()` erledigt das.

Über die Variable `oled` können wir jetzt die verschiedenen Funktionen des Displays verwenden. Eine davon seht ihr bereits im Codebeispiel, nämlich das Löschen des Displays mit `clear_display()`. Die andere wesentliche Funktion ist das An- und Ausschalten einzelner Pixel.

Das Wort \gloss{Pixel}{Ein Pixel ist der kleinste darstellbare Punkt auf einem Display}{Repräsentation von Bildern} wird vom englischen "picture element" abgeleitet, also Bildelement. Ein Pixel ist der kleinste darstellbare Punkt auf einem Display. In unserem Fall kann ein Pixel entweder schwarz oder weiß sein. Auf anderen Bildschirmen, wie dem eures Smartphones oder Fernsehers, können Pixel auch farbig sein. Das schauen wir uns später noch genauer an. In diesem Kapitel konzentrieren wir uns auf die einfache schwarzweiße Darstellung. Außerdem kann unser Display nur Schwarzweiß.

Das Display, das wir verwenden, hat eine Auflösung von 128 x 64 Pixeln. Das bedeutet, dass es 128 Pixel in der Breite und 64 Pixel in der Höhe hat. Insgesamt ergibt das 8192 einzelne Pixel, die wir ansteuern können.

Beginnen wir, indem wir das Pixel in der linken oberen Ecke des Displays einschalten. Die Koordinaten für dieses Pixel sind (0, 0), wobei die erste Zahl die x-Koordinate (horizontal) und die zweite Zahl die y-Koordinate (vertikal) ist. Um dieses Pixel einzuschalten, verwenden wir die Funktion `write_pixels()`, die wie folgt aussieht:

```{python}
#| code-line-numbers: false
oled.write_pixels(0, 0, 0, 0, [1])
```

Die ersten vier Argumente definieren zwei Punkte auf dem Display, die eine rechteckige Fläche beschreiben. Die ersten beiden Argumente sind die x- und y-Koordinaten des oberen linken Punkts, die zweiten beiden Argumente sind die x- und y-Koordinaten des unteren rechten Punkts. Diese Eckpunkte sind inklusive, das heißt, die Breite ergibt sich aus `x_end - x_start + 1` und die Höhe aus `y_end - y_start + 1`. In unserem Fall sind beide Punkte (0, 0), wir sprechen also genau ein Pixel an. Der letzte Parameter ist eine Liste von Werten, die angibt, ob die Pixel in der definierten Fläche ein- oder ausgeschaltet werden sollen. Ein Wert von 1 bedeutet weiß, 0 bedeutet schwarz. Da wir nur ein Pixel ansprechen, enthält die Liste nur einen Wert: `[1]`.

Eine Liste wird in Python mit eckigen Klammern `[]` definiert. Innerhalb der Klammern können beliebig viele Werte durch Kommas getrennt angegeben werden. In unserem Fall haben wir nur einen Wert, nämlich 1, um das einzelne Pixel einzuschalten.

Genauso können wir das Pixel wieder ausschalten, indem wir den Wert in der Liste auf 0 ändern. Sobald ihr Enter drückt, sollte das Pixel in der linken oberen Ecke wieder ausgehen:

```{python}
#| code-line-numbers: false
oled.write_pixels(0, 0, 0, 0, [1])
input("Drücke Enter um das Pixel auszuschalten...")
oled.write_pixels(0, 0, 0, 0, [0])
```

Einzelne Pixel lassen sich auf die oben gezeigte Weise an- und ausschalten. Aber was ist, wenn wir mehrere Pixel gleichzeitig ansteuern wollen? Zum Beispiel ein kleines Quadrat in der Mitte des Displays. Dafür müssen wir die Koordinaten der beiden Punkte anpassen, die die rechteckige Fläche definieren, und eine Liste mit den entsprechenden Werten für alle Pixel in dieser Fläche erstellen. Wir sprechen hier von einer Bitmap\index{Bitmap}, also einer Matrix von Pixelwerten, die zusammen ein Bild ergeben.

## Bitmaps {#sec-images-bitmaps}

Sagen wir, wir wollen ein 4x4 großes Quadrat in der Mitte des Displays zeichnen. Dazu müssen wir zuerst berechnen, wo die Mitte des Displays ist. Da das Display 128 Pixel breit und 64 Pixel hoch ist, liegt die Mitte bei (64, 32). Weil wir bei 0 beginnen zu zählen, korrigieren wir auf (63, 31). Um ein 4x4-Quadrat zu zeichnen, setzen wir die Koordinaten des oberen linken Punkts auf (61, 29) und die Koordinaten des unteren rechten Punkts auf (64, 32). Die Liste der Werte für die Pixel in dieser Fläche muss 16 Werte enthalten, alle auf 1 gesetzt, um das Quadrat einzuschalten.

```{python}
#| code-line-numbers: false
oled.write_pixels(61, 29, 64, 32, [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])
```

Genau genommen ist die Liste keine verschachtelte Struktur, sie wird aber als 4x4-Matrix interpretiert. Die Bitmap sieht also so aus:

```
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
```

Was ist, wenn wir das Quadrat auf 5x5 vergrößern wollen? Dann ändern wir den unteren rechten Punkt auf (65, 33) oder alternativ den oberen linken Punkt auf (60, 28). Die Liste der Werte erweitern wir auf 25 Einträge:

```{python}
#| code-line-numbers: false
oled.write_pixels(61, 29, 65, 33, [1]*25)
```

Die Python-Syntax `[1]*25` erzeugt eine Liste mit 25 Einsen. Das ist eine praktische Abkürzung, um lange Listen mit gleichen Werten zu erstellen.

Die Idee von `write_pixels()` ist also, dass wir eine rechteckige Fläche definieren und dann eine Liste von Werten bereitstellen, die angibt, ob jedes Pixel in dieser Fläche ein- oder ausgeschaltet wird. Die Länge der Liste muss genau der Anzahl der Pixel in der Fläche entsprechen. Die Werte in der Liste werden zeilenweise von links nach rechts und von oben nach unten gelesen.

In @fig-images-display-pixel-frame visualisieren wir das Konzept der Bitmap. Der rote Bereich, in dem die Pixel gesetzt werden, wird durch die ersten vier Argumente der Funktion `write_pixels()` definiert. Die Liste der Werte füllt diesen Bereich von links nach rechts und von oben nach unten. Die Liste sähe in diesem Fall so aus:

```
[0,1,0,1,1,1,0,1,0]
```

Als Matrix dargestellt:

```
0 1 0
1 1 1
0 1 0
```

In der Matrixdarstellung erkennt man schnell das Kreuzmuster, das wir gezeichnet haben.

![Der rote Bereich wird durch die ersten vier Argumente der Funktion `write_pixels()` definiert.](images/display_pixel_frame.png){#fig-images-display-pixel-frame .lightbox}

Wenn wir Kreuze als Bitmaps darstellen können, wie sieht es dann mit anderen Symbolen aus?

## Buchstaben {#sec-images-letters}

Auch Buchstaben auf dem Bildschirm sind nichts anderes als Pixelmuster. Wie bereits erwähnt, ist ein Buchstabe 5 Pixel breit und 8 Pixel hoch. Das bedeutet, dass wir für jeden Buchstaben eine Bitmap mit 40 Werten benötigen. Tinkerforge, der Hersteller des Displays, stellt eine Übersicht der unterstützten Zeichen und deren Pixelmuster auf [seiner Webseite](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/OLED_128x64_V2.html#font) bereit. Daraus habe ich den Buchstaben "A" als Bitmap in ein einfaches Spreadsheet übertragen und Pixel, die an sind, schwarz eingefärbt. Das Ergebnis seht ihr in @fig-images-bitmap-letter-a-spreadsheet.

![Der Buchstabe "A" als Bitmap in einem Spreadsheet.](images/bitmap_letter_a.png){#fig-images-bitmap-letter-a-spreadsheet .lightbox width="25%"}

Anhand dieser Darstellung können wir die Werte für die Liste mit Einsen und Nullen ableiten, die wir benötigen, um den Buchstaben "A" auf dem Display darzustellen. Die Liste sieht so aus:

```{python}
#| code-line-numbers: false
letter_a_bitmap = [
    0, 0, 1, 0, 0,
    0, 1, 0, 1, 0,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    1, 1, 1, 1, 1,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    0, 0, 0, 0, 0
]
```

Wer gute Augen hat, erkennt in der Matrix den Buchstaben "A" sofort. Welcher Buchstabe verbirgt sich in der folgenden Bitmap?

```{python}
#| code-line-numbers: false
#| echo: false
letter_unknown_bitmap = [
    0, 1, 1, 1, 0,
    1, 0, 0, 0, 1,
    1, 0, 0, 0, 0,
    0, 1, 1, 1, 0,
    0, 0, 0, 0, 1,
    1, 0, 0, 0, 1,
    0, 1, 1, 1, 0,
    0, 0, 0, 0, 0
]
```

Zeichnen wir den Buchstaben auf dem Display, um es herauszufinden. Wir kennen die Dimensionen (5x8 Pixel), haben die Bitmap und müssen nur noch die Position bestimmen, an der der Buchstabe gezeichnet werden soll. Ich habe mich für die Position (6, 10) als oberen linken Punkt entschieden:

```{python}
#| code-line-numbers: false
oled.write_pixels(6, 10, 10, 17, letter_unknown_bitmap)
```

Und? Seht ihr auch ein großes "S"? Versuchen wir, davor noch das "A" zu schreiben:

```{python}
#| code-line-numbers: false
oled.write_pixels(1, 10, 5, 17, letter_a_bitmap)
```

Wir haben richtig gerechnet: Das "A" soll vor dem "S" stehen, also müssen wir mit der x-Koordinate 5 Pixel nach links gehen. Die y-Koordinate bleibt gleich, weil beide Buchstaben auf der gleichen Höhe stehen sollen. Lasst uns noch ein Pixel Platz zwischen beiden Buchstaben lassen. Das bedeutet, dass wir die x-Koordinate des "A" um 1 Pixel weiter nach links setzen, also auf 0. Die x-Koordinate des rechten unteren Punkts des "A" wird dann 4. Der Code für das "A" sieht dann so aus:

```{python}
#| code-line-numbers: false
oled.write_pixels(0, 10, 4, 17, letter_a_bitmap)
```

Und nun noch ein "S" ans Ende, damit wir ein sinnvolles Wort geschrieben haben:

```{python}
#| code-line-numbers: false
oled.write_pixels(0, 10, 4, 17, letter_a_bitmap)
oled.write_pixels(6, 10, 10, 17, letter_unknown_bitmap)
oled.write_pixels(12, 10, 16, 17, letter_unknown_bitmap)
```

Sucht euch aus, ob ihr nun eine Spielkarte, den Namen eines Schmerzmittels oder das englischsprachige Wort für Ar*** geschrieben habt. In jedem Fall sind es drei Buchstaben, die wir mit Bitmaps auf dem Display dargestellt haben. Und das ganz ohne die Textfunktion des Displays zu verwenden.

Das wäre übrigens auch gegangen, wäre aber nicht so lehrreich gewesen:

```{python}
#| code-line-numbers: false
oled.write_line(0, 0, "Ass")
```

Wenn ihr beides hintereinander ausführt, steht oben "Ass" per Textfunktion und darunter "ASS" als eigene Bitmaps. Das Schöne an der `write_line()`-Funktion ist, dass sie automatisch die richtigen Bitmaps für die Buchstaben verwendet. Das Display hat eine eingebaute Schriftart, die es nutzt, wenn wir Text anzeigen wollen. Aber wie ihr gesehen habt, können wir auch eigene Bitmaps verwenden, um Buchstaben oder andere Symbole zu zeichnen, die nicht im Zeichensatz des Displays enthalten sind.

[WRITE A PARAGRAPH ABOUT FONTS AND HOW THEY ARE JUST COLLECTIONS OF BITMAPS, USE EXAMPLE. SMOOTH TRANSITION TO NEXT SECTION ON VECTOR GRAPHICS.]
Schriftarten für Pixel-Displays sind im Kern nichts anderes als Sammlungen von Bitmaps: Für jedes Zeichen wird festgelegt, welche Pixel im 5x8-Raster leuchten. Unser "A" oben ist genau so definiert, und das OLED-Bricklet bringt eine solche Tabelle für viele Zeichen bereits mit. Wenn ihr eine andere Schrift wollt, erstellt ihr einfach eine neue Bitmap-Tabelle, etwa eine fette oder eine schmale Variante, und verwendet diese beim Zeichnen. Das funktioniert hervorragend in festen Rastergrößen, stößt aber an Grenzen, sobald ihr Größen ändern oder sehr glatte Kanten haben wollt. Hier kommen Vektorgrafiken ins Spiel, die Formen nicht als Pixelraster, sondern als Linien und Kurven beschreiben.

## Vektorgrafiken {#sec-images-vector-graphics}

Während Bitmaps jedes Pixel explizit speichern, beschreiben Vektorgrafiken Objekte mathematisch, etwa "eine Linie von A nach B" oder "ein Kreis mit Mittelpunkt M und Radius r". Eine Vektor-Schriftart (z. B. TrueType) enthält keine 5x8-Raster pro Zeichen, sondern Pfade für die Konturen von "A", "S" und Co. Der Vorteil: Diese Formen lassen sich beliebig vergrößern oder verkleinern, ohne dass Treppeneffekte entstehen. Das ist ideal für hochauflösende Displays und Druck. Auf unserem kleinen OLED-Display arbeiten wir dennoch mit Bitmaps, weil sie direkt den Pixeln entsprechen und ohne aufwendiges Rasterisieren angezeigt werden können.

Schauen wir uns ein Beispiel an. Angenommen, wir wollen ein einfaches Haus zeichnen. In einer Vektorgrafik würden wir das Haus als Rechteck für die Wände und ein Dreieck für das Dach beschreiben. In Python könnten wir das so machen:

```{python}
#| code-line-numbers: false
def draw_house(oled, x, y, scale=1):
    width = round(15 * scale)
    height = round(15 * scale)
    # Wände
    oled.write_pixels(x, y + height // 2, x + width - 1, y + height - 1, [1] * (width * (height // 2)))
    # Dach
    roof_height = height // 2
    for i in range(roof_height):
        oled.write_pixels(x + i, y + roof_height - i - 1, x + width - i - 1, y + roof_height - i - 1, [1] * (width - 2 * i))
```

In diesem Beispiel definiert die Funktion `draw_house()` das Haus als Kombination von Rechteck (Wände) und Dreieck (Dach). Die Vektorbeschreibung wird in Pixel umgesetzt, indem wir die entsprechenden Bereiche mit `write_pixels()` füllen. Das Ergebnis ist ein einfaches Haus auf dem Display, das durch die Vektorbeschreibung flexibel skaliert werden könnte.

Wir können das Haus nämlich ganz einfach größer oder kleiner zeichnen, indem wir die Parameter `width` und `height` anpassen. Das ist der große Vorteil von Vektorgrafiken: Sie sind skalierbar und behalten ihre Form, egal wie groß oder klein sie dargestellt werden.

## Icons {#sec-images-icons}

![](images/bitmap_bw_r2d2.png){#fig-images-bitmap-r2d2 .lightbox width="50%"}

![](images/bitmap_bw_darth_vader.png){#fig-images-bitmap-darth-vader .lightbox width="50%"}

```{python}
from openpyxl import load_workbook

workbook = load_workbook("pixel_art.xlsx")
sheet = workbook.active

arr = []
for row in sheet.iter_rows():
    for cell in row:
        color = getattr(cell.fill.fgColor, "rgb", None)
        arr.append(1 if color == "FF000000" else 0)

print(arr)
```

## Komprimierte Bilder {#sec-images-compressed}

Bitmaps speichern für jedes Pixel einen Wert. Das ist einfach, kann aber viel Speicher benötigen. Deshalb werden Bitmaps häufig komprimiert. Ein klassisches Verfahren ist Run-Length Encoding (RLE). Dabei werden Folgen identischer Pixel durch "Wert + Länge" ersetzt. Aus `0,0,0,0,1,1,0,0` wird zum Beispiel `(0x4),(1x2),(0x2)`. Besonders bei großen einfarbigen Flächen spart das deutlich Speicher und Übertragungszeit. Für eingebettete Systeme wie unser Display ist das nützlich, weil weniger Daten übertragen und verarbeitet werden müssen. Vor der Anzeige wird die komprimierte Darstellung einfach wieder in die ursprüngliche Pixelsequenz entpackt.

Das Extrembeispiel ist ein komplett schwarzes oder weißes Bild. Statt 8192 Nullen oder Einsen zu speichern, reicht ein Eintrag: `(0x8192)` oder `(1x8192)`. Das spart enorm viel Platz.

## Nibbles

Zum Abschluss des Kapitels wollen wir noch zwei Aspekte betrachten, die wir bei der Entwicklung eines kleinen Spiels kennenlernen wollen: Animationen und Objektorientierung. 

Das Spiel *Nibbles* wurde 1991 als Spiel für das Betriebssystem Microsoft DOS veröffentlicht und kostenlos bereitgestellt. Es wurde in der Programmiersprache QBasic geschrieben, in der auch ich das Programmieren zuerst gelernt habe. Die Spielidee wurde später im Spiel *Snake* weiterverwendet, das auf vielen Handys, besonders von Nokia, vorinstalliert war. In beiden Spielen bewegt ihr eine Schlange über den Bildschirm, die immer länger wird, je mehr sie frisst. Ziel ist es, die Schlange so zu steuern, dass sie nicht mit sich selbst oder den Bildschirmrändern kollidiert.

Damit wir Nibbles auf umserem kleinen OLED umsetzen können - übrigens hatten die ersten Nokia-Mobiltelefone Displays mit kleinerer Auflösung - müssen wir uns zunächst überlegen, wie wir Dinge wie eine Schlange auf dem Bildschirm bewegen oder animieren können. Der Begriff *animieren* kommt aus dem Lateinischen und bedeutet so viel wie "beleben" oder "zum Leben erwecken". Das klingt gut!

### Animationen {#sec-images-animations}

Animationen sind im Grunde nichts anderes als eine schnelle Abfolge von Bildern, die nacheinander angezeigt werden. Wenn die Bilder schnell genug wechseln, entsteht der Eindruck von Bewegung. Das Prinzip ist ähnlich wie bei einem Daumenkino, wo eine Serie von Zeichnungen durch schnelles Blättern zum Leben erweckt wird.

In unserem Fall können wir Animationen auf dem OLED-Display erstellen, indem wir mehrere Bitmaps vorbereiten, die verschiedene Zustände eines Objekts darstellen. Zum Beispiel könnten wir eine einfache Animation eines laufenden Roboters erstellen, indem wir verschiedene Positionen der Beine zeichnen und diese nacheinander anzeigen.

### Objekte und Klassen {#sec-images-object-oriented}

In @sec-colors haben wir bereits kurz die Begriffe *Klasse* und *Objekt* eingeführt. Hier wollen wir das Konzept vertiefen, indem wir eine eigene Klasse für ein animiertes Objekt definieren. Eine Klasse ist wie ein Bauplan für ein Objekt, das bestimmte Eigenschaften (Attribute) und Fähigkeiten (Methoden) hat. Eine Klasse, die wir einmal definiert haben, können wir beliebig oft ins Leben rufen, indem wir Objekte dieser Klasse erstellen.