---
abstract: |
    Im zweiten Kapitel kn√ºpfen wir an den Regenbogen an und lernen, wie wir den Computer √ºber unsere Eingabe steuern k√∂nnen.
abstract-title: ""
---

# Zahlen üî¢ {#sec-numbers}

## Lernziele {.unnumbered}

## Experimentaufbau {.unnumbered}

Das erste Experiment hatte es in sich! In diesem Kapitel erweitern unsere Hardware aus @sec-colors und f√ºgen ein Eingabeger√§t hinzu: Einen einfachen Drehknopf ([Rotary Encoder Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/Rotary_Encoder_V2.html)). Den schraubt ihr neben die LED, wie auf der Abbildung zu sehen ist.

## Erste Schritte mit dem Drehknopf

Wie schon bei der LED wollen wir uns im ersten Schritt den neuen Drehknopf im Brick Viewer genauer anschauen und seine Funktion kennenlernen. Schlie√üt eueren Master Brick √ºber das USB-Kabel an euren Rechner an, √∂ffnet den Brick Viewer und dr√ºckt den Connect-Button.

![Der Brick Viewer nach dem Connect.](images/brick_viewer_after_connect.png){#fig-brick-viewer-after-connect .lightbox group="brick-viewer"}

...

## Hoch- und Runterz√§hlen

Der Drehknopf ist vergleichbar mit einem Drehknopf f√ºr die Lautst√§rke wie man ihn beispielsweie an einer Stereoanlage wie in @fig-hifi-system findet, um die Musik lauter und leiser zu stellen. Dreht ihr nach rechts wird es lauter, in die andere Richtung leiser. 

![Die gute alte Stereoanlage mit Drehknopf! Wer kennt sie nicht mehr? (Quelle: [Wikimedia](https://commons.wikimedia.org/wiki/File:Sony_XO-D20S_Midi_HiFi_system_%28white_bg%29.jpg))](images/hifi_system.jpg){#fig-hifi-system .lightbox}

Im Hintergrund ver√§ndert sich der Wert, den der Drehknopf sendet, entweder er erh√∂ht oder verringert sich. Welchen Wert der konkret sendet h√§ngt vom Ausgangszustand ab. Im Brick Viewer haben wir das schon gesehehen. Testen wir es einmal in einem Programm. Der Code unten verbindet sich mit dem Drehknopf, liest den aktuellen Wert aus und schreibt ihn auf die Konsole. Denkt daran, dass ihr eure UID statt meiner eintragen m√ºsst:

```{python}
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
knob = BrickletRotaryEncoderV2('XYZ', ipcon) # <1>
count = knob.get_count() # <2>
print(count)
```
1. Wir erstellen eine virtuelle Repr√§sentation des Drehknopfs in unserem Programm, um seine Funktionen verwenden zu k√∂nnen.
2. √úber die virtuelle Repr√§sentation des Drehknopfs k√∂nnen wir mittels `get_count()` den aktuellen Wert abfragen.

Die Ausgabe sollte sich mit dem Wert decken, den ihr auch im Brick Viewer seht. Schlie√ülich verwendet der Brick Viewer die gleiche Programmierschnittstelle wie unser Programm. Wenn alles funktioniert habt ihr soeben die erste Funktion des Drehknopfs erfolgreich aus einem Python-Programm heraus getestet.

Wenn wir jetzt an dem Knopf drehen und das Programm erneut ausf√ºhren wird uns ein anderer Wert angezeigt. Logisch! Unser Ziel ist es aber, dass wir daf√ºr nicht jedes Mal das Programm neu starten m√ºssen. Die L√∂sung f√ºr dieses Problem habt ihr bereits in @sec-colors kennengelernt: Wir verwenden eine Schleife, die das Programm immer wiederholt, bis wir es beenden:

```{python}
while True:
    count = knob.get_count()
    print(count, end='\r')
```

Kurze Erinnerung: Mit `while True` erstellen wir eine Endlosschleife. Eigentlich etwas, das wir vermeiden wollen. Allerdings nicht, wenn wir es explizit so wollen. Eine Endlosschleife kann n√ºtzlich sein, um kontinuierlich Daten zu lesen oder auf Ereignisse zu warten. Und wir k√∂nnen sie jederzeit beenden, indem wir das Programm mit *Strg+C* abbrechen.

## Das fertige Programm

```{python}
import keyboard
import time
import colorsys
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223) 
led = BrickletRGBLEDV2('ZEP', ipcon)

# Turn button of initially
led.set_rgb_value(0, 0, 0)

# Initialize the hue value
hue = 1

# Set the duration for one rainbow cycle
duration_seconds = 4
duration_seconds_per_step = duration_seconds / 360

# Loop until user presses escape key
while not keyboard.is_pressed('esc'):

    # Calculate RGB from hue
    r, g, b = colorsys.hsv_to_rgb(hue / 360.0, 1.0, 1.0)
    r = int(r * 255)
    g = int(g * 255)
    b = int(b * 255)

    led.set_rgb_value(r, g, b)
    
    # Wait a bit
    time.sleep(duration_seconds_per_step)

    hue = hue + 1
    if hue > 360:
        hue = 1

led.set_rgb_value(0, 0, 0)
```