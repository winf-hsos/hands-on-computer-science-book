# Zahlen {#sec-numbers}

## Zusammenfassung {.unnumbered .collapsable}

Im zweiten Kapitel spendieren wir der LED aus @sec-numbers eine Dimmfunktion, die wir √ºber einen Drehknopf steuern k√∂nnen.

### Schritt f√ºr Schritt zum Ziel {.unnumbered}

Auf dem Weg dorthin gehen wir die folgenden Schritte.

| \# | Was? | Wo? |
|--|-------------------------------------------------------|----------------|
| 1 | Wir machen uns mit dem Drehknopf vertraut. | @sec-numbers-experiment-setup |
| 2 | Wir lesen den Z√§hlerstand des Drehknopfs aus einem Programm heraus aus. | @sec-numbers-read-counter |
| 3 | Wir f√ºhren Kontrollstrukturen ein (`if`). | @sec-numbers-control-structures |
| 4 | Wir erstellen eine erste Version eines Dimmers f√ºr die LED. | @sec-numbers-led-dimmer-1 |
| 5 | Wir besch√§ftigen uns mit Zahlensystemen. | @sec-numbers-number-systems |
| 6 | Wir lernen, was ein Bit und ein Byte ist. | @sec-numbers-bit-and-bytes |
| 7 | Wir erweitern den LED-Dimmer zur Version 2. | @sec-numbers-led-dimmer-2 |
| 8 | Wir setzen und mit den Druckknopf auseinander. | @sec-numbers-button-reading |
| 9 | Wir bauen Version 3 des LED-Dimmers. | @sec-numbers-led-dimmer-3 |
| 10 | Wir modularisieren unseren Code mit Funktionen. | @sec-numbers-functions |

### Begriffe und Konzepte {.unnumbered}

Dabei lernen wir neue Begriffe und Konzepte kennen.

<!-- CHAPTER_GLOSSARY_START -->
::: {.datatable-nosearch data-order='[[2,"asc"]]'}
| Begriff | Kategorie | Wo? |
|---|---|---|
| **DRY-Prinzip** | Programmierung | @sec-numbers-led-dimmer-3 |
| **Funktionen** | Programmierung | @sec-numbers-led-dimmer-3 |
:::
<!-- CHAPTER_GLOSSARY_END -->

## Experimentaufbau {#sec-numbers-experiment-setup .collapsable}

### Hardware

Das erste Experiment in @sec-colors war ein guter Einstieg! In diesem Kapitel legen wir noch eine Schippe drauf: Unsere Hardware bekommt ein neues Bauteil ‚Äì einen Drehknopf. Das montiert ihr einfach neben der LED, wie in @fig-setup-rgb-led-rotary-encoder gezeigt.

Die vollst√§ndige Hardwareliste f√ºr dieses Kapitel sieht so aus:

-  1 x [Master Brick 3.2](https://www.tinkerforge.com/de/doc/Hardware/Bricks/Master_Brick.html)
-  1 x [Distance IR 4-30cm Bricklet 2.0](https://www.tinkerforge.com/de/shop/distance-ir-4-30cm-v2-bricklet.html)
-  1 x [Montageplatte 22x10](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-plate-22x10.html)
-  2 x [Brickletkabel 15cm (7p-7p)](https://www.tinkerforge.com/de/shop/accessories/cable/bricklet-cable-15cm-7p-7p.html)

::: {#fig-setup-rgb-led-rotary-encoder layout="[[1], [1,1], [1,1]]"}
![Seitenansicht.](images/master_brick_with_led_and_rotary_01.jpg){#fig-setup-rgb-led-a .lightbox group="setup-rgb-led"}

![Draufsicht.](images/master_brick_with_led_and_rotary_02.jpg){#fig-setup-rgb-led-b .lightbox group="setup-rgb-led"}

![Nahaufnahme des Rotary Encoders.](images/master_brick_with_led_and_rotary_03.jpg){#fig-setup-rgb-led-c .lightbox group="setup-rgb-led"}

![Seitenansicht.](images/master_brick_with_led_and_rotary_04.jpg){#fig-setup-rgb-led-d .lightbox group="setup-rgb-led"}

![Untenansicht.](images/master_brick_with_led_and_rotary_05.jpg){#fig-setup-rgb-led-e .lightbox group="setup-rgb-led"}

Einfaches Setup mit einem Mikrocontroller, LED und einem Drehknopf.
:::

### Erste Schritte mit dem Drehknopf {#sec-numbers-first-steps}

Wie bei der LED werfen wir zuerst einen Blick auf den neuen Drehknopf im Brick Viewer. Schlie√üt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Setup-Tab sollte nun neben der LED auch der Rotary Encoder auftauchen. Denkt daran: Dort findet ihr auch die UID eurer Ger√§te ‚Äì die braucht ihr gleich f√ºr euer Programm.

![Der Brick Viewer nach dem Connect.](images/exp_2_brick_viewer_after_connect.png){#fig-exp-2-brick-viewer-after-connect .lightbox group="brick-viewer-rotary"}

Wechselt nun in den Tab f√ºr den Drehknopf, wo ihr ihn direkt testen k√∂nnt: Ihr seht den aktuellen Z√§hlwert. Der kann positiv oder negativ sein ‚Äì je nachdem, wie oft und in welche Richtung ihr gedreht habt. Daneben zeigt ein Diagramm die zeitliche Entwicklung.

Doch der Knopf kann mehr als nur z√§hlen: Ihr k√∂nnt ihn auch dr√ºcken. Achtet mal auf den kleinen Kreis im Brick Viewer. Wird er gedr√ºckt, leuchtet er rot. Noch l√∂st das Dr√ºcken keine Aktion aus, aber wir √ºberlegen sp√§ter, welche Funktion wir damit verbinden wollen.

Und zuletzt: der Button Reset Count. Damit setzt ihr den Z√§hler zur√ºck ‚Äì eine praktische Funktion, die wir sp√§ter ebenfalls ins Programm einbauen k√∂nnen.

::: {#fig-brick-viewer-rotary-encoder layout="[[1,1]]"}
![Das Diagramm zeigt den aktuellen Wert an.](images/brick_viewer_rotary_encoder.png){.lightbox group="brick-viewer-rotary"}

![Der Button wird rot, wenn er gedr√ºckt ist.](images/brick_viewer_rotary_encoder_pressed.png){#fig-brick-viewer-rotary-encoder-pressed .lightbox group="brick-viewer-rotary"}

Die Funktionen des Rotary Encoders im Brick Viewer.
:::

Fassen wir zusammen, was unser Drehknopf (Rotary Encoder) draufhat:

1.  Er z√§hlt ‚Äì vorw√§rts und r√ºckw√§rts
2.  Er merkt, wenn ihr ihn dr√ºckt
3.  Er kann seinen Z√§hler zur√ºcksetzen

Zeit also, das Ganze in Python auszuprobieren und zu sehen, welche coolen Anwendungen wir damit bauen k√∂nnen.

## Z√§hler auslesen {#sec-numbers-read-counter .collapsable}

Der Drehknopf funktioniert √§hnlich wie der Lautst√§rkeregler einer Stereoanlage (siehe @fig-hifi-system): Dreht ihr nach rechts, wird es lauter ‚Äì nach links, leiser.

![Die gute alte Stereoanlage mit Drehknopf! Wer kennt sie nicht mehr? (Quelle: [Wikimedia](https://commons.wikimedia.org/wiki/File:Sony_XO-D20S_Midi_HiFi_system_%28white_bg%29.jpg))](images/hifi_system.jpg){#fig-hifi-system .lightbox}

Im Hintergrund ver√§ndert sich bei jeder Drehung der Wert, den der Knopf sendet ‚Äì mal h√∂her, mal niedriger, je nach Ausgangszustand. Im Brick Viewer habt ihr das schon gesehen. Probieren wir es jetzt in einem Programm aus: Der folgende Code verbindet sich mit dem Drehknopf, liest den aktuellen Wert und gibt ihn in der Konsole aus. Denkt daran, eure eigene UID einzutragen:

```{python}
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
knob = BrickletRotaryEncoderV2('WZd', ipcon) # <1>
count = knob.get_count(reset=False) # <2>
print(count)
```

1.  Wir erstellen eine virtuelle Repr√§sentation des Drehknopfs in unserem Programm, um seine Funktionen verwenden zu k√∂nnen.
2.  √úber die virtuelle Repr√§sentation des Drehknopfs k√∂nnen wir mittels `get_count()` den aktuellen Wert abfragen. Der Parameter `reset` bestimmt, ob der Z√§hler nach dem Auslesen zur√ºckgesetzt werden soll oder nicht.

Die Ausgabe sollte mit dem Wert √ºbereinstimmen, den ihr auch im Brick Viewer seht ‚Äì kein Wunder, beide nutzen dieselbe Programmierschnittstelle. Damit habt ihr die erste Funktion des Drehknopfs erfolgreich aus Python getestet.

Dreht ihr den Knopf und startet das Programm erneut, erscheint nat√ºrlich ein anderer Wert. Klar! Aber jedes Mal neu starten? Das geht besser. Die L√∂sung kennt ihr schon aus @sec-colors: eine Schleife, die das Programm so lange wiederholt, bis wir es beenden:

```{python}
while True:
    count = knob.get_count(reset=False)
    print(count)
```

Zur Erinnerung: `while True` erzeugt eine Endlosschleife. Normalerweise wollen wir so etwas vermeiden ‚Äì au√üer, wir brauchen es genau daf√ºr. Endlosschleifen sind praktisch, wenn wir kontinuierlich Daten lesen oder auf Ereignisse warten. Und keine Sorge: Mit Strg+C k√∂nnt ihr das Programm jederzeit beenden.

Wenn ihr das Programm ausf√ºhrt, werdet ihr direkt ein Problem erkennen. Die Schleife rennt f√∂rmlich und gibt nacheinander immer wieder denselben Wert aus. Nur wenn wir am Knopf drehen, √§ndert sich der Wert ‚Äì wird aber von der Schleife x-mal auf die Konsole geschrieben. Wie k√∂nnten wir das verbessern?

## Kontrollstrukturen {#sec-numbers-control-structures .collapsable}

Wie w√§re es hiermit?

```{python}
last_count = None
while True:
    new_count = knob.get_count(reset=False)

    if new_count != last_count:
        last_count = new_count
        print(last_count)
```

Gehen wir durch, was hier passiert: Zuerst weisen wir der Variable `last_count` vor dem ersten Schleifendurchlauf den Wert `None` zu. Anschlie√üend wird in jedem Durchlauf der aktuelle Z√§hlerstand ausgelesen und in der Variable `new_count` gespeichert. Danach pr√ºfen wir, ob sich der neue Wert im Vergleich zum alten unterscheidet. Da `last_count` im ersten Durchlauf `None` ist, wird die Bedingung in Zeile 5 beim Start immer `True` sein. Somit geben wir den Wert zu Beginn auf jeden Fall aus ‚Äì genau so, wie es f√ºr die Anwendung sinnvoll ist.

In den folgenden Schleifendurchl√§ufen wird nur dann etwas ausgegeben, wenn sich der Wert ver√§ndert hat, ihr also tats√§chlich am Drehknopf gedreht habt. Ansonsten bleibt die Ausgabe unver√§ndert.

Die Pr√ºfung, ob der aktuelle Wert (gespeichert in `new_count`) sich vom alten Wert unterscheidet, erfolgt in Zeile 5. Hier lernen wir auch ein neues Konzept der Programmierung kennen: die Kontrollstruktur `if`, gefolgt von einer Bedingung.

Neu ist hier die Kontrollstruktur `if`. Sie pr√ºft eine Bedingung, die ‚Äì wie ihr schon aus @sec-colors kennt ‚Äì nur `True` oder `False` sein kann. Ist sie wahr (`True`), l√§uft der einger√ºckte Code darunter. Ist sie falsch (`False`), passiert nichts.

√úbertragen auf unser Programm hei√üt das: `print(last_count)` l√§uft nur dann, wenn sich der Wert tats√§chlich ver√§ndert hat. In diesem Fall merken wir uns den neuen Wert und aktualisieren `last_count`. Beim n√§chsten Schleifendurchlauf pr√ºfen wir wieder, ob sich etwas getan hat. Meistens ist das nicht so ‚Äì und genau deshalb sehen wir nur dann eine Ausgabe, wenn wir wirklich am Knopf drehen. Ziemlich effizient, oder?

## LED-Dimmer 1.0 {#sec-numbers-led-dimmer-1 .collapsable}

Wenden wir das Gelernte an und bauen einen praktischen LED-Dimmer. Daf√ºr holen wir unsere LED aus Kapitel 1 mit dazu und kombinieren sie mit dem Drehknopf.

Die Idee ist simpel: Der Z√§hler des Knopfs steuert die Helligkeit der LED. Dreht ihr nach rechts, wird sie heller, nach links, dunkler. Wie bei der Stereoanlage in @fig-hifi-system.

Bevor wir uns an die eigentliche Anwendungslogik machen, brauchen wir Zugriff auf beide Ger√§te ‚Äì LED und Drehknopf. Dazu erweitern wir den bekannten Boilerplate-Code und speichern die Ger√§te in eigenen Variablen:

```{python}
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
knob = BrickletRotaryEncoderV2('WZd', ipcon) 
led = BrickletRGBLEDV2('ZG1', ipcon)
```

Dieser Teil muss immer am Anfang unseres Programms stehen, damit alles funktioniert. In den kommenden Beispielen setzen wir ihn als gegeben voraus und wiederholen ihn nicht jedes Mal.

Als Startpunkt nehmen wir den Code von oben, der den Z√§hlerwert auf der Konsole ausgibt. Schlie√ülich brauchen wir genau diese Information ‚Äì wann sich der Wert √§ndert und wie er aktuell steht ‚Äì auch, um die LED zu steuern.

Damit wir die LED von aus bis volle Helligkeit dimmen k√∂nnen, legen wir uns zuerst auf eine Farbe fest. Ich bin zwar kein Fan von wei√üem LED-Licht, aber f√ºr dieses Kapitel ist es am einfachsten: voll aufgedreht leuchtet die LED wei√ü, ausgedreht ist sie schwarz ‚Äì klar! Sp√§ter k√ºmmern wir uns darum, wie wir das Licht w√§rmer machen k√∂nnen.

Erinnern wir uns also: Was bedeuten die Zust√§nde An und Aus im RGB-Farbraum?

```{python}
#| code-line-numbers: false
# White
led.set_rgb_value(255, 255, 255)

# Black (off)
led.set_rgb_value(0, 0, 0)
```

Damit haben wir die beiden Extremzust√§nde festgelegt. Doch was passiert dazwischen, wenn die LED gedimmt ist? Ganz einfach: Wir lassen die drei RGB-Werte gemeinsam von 1 bis 254 hoch- oder runterlaufen. H√∂here Werte ergeben ein helleres Wei√ü, niedrigere ein dunkleres.

Setzen wir diese Erkenntnisse in Programmcode um und weisen den Z√§hlerwert den RGB-Werten der LED zu. Spoiler-Alert: Das ist etwas naiv, aber lasst uns mal schauen, was passiert und wo m√∂glicherweise Probleme auftreten:

```{python}
knob.reset()
last_count = 0

while True:
    new_count = knob.get_count(reset=False)

    if new_count != last_count:
        last_count = new_count
        print(last_count)

        # Setze RGB-Werte auf den Z√§hlerwert
        led.set_rgb_value(last_count, last_count, last_count)
```

Lasst es mal laufen und dreht voll auf oder runter! Beobachtet dabei den Wert f√ºr `last_count`. Was passiert, wenn er kleiner als Null wird? Oder wenn er gr√∂√üer als 255 wird? Bumm! Das Programm st√ºrzt ab!

Warum? Auf der Kommandzeile bekommen wir eine lange Fehlermeldung mit der folgenden Aussage ganz am Ende:

```{bash}
#| code-line-numbers: false
struct.error: ubyte format requires 0 <= number <= 255
```

Wenn man die Fehlermeldung googelt oder ChatGPT befragt, bekommt man Hilfe. Offensichtlich wird f√ºr einen RGB-Wert, den wir der Funktion `set_rgb_value()` √ºbergeben, ein bestimmter Datentyp erwartet, der `ubyte` hei√üt. Das steht f√ºr "unsigned byte" und bedeutet, dass der Wert zwischen 0 und 255 liegen muss.

Moment üßê ‚Äì was hat jetzt das Byte mit 0 bis 255 zu tun? Bisher dachten wir doch, das w√§re wegen des RGB-Codes? Stimmt auch, aber der RGB-Code liegt nicht zuf√§llig im Wertebereich von 0 bis 255.

Um das zu verstehen, m√ºssen wir das Bin√§rsystem kennen. Also los!

## Zahlensysteme {#sec-numbers-number-systems .collapsable}

Eigentlich ist es schnell erkl√§rt. Das Bin√§rsystem ist wie das Dezimalsystem, mit dem wir allt√§glich unterwegs sind ‚Äì nur nutzt es statt der Basis 10 die Basis 2. Einfach, oder? Wenn nicht, lest weiter ‚Äì das hier soll schlie√ülich ein Einf√ºhrungsbuch sein.

### Unser Dezimalsystem

Wir wenden das Dezimalsystem t√§glich intuitiv an. Es fragt sich wahrscheinlich niemand von euch, was die Systematik dahinter ist, oder? Und doch habt ihr es alle einmal in der Schule gelernt, und wir m√ºssen es an dieser Stelle etwas auffrischen. Solltet ihr mit Stellenwertsystemen\index{Stellenwertsystem} noch 100 % vertraut sein, k√∂nnt ihr diesen Abschnitt getrost √ºberspringen.

Nehmen wir eine Zahl wie die 123 als Beispiel. Wir haben sofort ein Gef√ºhl f√ºr die Zahl, wir wissen etwa, wie gro√ü sie ist. Und wenn wir es etwas genauer erkl√§ren m√ºssen, k√∂nnen die meisten von euch sicher erl√§utern, wof√ºr ‚Äì also f√ºr welchen Wert ‚Äì jede Ziffer steht. Wir beginnen mit der kleinsten Wertigkeit, also der Ziffer ganz rechts: der 3. Sie steht f√ºr die Einserstelle, und davon haben wir 3. Die n√§chste Stelle steht f√ºr die Zehner, und weil dort eine 2 steht, sind es zwanzig. Also $3+20=23$. Schlie√üen wir auch die dritte und letzte Ziffer in unsere Erl√§uterung ein: Die 1 steht f√ºr die Hunderterstelle, also $1*100=100$. Damit haben wir $100+20+3=123$. Ganz einfach und intuitiv.

::: {#fig-decimal-123 layout="[[1,1]]"}
![Im Dezimalsystem hat jede Stelle einen anderen Wert.](https://winf-hsos.github.io/university-docs/images/binary_system_decimal_calculation_123_a.png){#fig-decimal-system-calculation-123-a .lightbox}

![Durch Ausmultiplizieren errechnen wir den Wert der Zahl.](https://winf-hsos.github.io/university-docs/images/binary_system_decimal_calculation_123_b.png){#fig-decimal-system-calculation-123-b .lightbox}

Das Dezimalsystem ist ein Stellenwertsystem.
:::

Das Ganze funktioniert nicht nur mit dreistelligen Zahlen, sondern prinzipiell mit beliebig langen Zahlen. Wir wissen, dass die n√§chste Ziffer, die wir links im Beispiel in @fig-decimal-system-4123 sehen, f√ºr die Tausenderstelle steht. Die n√§chste Stelle w√ºrde f√ºr die Zehntausenderstelle stehen ‚Äì und so weiter. Warum f√§llt es uns so leicht?

Erstens, weil wir damit jeden Tag umgehen. Das Dezimalsystem ist das System, das wir am h√§ufigsten verwenden, und wir haben es von klein auf gelernt. Es ist intuitiv und einfach zu verstehen. Zweitens aber auch, weil wir die Systematik kennen: Jede Stelle ist 10-mal so viel wert wie die vorherige.

![Jede Stelle steht f√ºr eine h√∂here Potenz der Basis 10.](https://winf-hsos.github.io/university-docs/images/binary_system_decimal_calculation_4123.png){#fig-decimal-system-4123 .lightbox}

Wurde uns das Dezimalsystem von Gott gegeben? Vielleicht ‚Äì wenn man an die Sch√∂pfung glaubt[^numbers-1] und daran, dass Gott uns so geschaffen hat, wie wir sind, dann hat er implizit daf√ºr gesorgt, dass wir dezimal denkende Wesen werden. Warum? Eine Theorie besagt, dass die menschliche Anatomie, insbesondere die Anzahl der Finger, einen Einfluss auf unser Zahlensystem hatte. Z√§hlt einfach mal anhand eurer Finger durch.

[^numbers-1]: H√§nde hoch, wer daran noch glaubt!

### Das Oktalsystem

Nun gibt es auch Wesen mit weniger als zehn Fingern (und auch mit mehr?). Nehmt mal einen Cartoon-Charakter wie Mickey Mouse als Beispiel. In @fig-cartoon-character seht ihr, wie hier wahrscheinlich gez√§hlt wird. H√§tte ein Volk von Mickey-M√§usen sich auch f√ºr das Dezimalsystem entschieden?

![Cartoon-Charaktere haben nur acht Finger. Quelle: Erstellt mit ChatGPT nach @petzold_code_2022](https://winf-hsos.github.io/university-docs/images/binary_system_human_vs_cartoon.png){#fig-cartoon-character .lightbox}

Vermutlich nicht!

![Das Oktalsystem funktioniert wie das Dezimalsystem. Nur die Basis ist 8 statt 10.](https://winf-hsos.github.io/university-docs/images/binary_system_octal_123.png){#fig-octal-123 .lightbox}

### Das Bin√§rsystem {#sec-numbers-binary-system}

Treiben wir es noch ein wenig weiter auf die Spitze und nehmen ein paar Finger weg ‚Äì sagen wir bis auf zwei. Dann w√§ren wir vielleicht bei einem Delfin mit zwei Flossen, wie ihr ihn in @fig-binary-system-dolphin seht. Delfine haben sich vermutlich auf ein System geeinigt, das auch f√ºr unsere heutigen Computer die Grundlage darstellt: das Bin√§rsystem\index{Bin√§rsystem}.

![Delfine w√ºrden anders z√§hlen. Eher wie Computer.](https://winf-hsos.github.io/university-docs/images/binary_system_dolphin.png){#fig-binary-system-dolphin .lightbox}

Das Wort "bin√§r"\index{bin√§r} stammt aus dem Lateinischen und bedeutet "paarweise" oder "zu zweit". Von diesem Wort stammt auch der Name des Stellenwertsystems mit der Basis 2 ‚Äì und das nicht ohne Grund. Im Bin√§rsystem gibt es f√ºr jede Stelle genau zwei M√∂glichkeiten: 0 oder 1. Ein anderer Begriff ist √ºbrigens Dualsystem, was genau das Gleiche meint. Auch das Wort "dual" kommt von den R√∂mern und hei√üt so viel wie "zwei enthaltend".

![Eine Bin√§rziffer ist vergleichbar mit einem Lichtschalter, der an oder aus sein kann.](https://winf-hsos.github.io/university-docs/images/binary_system_light_switch.png){#fig-light-switch .lightbox .align-center}

::: {#fig-binary-110 layout="[[1,1]]"}
![](https://winf-hsos.github.io/university-docs/images/binary_system_binary_110_b.png){#fig-binary-110-b .lightbox group="binary-system"}

![](https://winf-hsos.github.io/university-docs/images/binary_system_binary_110_c.png){#fig-binary-110-c .lightbox group="binary-system"}

Das Bin√§rsystem funktioniert wie alle anderen Stellenwertsysteme auch.
:::

![](https://winf-hsos.github.io/university-docs/images/binary_system_place_value_systems.png)

### Andere Systeme

- R√∂mische Zahlen
- Tally-Schreibweise


## Bits & Bytes {#sec-numbers-bit-and-bytes .collapsable}

### Zwei Zust√§nde

Warum haben wir uns Zahlensysteme angeschaut, und was hat das mit Computern zu tun? Ganz einfach: Computer denken bin√§r. Das bedeutet, sie kennen nur zwei Zust√§nde: an oder aus, 0 oder 1.

Wir kommen sp√§ter noch einmal ausf√ºhrlich darauf zur√ºck, aber so viel schon vorweg: Eine Bin√§rziffer nennen wir im Englischen "binary digit", kurz "bit". Jetzt klingelt es, oder?

Ein Bit ist eine Informationseinheit. Nicht irgendeine, sondern die kleinste, die es gibt. Die Erkl√§rung, warum das so ist, folgt sp√§ter. Wir wollen uns an dieser Stelle die Frage stellen, was wir mit einem Bit alles anstellen k√∂nnen.

Ein Bit ist alleine ziemlich einsam und eingeschr√§nkt. Wenn sich ein Computer mit einem Bit lediglich merken kann, ob eine Lampe an oder aus ist, dann sind das genau zwei M√∂glichkeiten. Nicht besonders viel. Wir kamen aber von den Farben √ºber Zahlensysteme zu den Bits ‚Äì und unsere urspr√ºngliche Frage war, wie ein Computer mit seinen Mitteln ‚Äì also Nullen und Einsen (oder eben Bits) ‚Äì so viele unterschiedliche Farben abbilden und speichern kann. Zwei w√ºrden gerade einmal f√ºr Schwarz/Wei√ü ausreichen.

Ihr ahnt es vielleicht schon: Wir gesellen zum ersten ein zweites Bit hinzu. Und schon k√∂nnen wir vier unterschiedliche Zust√§nde abbilden: `00`, `01`, `10` und `11`. Damit k√∂nnten wir zum Beispiel die Farben Schwarz, Blau, Gr√ºn und Cyan darstellen. Etwas willk√ºrlich (warum gerade diese Farben), aber denkbar.

Was passiert, wenn wir ein drittes Bit hinzunehmen? Sind es nun sechs Zust√§nde? Nein, es sind acht: `000`, `001`, `010`, `011`, `100`, `101`, `110` und `111`. Damit k√∂nnten wir die Farben Schwarz, Blau, Gr√ºn, Cyan, Rot, Magenta, Gelb und Wei√ü darstellen (oder jede andere Kombination, die wir uns w√ºnschen).

Mit jedem zus√§tzlichen Bit k√∂nnen wir also nicht plus zwei mehr Zust√§nde abbilden, sondern wir verdoppeln unsere M√∂glichkeiten. Also m√ºssen wir mal zwei ‚Äì und nicht plus zwei ‚Äì rechnen. Das ist eine gute Nachricht, denn die Anzahl der Farben, die wir mit jedem zus√§tzlichen Bit darstellen k√∂nnen, verdoppelt sich jedes Mal.

Das halten wir fest, aber schauen wir zur√ºck auf unsere RGB-Farben und die Fehlermeldung, die wir zuletzt bekommen haben. Der Wert f√ºr eine Farbe aus dem RGB-Farbcode muss zwischen 0 und 255 liegen. Wir haben somit inklusive der Null 256 M√∂glichkeiten f√ºr jede der drei RGB-Grundfarben. Wie viele Bits ben√∂tigen wir daf√ºr? Rechnen wir es aus:

$$
\begin{aligned}
2^0 &= 1 \\
2^1 &= 2 \\
2^2 &= 4 \\
2^3 &= 8 \\
2^4 &= 16 \\
2^5 &= 32 \\
2^6 &= 64 \\
2^7 &= 128 \\
2^8 &= 256 \\
\end{aligned}
$$

Stopp! $2^8 = 256$, das gen√ºgt uns v√∂llig. Mit 8 Bits k√∂nnen wir somit 256 Zust√§nde abbilden ‚Äì genau passend f√ºr 256 Rot-, Gr√ºn- oder Blauanteile. 

### Acht Bits macht ein Byte

Und das ist kein Zufall: 8 Bits sind f√ºr Computer eine besondere Gr√∂√üe. Wir nennen eine Gruppe von 8 Bits ein Byte\index{Byte}. Und jetzt d√ºrfte es erneut klingeln.

![Ein Byte k√∂nnt ihr euch vorstellen wie acht Gl√ºhbirnen nebeneinander.](https://winf-hsos.github.io/university-docs/images/binary_system_byte_a.png){#fig-binary-system-byte-a .lightbox}

In @fig-binary-system-byte-a ist ein Byte als Reihe von acht Gl√ºhbirnen dargestellt. Ihr k√∂nnt euch vorstellen, dass Bits mit dem Wert 1 leuchten und Bits mit dem Wert 0 aus sind. Um den Wert zu ermitteln, den das Byte gerade darstellt, k√∂nnt ihr jeder Gl√ºhbirne von rechts nach links die entsprechenden Wertigkeiten der Stellen aus dem Bin√§rsystem zuweisen und die Werte addieren. Stellen, an denen die Gl√ºhbirne leuchtet, werden addiert, die anderen werden ausgelassen (@fig-binary-system-byte-b). Das Byte im gezeigten Beispiel steht somit f√ºr:

$$
32 + 8 + 1 = 41
$$

Wof√ºr steht das Byte, wenn alle Lampen leuchten? Oder anders gefragt: Was ist die gr√∂√üte Zahl, die wir mit einem Byte darstellen k√∂nnen?

$$
128+64+32+16+8+4+2+1 = 255
$$

Die Antwort √ºberrascht uns nicht, denn schlie√ülich haben wir es ja schon herausgefunden: Ein Byte erlaubt uns, Werte zwischen 0 (alle Gl√ºhbirnen aus) und 255 (alle Gl√ºhbirnen an) darzustellen. Insgesamt also 256 M√∂glichkeiten. Somit k√∂nnen wir mit 8 Gl√ºhbirnen die Intensit√§t einer der drei Grundfarben im RGB-Code darstellen.

![Jede Gl√ºhbirne steht f√ºr eine Stelle aus dem Bin√§rsystem.](https://winf-hsos.github.io/university-docs/images/binary_system_byte_b.png){#fig-binary-system-byte-b .lightbox}

Das erkl√§rt auch die Fehlermeldung von oben: Ein Byte kann Werte zwischen 0 und 255 darstellen. Wir haben im Experiment den Drehknopf voll nach oben oder nach unten gedreht, wodurch der Wert entweder gr√∂√üer als 255 oder kleiner als 0 wurde. Und damit ist es kein g√ºltiger Wert im Sinne eines Bytes mehr.

### Kilo, Mega, Giga

Ein Byte besteht aus 8 Bits. Wenn wir also von Bytes sprechen, reden wir oft auch von Kilobytes, Megabytes, Gigabytes et cetera. Diese Begriffe sind wichtig, um die Gr√∂√üe von Daten zu beschreiben. In @tbl-data-sizes seht ihr eine √úbersicht √ºber die verschiedenen Gr√∂√üenordnungen.

| Potenz (Bytes) | Ausgeschrieben | Bezeichnung (Abk√ºrzung) | Entspricht ca. |
|------------|--------------|-----------------|------------------------------|
| $10^3$ | Tausend | Kilobyte (KB) | kleine Textdatei |
| $10^6$ | Million | Megabyte (MB) | Digitales Foto |
| $10^9$ | Milliarde | Gigabyte (GB) | Film (DVD 4,7 GB) |
| $10^{12}$ | Billion | Terabyte (TB) | G√§ngige Festplattenkapazit√§t |
| $10^{15}$ | Billiarde | Petabyte (PB) | Speichervolumen Rechenzentrum |
| $10^{18}$ | Trillion | Exabyte (EB) | Internetverkehr pro Tag |
| $10^{21}$ | Trilliarde | Zettabyte (ZB) | Datenbestand weltweit (\>100 ZB) |
| $10^{24}$ | Quadrillion | Yottabyte (YB) | keine Entsprechung |

: Verschiedene Mengeneinheiten f√ºr Bytes und deren ungef√§hre Entsprechung. {#tbl-data-sizes}

Jetzt, da ihr wisst, was mit einem Byte gemeint ist, k√∂nnt ihr eine ungef√§hre Vorstellung f√ºr die Gr√∂√üenordnungen von Datenmengen entwickeln. Die ersten drei Zeilen aus @tbl-data-sizes k√∂nnt ihr selbst einmal nachvollziehen. Schaut euch dazu mal eine Textdatei an, notiert deren Gr√∂√üe und rechnet aus, wie viele Gl√ºhbirnen f√ºr die Speicherung gebraucht werden. Denkt daran: Ein Byte entspricht acht Gl√ºhbirnen.

Wir kommen in den sp√§teren Kapiteln immer wieder auf die Bits und Bytes zur√ºck, weil wir in Computern letztlich √ºberall mit diesen Einheiten arbeiten. Es ist somit gut, wenn ihr schon an dieser Stelle ein grundlegendes Verst√§ndnis f√ºr diese Konzepte entwickelt.

## LED-Dimmer 2.0 {#sec-numbers-led-dimmer-2 .collapsable}

Zur√ºck zu unserem eigentlichen Vorhaben. Wir waren gerade dabei, einen Dimmer f√ºr unsere LED zu basteln, als uns die Zahlensysteme dazwischengekommen sind. Daf√ºr haben wir jetzt ein besseres Verst√§ndnis daf√ºr, wie ein Computer Farben sieht ‚Äì n√§mlich als lange Sequenz aus Nullen und Einsen. Und zwar 24 davon, weil jede Grundfarbe ein Byte an Speicher verwendet.

### `min()` und `max()`

Was m√ºssen wir also in unserem Programm ver√§ndern, jetzt, da wir wissen, was zuvor das Problem war? Genau! Wir m√ºssen sicherstellen, dass die Werte, die wir an die LED senden, im g√ºltigen Bereich f√ºr ein Byte liegen ‚Äì und zwar zwischen 0 und 255.

```{python}
knob.reset()
last_count = 0

while True:
    new_count = knob.get_count(reset=False)

    if new_count != last_count:
        last_count = new_count

        # Clamp last_count to valid byte range
        last_count = max(0, min(255, last_count)) #<1>

        print(last_count)

        # Setze RGB-Werte auf den Z√§hlerwert
        led.set_rgb_value(last_count, last_count, last_count)
```

1. Die Funktionen `min()` und `max()` sorgen daf√ºr, dass der Wert von `last_count` immer zwischen 0 und 255 bleibt. Wenn `last_count` kleiner als 0 ist, wird er auf 0 gesetzt. Wenn er gr√∂√üer als 255 ist, wird er auf 255 gesetzt.

Die neue Logik in Zeile 9 hilft uns dabei. Nachdem wir den neuen Wert des Z√§hlers in der Variable `last_count` gespeichert haben (Zeile 6), wenden wir eine geschickte Kombination der beiden Funktionen `max()` und `min()` an, um sicherzustellen, dass der Wert im g√ºltigen Bereich bleibt. Wie funktioniert das genau? Dazu gehen wir die Zeile Schritt f√ºr Schritt durch.

Zun√§chst einmal der Ausdruck `min(255, last_count)`. Die Funktion `min()` gibt einfach den kleineren der beiden Werte zur√ºck, die ihr √ºbergeben werden. Wenn `last_count` also gr√∂√üer als 255 ist, wird 255 zur√ºckgegeben. Andernfalls wird `last_count` zur√ºckgegeben. Das Ergebnis dieser Auswertung ist gleichzeitig der zweite Wert, den wir der Funktion `max()` √ºbergeben.

Die Funktion `max()` macht genau das Gegenteil. Sie gibt den gr√∂√üeren der beiden ihr √ºbergebenen Werte zur√ºck. Zur Auswahl stehen ihr der Wert 0 und das Ergebnis der `min()`-Funktion. Das bedeutet, dass `max()` sicherstellt, dass der endg√ºltige Wert von `last_count` niemals kleiner als 0 ist.

Und voil√†! Nach Zeile 9 kann der Wert von `last_count` nur noch zwischen 0 und 255 liegen. Problem gel√∂st!

Probiert es am besten direkt aus und dreht mal voll auf! Es sollte nun kein Fehler mehr auftreten.

### Helligkeit entkoppeln

Vielleicht habt ihr es auch bemerkt, aber so richtig toll funktioniert unser Dimmer immer noch nicht. Zwar erscheint keine Fehlermeldung mehr, wenn wir endlos aufdrehen. Jedoch wird die LED auch nicht gedimmt, wenn wir wieder in die andere Richtung drehen. Der Grund daf√ºr ist einfach: Die Helligkeit der LED h√§ngt in unserem Programm direkt vom Z√§hlerstand des Drehknopfes ab. Wenn der √ºber 255 kommt, wird die Helligkeit zwar auf 255 gedeckelt, der Z√§hler wird aber im Hintergrund trotzdem weiter hochgez√§hlt. Wenn wir die LED wieder dimmen, also einen Helligkeitswert von weniger als 255 erreichen m√∂chten, dann m√ºssen wir zun√§chst mit dem Drehknopf wieder bis unter die 255 kommen.

Viel sch√∂ner w√§re es, wenn wir zwar endlos √ºberdrehen k√∂nnten, aber mit der ersten Drehung in die andere Richtung die Helligkeit der LED sofort verringern. Ein einfacher Weg w√§re, f√ºr den Z√§hlerstand des Drehknopfes analog zu `last_count` nur Werte zwischen 0 und 255 zu erlauben. Dazu k√∂nnten wir den Z√§hler ‚Äì genau wie `last_count` ‚Äì manuell auf 0 oder 255 setzen, je nachdem, ob wir gr√∂√üer als 255 oder kleiner als 0 waren. Leider bietet der Drehknopf √ºber seine Programmierschnittstelle keine solche Funktion an. Wir k√∂nnen den Wert zwar auslesen, aber nicht programmatisch ver√§ndern.

Wir m√ºssen also einen Workaround entwickeln. Eine M√∂glichkeit w√§re, die Helligkeit unabh√§ngig vom Z√§hlerstand zu verwalten und daf√ºr eine eigene Variable `brightness` einzuf√ºhren. Wir k√∂nnten den Wert von `brightness` dann erh√∂hen oder verringern, wenn wir eine Drehung in die eine oder andere Richtung erkannt haben.

Um zu erkennen, ob und in welche Richtung der Drehknopf gedreht wurde, k√∂nnen wir die Differenz zwischen dem aktuellen und dem letzten Z√§hlerstand betrachten. Sie gibt uns direkt Aufschluss: Ist die Differenz positiv, wurde der Knopf nach oben gedreht, ist sie negativ, wurde er nach unten gedreht.

```{python}
knob.reset()
last_count = 0

brightness = 0 # <1>
led.set_rgb_value(brightness, brightness, brightness) 

while True:
    new_count = knob.get_count(reset=False)

    if new_count != last_count:
        diff = new_count - last_count # <2>
        last_count = new_count

        # Adjust brightness
        brightness += diff # <3>
        brightness = max(0, min(255, brightness))

        # Setze RGB-Werte auf den Z√§hlerwert
        led.set_rgb_value(brightness, brightness, brightness)

        print(f"Brightness / Counter: {brightness} / {new_count}") # <4>
```

1. Die neue Variable `brightness` zu Beginn mit 0 initialisieren. Die LED soll aus sein.
2. Hier ermitteln wir die Differenz zwischen dem aktuellen und dem letzten Z√§hlerstand und speichern sie in der Variable `diff`.
3. Wir passen die Helligkeit an, indem wir `brightness` um `diff` erh√∂hen oder verringern. Dabei stellen wir sicher, dass der Wert zwischen 0 und 255 bleibt.
4. Zur √úberpr√ºfung geben wir beide Variablen aus. Wenn wir den Wertebereich 0‚Äì255 verlassen, gehen die Werte der beiden Variablen auseinander.

### Konstanten

Das sieht schon sehr gut aus! Unser Dimmer ist fast fertig, die grundlegende Funktionalit√§t l√§uft robust. Eine Kleinigkeit st√∂rt mich noch: Der Dimmer reagiert nur sehr langsam, und wir m√ºssen scheinbar endlos drehen, um die LED auf die volle Helligkeit zu bekommen. K√∂nnen wir das beschleunigen?

Das ist nat√ºrlich eine rhetorische Frage ‚Äì in der Programmierung k√∂nnen wir so gut wie alles umsetzen. Und in diesem Fall ist es sogar recht einfach. Damit die LED schneller hell oder dunkel wird, wenn wir am Drehknopf drehen, k√∂nnen wir die Anpassung der Helligkeit einfach verst√§rken. Momentan wird die Variable `brightness` um die Differenz des Z√§hlerstands erh√∂ht oder verringert. Wir k√∂nnten stattdessen einen festen, h√∂heren Schrittwert definieren, um die Helligkeit schneller zu √§ndern.

Dazu definieren wir eine neue Variable, die eine Besonderheit hat. Wir geben ihr den Namen `STEP`, der nur aus Gro√übuchstaben besteht (Zeile 3). Gem√§√ü der [Regeln f√ºr die Bennung von Variablen in Python](https://docs.python.org/3/reference/lexical_analysis.html#identifiers "Regeln f√ºr Variablennamen in Python") werden Namen in GROSSBUCHSTABEN √ºblicherweise f√ºr Konstanten verwendet ‚Äì und tats√§chlich ist `STEP` genau genommen auch keine Variable, sondern eine **Konstante**\index{Konstante}.

Eine Konstante unterscheidet sich dadurch, dass ihr Wert einmal festgelegt wird und sich danach nicht mehr √§ndert. In unserem Fall wollen wir, dass `STEP` immer den Wert 10 hat. Konstanten definieren wir typischerweise zu Beginn eines Python-Programms, damit man einen schnellen √úberblick √ºber alle definierten Konstanten und ihre Werte bekommen kann.

Es ist wichtig zu verstehen, dass der fixe Wert einer Konstante sich nur auf die Ausf√ºhrung des Programms bezieht. Zwischen mehreren Ausf√ºhrungen desselben Programms kann der Wert einer Konstante ge√§ndert werden. Zum Beispiel k√∂nnten wir als Hersteller des LED-Dimmers f√ºr eine neue Version entscheiden, dass dieser sich noch schneller dimmen lassen soll, und wir erh√∂hen den Wert f√ºr `STEP` auf 20. Oder der Benutzer k√∂nnte diesen Wert √ºber die Einstellungen der hypothetischen Dimmer-App anpassen.

Wenn wir ‚Äì wie in Zeile 15 gezeigt ‚Äì die Differenz des Z√§hlers mit der Schrittgr√∂√üe multiplizieren, k√∂nnen wir die Anpassung der Helligkeit verst√§rken.

```{python}
#| lst-label: lst-dim-led
#| lst-cap: Der fertige LED-Dimmer (ohne Boilerplate-Code)
knob.reset()
brightness = 0
STEP = 10 # <1>
led.set_rgb_value(brightness, brightness, brightness) 

last_count = 0
while True:
    new_count = knob.get_count(reset=False)

    if new_count != last_count:
        diff = new_count - last_count
        last_count = new_count

        # Adjust brightness
        brightness += diff * STEP # <2>
        brightness = max(0, min(255, brightness))

        # Setze RGB-Werte auf den Z√§hlerwert
        led.set_rgb_value(brightness, brightness, brightness)

        print(f"Brightness / Counter: {brightness} / {new_count}")
```

1. Hier definieren wir eine Konstante `STEP` und weisen ihr den Wert 10 zu.
2. Die Helligkeit wird nun um `diff * STEP` angepasst, was bedeutet, dass jede Drehung des Knopfes einen gr√∂√üeren Einfluss auf die Helligkeit hat.

Mit dem LED-Dimmer haben wir die zentrale Funktion des Drehknopfes zur Gen√ºge kennengelernt. Das Ger√§t hat aber noch eine andere Funktion.

## Druckknopf auslesen {#sec-numbers-button-reading .collapsable}

Neben dem Z√§hler besitzt der Drehknopf (der Name sagt es schon) noch eine Funktion, n√§mlich die eines einfachen Druckknopfes. Wir haben es weiter oben in @sec-numbers-first-steps mit dem Brick Viewer schon ausprobiert: Der Drehknopf l√§sst sich dr√ºcken und erzeugt eine haptische R√ºckmeldung, ein leichtes Knacken. Im Brick Viewer wurde der kleine Kreis auf der rechten Seite dann rot eingef√§rbt.

Selbstverst√§ndlich k√∂nnen wir den Zustand des Buttons auch aus einem Programm heraus abfragen. Dazu bietet uns der Drehknopf eine Methode `is_pressed()` an:

```{python}
while True:
    if knob.is_pressed():
        print("Button pressed")
    else:
        print("Button not pressed")
```

Die Funktion liefert `True` zur√ºck, wenn der Button gerade gedr√ºckt ist, und ansonsten `False`. Das k√∂nnen wir wunderbar nutzen und dar√ºber eine Bedingung formulieren, um entweder "Button pressed" oder "Button not pressed" auf der Konsole auszugeben. Ihr erinnert euch bestimmt an das `if`-Statement aus @sec-numbers-control-structures. Das ist genau das, was wir jetzt brauchen!


```{python}
#| lst-cap: Ein erster Test des Drehknopf-Buttons.
#| lst-label: lst-button-test
button_pressed_before = False # <1>
while True:
    button_pressed_after = knob.is_pressed()

    if button_pressed_before == True and button_pressed_after == False: # <2>
        print("Button was pressed and released") # <3>
    
    button_pressed_before = button_pressed_after # <4>
```

1. Wir initialisieren eine Variable `button_pressed_before`, die den vorherigen Zustand des Buttons speichert. Am Anfang gehen wir mal davon aus, dass er nicht gedr√ºckt ist.
2. Mit dem `if`-Statement √ºberpr√ºfen wir, ob der Button logelassen wurde. Dazu muss der vorherige Zustand `True` und der aktuelle Zustand `False` sein.
3. Wenn der Button soeben losgelassen wurde, geben wir eine entsprechende Information auf der Konsole aus.
4. Am Ende der Schleife aktualisieren wir den vorherigen Zustand `button_pressed_before`, damit er den aktuellen Zustand f√ºr die n√§chste Iteration speichert.

Das reicht f√ºrs Erste ‚Äì der Button kann tats√§chlich nicht mehr als das. Reicht aber auch: Damit k√∂nnen wir unserem Dimmer schon einen zus√§tzlichen Mehrwert verleihen. Schlie√ülich kann unsere LED nicht nur wei√ü leuchten.

## LED-Dimmer 3.0 {#sec-numbers-led-dimmer-3 .collapsable}

W√§re es nicht praktisch, wenn wir das Licht der LED nicht nur dimmen, sondern auch den Farbton ver√§ndern k√∂nnten? Wei√ües Licht ist am Abend bekanntlich nicht empfehlenswert, und gr√ºnes Licht soll beruhigend wirken.

Lasst uns unseren Dimmer so erweitern, dass per Knopfdruck der Farbton gewechselt werden kann. F√ºrs Erste wollen wir die Farben Wei√ü, Gelb und Gr√ºn anbieten. Das l√§sst sich sp√§ter beliebig erweitern.

### Farbe per Variable steuern

Der Ausgangspunkt f√ºr unser dimmbares Stimmungslicht ist der Dimmer aus @lst-dim-led. Von hier aus f√ºgen wir Schritt f√ºr Schritt die Logik f√ºr den Farbwechsel per Button ein. Lasst uns aber zun√§chst ganz ohne Button versuchen, die Farbe der LED zu √§ndern.

Bisher haben wir es uns einfach gemacht und die LED in Wei√ü leuchten lassen. Dazu mussten wir nur jeden der drei RGB-Farbkan√§le auf den gleichen Wert setzen. Wenn wir neben Wei√ü auch Gelb und Gr√ºn anbieten wollen, m√ºssen wir die Farbkan√§le unterschiedlich ansteuern. F√ºr Gelb setzen wir den roten und den gr√ºnen Kanal auf den gleichen Wert, w√§hrend der blaue Kanal auf 0 bleibt. F√ºr Gr√ºn setzen wir den gr√ºnen Kanal auf den gleichen Wert und die anderen beiden auf 0. Um so eine Logik umzusetzen, haben wir das passende Instrument bereits in unserem Werkzeugkasten: [Kontrollstrukturen](#sec-numbers-control-structures).

Nehmen wir mal an, wir h√§tten eine Variable `color`, auf der die aktuelle Farbe gespeichert ist, in der die LED leuchten soll. Sie k√∂nnte also die Werte "white", "yellow" oder "green" annehmen. Dann k√∂nnten wir mit `if`-Statements die notwendige Logik umsetzen:

```{python}
if color == "white":
    led.set_rgb_value(brightness, brightness, brightness)
if color == "yellow":
    led.set_rgb_value(brightness, brightness, 0)
if color == "green":
    led.set_rgb_value(0, brightness, 0)
```

Erinnert euch, dass der Code nach einem `if` nur dann ausgef√ºhrt wird, wenn die vorangegangene Bedingung erf√ºllt ist. Da die Variable `color` zu einem Zeitpunkt nur einen der drei Werte annehmen kann, muss genau eine der drei Bedingungen erf√ºllt sein und alle anderen entsprechend nicht.

Wenn wir jetzt zu Beginn unseres Programms `color` auf einen der drei Werte setzen, k√∂nnen wir die Logik schnell mal testen:

```{python}
color = "white"

if color == "white":
    led.set_rgb_value(brightness, brightness, brightness)
if color == "yellow":
    led.set_rgb_value(brightness, brightness, 0)
if color == "green":
    led.set_rgb_value(0, brightness, 0)
```

Alles sollte so sein wie zuvor, die LED leuchtet wei√ü.

```{python}
color = "yellow"
```

Jetzt sollte beim Start des Programms die LED gelb leuchten. Dasselbe probiert mal mit "green" aus, das d√ºrfte auch funktionieren.

### Farbe per Knopfdruck √§ndern

Die aktuelle Farbe in einer Variable zu speichern ist eine gute Idee gewesen. Darauf k√∂nnen wir aufbauen und den Button f√ºr den Wechsel der Farbe nutzen. Aber wie?

Zun√§chst erinnern wir uns an die Logik aus @lst-button-test, in dem wir den Button bereits aus einem Programm heraus getestet haben. Dort haben wir eine Logik gebastelt, die erkennt, wenn der Button gedr√ºckt und wieder losgelassen wird. Wenn das der Fall war, wurde der Wert "Button gedr√ºckt" auf der Konsole ausgegeben. K√∂nnten wir diese Logik nicht verwenden, um statt etwas auszugeben einfach die Farbe zu wechseln?

Nat√ºrlich k√∂nnen wir das. Passen wir den Code entsprechend an:

```{python}
button_pressed_before = False
while True:
    button_pressed_after = knob.is_pressed()

    if button_pressed_before == True and button_pressed_after == False:
        if color == "white":
            color = "yellow"
        elif color == "yellow":
            color = "green"
        elif color == "green":
            color = "white"

    button_pressed_before = button_pressed_after
```

Wieder ein Haufen voller `if`s - aber es sollte funktionieren. Gehen wir es einmal durch: Wenn der Button losgelassen wurde (Zeile 5) gelangen wir zur Pr√ºfung der `if`-Statements. Im ersten Fall wird gepr√ºft, ob die LED gerade Wei√ü leuchtet (`color == "white"`). Ist das der Fall, dann wechseln wir jetzt auf Gelb. Im zweiten Schritt sehen wir ein `elif`, das sehr √§hnlich zu einem `if` ist, mit der Einschr√§nkung, dass es nur √ºberhaupt gepr√ºft wird, wenn das vorherige `if` nicht schon wahr war. Das macht in diesem Fall einen gro√üen Unterschied (im Vergleich zu weiter oben, als wir einfache `if`-Statements verwendet haben, um die Farbe der LED mit `set_rgb_color` zu setzen). √úberlegt mal, was passieren w√ºrde, wenn wir hier folgenden Code einsetzen w√ºrden:

```{python}
if color == "white":
    color = "yellow"
if color == "yellow":
    color = "green"
if color == "green":
    color = "white"

```

Geht das mal im Kopf durch. Wenn `color` aktuell den Wert `white` hat, dann wird durch das erste `if` der Wert auf `yellow` gesetzt. Anschlie√üend wird das zweite `if` gepr√ºft, das jetzt wahr ist, und der Wert wird auf `green` gesetzt. Das dritte `if` wird dann also ebenfalls wahr sein, und der Wert wird wieder auf `white` gesetzt. Im Endeffekt haben wir also nichts gewonnen, die LED bliebe wei√ü. Hier ist die Verwendung von `elif` entscheidend. Denn ein `elif` wird nur gepr√ºft, wenn das vorherige `if` oder `elif` nicht wahr war. Nach der ersten Anpassung w√§re hier also Schluss und die Farbe ist wie gew√ºnscht Gelb.

F√ºgen wir alles zusammen - die neue Logik zum setzen der Farben basierend auf der Varible `color`und die Logik zum √Ñndern der Variable, sowie die Logik des Dimmers aus @lst-dim-led:

```{python}
#| lst-cap: Farbwechsel und Helligkeitsanpassung in einem Programm.
#| lst-label: lst-color-brightness
button_pressed_before = False

# 1. Main loop to keep program running
while True:
    new_count = knob.get_count(reset=False)
    button_pressed_after = knob.is_pressed()

    # 2. Logic for color change on button release
    if button_pressed_before == True and button_pressed_after == False:
        if color == "white":
            color = "yellow"
        elif color == "yellow":
            color = "green"
        elif color == "green":
            color = "white"

        # Update LED to reflect new color
        if color == "white":
            led.set_rgb_value(brightness, brightness, brightness)
        if color == "yellow":
            led.set_rgb_value(brightness, brightness, 0)
        if color == "green":
            led.set_rgb_value(0, brightness, 0)

    button_pressed_before = button_pressed_after

    # 3. Logic for brightness adjustment
    if new_count != last_count:
        diff = new_count - last_count
        last_count = new_count

        # Adjust brightness
        brightness += diff * STEP
        brightness = max(0, min(255, brightness))

        # Update LED to reflect new color
        if color == "white":
            led.set_rgb_value(brightness, brightness, brightness)
        if color == "yellow":
            led.set_rgb_value(brightness, brightness, 0)
        if color == "green":
            led.set_rgb_value(0, brightness, 0)

        print(f"Brightness / Counter: {brightness} / {new_count}")
```

Schaut euch den Code in Ruhe an und pr√ºft, ob ihr ihn Zeile f√ºr Zeile nachvollziehen k√∂nnt. An dieser Stelle hat unser Programm schon eine betr√§chtliche Gr√∂√üe angenommen, und so langsam wird es un√ºbersichtlich. Versuchen wir also, Struktur hineinzubringen. Im Wesentlichen besteht das Programm aus drei Teilen, jeden habe ich mit einem vorangestellten Kommentar markiert:

1. Hauptschleife, um das Programm am Laufen zu halten
2. Logik f√ºr Farbwechsel bei Tastenfreigabe
3. Logik zur Helligkeitsanpassung

In der Hauptschleife wird am Anfange immer wieder der aktuelle Z√§hlerstand und der Zustand des Buttons abgefragt und auf jeweils einer Variable gespeichert. Diese Werte ben√∂tigen wir, um zu entscheiden, ob wir die Farbe √§ndern oder die Helligkeit anpassen m√ºssen.

Um einen potenziellen Farbwechsel k√ºmmert sich der zweite Block, der mit dem `if button_pressed_before == True ...` beginnt. Die Bedingung pr√ºft, ob der Button gerade aus dem gedr√ºckten Zustand in den nicht gedr√ºckten Zustand wechselt, der Benutzer ihn also gerade losgelassen hat. In diesem Moment soll die Farbe gewechselt werden. Die Logik daf√ºr haben wir gerade entwickelt.

Um die Helligkeitsanpassung k√ºmmert sich dann der dritte und letzte gr√∂√üere Block. Er beginnt mit `if new_count != last_count`, was pr√ºft, ob der Drehknop bet√§tigt wurde. Wenn ja, dann wird die Helligkeit entsprechend der Differenz angepasst. Diese Logik haben wir in @sec-numbers-led-dimmer-2 zusammen entwickelt.

Wer von euch jetzt ganz genau hinsieht, der erkennt, dass die Bl√∂cke 2 und 3 zum Teil identischen Code ausf√ºhren. In der Programmierung ist das eine rote Flagge üö©! Lasst uns dar√ºber sprechen, warum!

## Funktionen {#sec-numbers-functions .collapsable}

In der Programmierung m√∂chten wir Wiederholungen um jeden Preis vermeiden. Wir sprechen auch vom \gloss{DRY-Prinzip}{Grundprinzip in der Programmierung, Code m√∂glichst nicht zu wiederholen.}{Programmierung}, was f√ºr *Don't Repeat Yourself* steht. Wenn wir feststellen, dass wir denselben Code an mehreren Stellen verwenden, sollten wir dar√ºber nachdenken, etwas zu ver√§ndern. Warum? Und was?

Nehmen wir in unserem Beispiel an, wir f√ºhren eine vierte Farbe ein, sagen wir Blau. Dann m√ºssten wir den Code in den Bl√∂cken 2 und 3 anpassen, um die neue Farbe zu ber√ºcksichtigen. Das bedeutet, dass wir den gleichen Code an mehreren Stellen √§ndern m√ºssten, was fehleranf√§llig und m√ºhsam ist. Zwei mag noch nicht nach einem Problem klingen, aber selbst hier zeigt sich das Problem der Wiederholung. Wird eine Stelle vergessen, ist der Code inkonsistent und funktioniert nicht mehr wie gew√ºnscht.

Die L√∂sung liegt darin, h√§ufig verwendeten Code in Funktionen auszulagern. \gloss{Funktionen}{Benannter Codeblock zur L√∂sung eines definierten Problems.}{Programmierung} sind ein m√§chtiges Werkzeug in der Programmierung. Sie erm√∂glichen es uns, Codebl√∂cke zu definieren, die wir immer wieder verwenden k√∂nnen, ohne sie jedes Mal neu schreiben zu m√ºssen. Funktionen helfen uns dabei, unseren Code sauberer, √ºbersichtlicher und wartbarer zu gestalten.

Im @lst-color-brightness wird dieser Teil an zwei Stellen wiederholt:

```{python}
if color == "white":
    led.set_rgb_value(brightness, brightness, brightness)
if color == "yellow":
    led.set_rgb_value(brightness, brightness, 0)
if color == "green":
    led.set_rgb_value(0, brightness, 0)
```

Zeit, diesen Code nur einmal zu schreiben! Machen wir daraus eine Funktion. Wie das geht? Im Prinzip m√ºssen wir vier Dinge kl√§ren:

1. Was soll die Funktion tun?
2. Wie sieht das Ergebnis aus?
3. Was ben√∂tigt die Funktion, um ihre Aufgabe zu erledigen?
4. Wie heisst die Funktion?


![Funktionen folgen einem Eingabe-Verarbeitung-Ausgabe (EVA) Schema.](https://winf-hsos.github.io/university-docs/images/problem_solving_input_function_output.png){#fig-numbers-input-function-output .lightbox}

```{python}
def set_led_color(color, brightness):
    if color == "white":
        led.set_rgb_value(brightness, brightness, brightness)
    if color == "yellow":
        led.set_rgb_value(brightness, brightness, 0)
    if color == "green":
        led.set_rgb_value(0, brightness, 0)

```

In @lst-dim-led-color seht ihr den fertigen Code f√ºr den Dimmer mit Farbwechsel per Knopfdruck.

```{python}
#| lst-cap: Der fertige Dimmer mit Farbwechsel per Knopfdruck.
#| lst-label: lst-dim-led-color
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
knob = BrickletRotaryEncoderV2('WZd', ipcon) 
led = BrickletRGBLEDV2('ZG1', ipcon)

knob.reset()
brightness = 0
STEP = 10
led.set_rgb_value(brightness, brightness, brightness) 
last_count = 0

color = "white"
button_pressed_before = False

def set_led_color(color, brightness):
    if color == "white":
        led.set_rgb_value(brightness, brightness, brightness)
    if color == "yellow":
        led.set_rgb_value(brightness, brightness, 0)
    if color == "green":
        led.set_rgb_value(0, brightness, 0)

while True:
    new_count = knob.get_count(reset=False)
    button_pressed_after = knob.is_pressed()

    # If button changes from pressed to not pressed
    if button_pressed_before == True and button_pressed_after == False:
        if color == "white":
            color = "yellow"
        elif color == "yellow":
            color = "green"
        elif color == "green":
            color = "white"

        print(f"Color changed to: {color}")
        set_led_color(color, brightness)   

    button_pressed_before = button_pressed_after

    if new_count != last_count:
        diff = new_count - last_count
        last_count = new_count

        # Adjust brightness
        brightness += diff * STEP
        brightness = max(0, min(255, brightness))

        print(f"Brightness / Counter: {brightness} / {new_count}")
        set_led_color(color, brightness)
```