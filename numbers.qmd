---
abstract: |
    Unser Regenbogen aus dem ersten Kapitel war nur der Anfang. Doch wie speichert der Computer eigentlich die vielen RGB-Werte f√ºr all diese Farben? Das f√ºhrt uns zum Bin√§rsystem: Mit nur Einsen und Nullen und in kleinen P√§ckchen, den Bytes ‚Äì kann er jeden Farbton unseres Regenbogens abbilden. Und noch viel mehr.
abstract-title: ""
---

# Zahlen üî¢ {#sec-numbers}

## Lernziele {.unnumbered}

Unsere wichtigsten Lernziele in diesem Kapitel sind:

- Wir lernen Kontrollstrukturen kennen, mit denen wir unsere Programm steuern k√∂nnen.
- Wir verstehen das Bin√§rsystem und wissen, wie der Computer Zahlen speichert.
- Wir f√ºhren das Byte als zentrale Einheit f√ºr Informationen in Computern ein. 

## Experimentaufbau {.unnumbered}

Das erste Experiment in @sec-colors war schon ein ordentlicher Einstieg! In diesem Kapitel legen wir noch eine Schippe drauf: Unsere Hardware bekommt ein neues Teil ‚Äì einen Drehknopf ([Rotary Encoder Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/Rotary_Encoder_V2.html)). Den schraubt ihr einfach neben die LED, wie in @fig-setup-rgb-led-rotary-encoder gezeigt.

::: {#fig-setup-rgb-led-rotary-encoder layout="[[1], [1,1], [1,1]]"}

![Seitenansicht.](images/master_brick_with_led_and_rotary_01.jpg){#fig-setup-rgb-led-a .lightbox group="setup-rgb-led"}

![Draufsicht.](images/master_brick_with_led_and_rotary_02.jpg){#fig-setup-rgb-led-b .lightbox group="setup-rgb-led"}

![Nahaufnahme des Rotary Encoders.](images/master_brick_with_led_and_rotary_03.jpg){#fig-setup-rgb-led-c .lightbox group="setup-rgb-led"}

![Seitenansicht.](images/master_brick_with_led_and_rotary_04.jpg){#fig-setup-rgb-led-d .lightbox group="setup-rgb-led"}

![Untenansicht.](images/master_brick_with_led_and_rotary_05.jpg){#fig-setup-rgb-led-e .lightbox group="setup-rgb-led"}

Einfaches Setup mit einem Mikrocontroller, der LED und einem Drehknopf.

:::

## Erste Schritte mit dem Drehknopf

Wie bei der LED werfen wir zuerst einen Blick auf den neuen Drehknopf im Brick Viewer. Schlie√üt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf *Connect*. Im Setup-Tab sollte nun neben der LED auch der Rotary Encoder auftauchen. Denkt daran: Dort findet ihr auch die UID eurer Ger√§te ‚Äì die braucht ihr gleich f√ºr euer Programm.

![Der Brick Viewer nach dem Connect.](images/exp_2_brick_viewer_after_connect.png){#fig-exp-2-brick-viewer-after-connect .lightbox group="brick-viewer-rotary"}

Wechselt nun in den Tab f√ºr den Drehknopf, wo ihr ihn direkt testen k√∂nnt: Ihr seht den aktuellen Z√§hlwert, der kann positiv oder negativ sein, je nachdem, wie oft und in welche Richtung ihr gedreht habt. Daneben zeigt ein Diagramm die zeitliche Entwicklung.

Doch der Knopf kann mehr als nur z√§hlen: Ihr k√∂nnt ihn auch dr√ºcken. Achtet mal auf den kleinen Kreis im Brick Viewer. Wird er gedr√ºckt, leuchtet er rot. Noch l√∂st das Dr√ºcken keine Aktion aus, aber wir √ºberlegen sp√§ter, welche Funktion wir damit verbinden wollen.

Und zuletzt: Der Button Reset Count. Damit setzt ihr den Z√§hler zur√ºck, eine praktische Funktion, die wir sp√§ter ebenfalls ins Programm einbauen k√∂nnen.

::: {#fig-brick-viewer-rotary-encoder layout="[[1,1]]"}

![Das Diagramm zeigt den aktuellen Wert an.](images/brick_viewer_rotary_encoder.png){#fig-brick-viewer-rotary-encoder .lightbox group="brick-viewer-rotary"}

![Der Button wir rot, wenn er gedr√ºckt ist.](images/brick_viewer_rotary_encoder_pressed.png){#fig-brick-viewer-rotary-encoder-pressed .lightbox group="brick-viewer-rotary"}

Die Funktionen des Rotary Encoders im Brick Viewer.

:::

Fassen wir zusammen, was unser Drehknopf (Rotary Encoder) draufhat:

1. Er z√§hlt ‚Äì vorw√§rts und r√ºckw√§rts
2. Er merkt, wenn ihr ihn dr√ºckt
3. Er kann seinen Z√§hler zur√ºcksetzen

Zeit also, das Ganze in Python auszuprobieren und zu sehen, welche coolen Anwendungen wir damit bauen k√∂nnen.

## Hoch- und Runterz√§hlen

Der Drehknopf funktioniert √§hnlich wie der Lautst√§rkeregler einer Stereoanlage (siehe @fig-hifi-system): Dreht ihr nach rechts, wird es lauter ‚Äì nach links, leiser.

![Die gute alte Stereoanlage mit Drehknopf! Wer kennt sie nicht mehr? (Quelle: [Wikimedia](https://commons.wikimedia.org/wiki/File:Sony_XO-D20S_Midi_HiFi_system_%28white_bg%29.jpg))](images/hifi_system.jpg){#fig-hifi-system .lightbox}

Im Hintergrund ver√§ndert sich bei jeder Drehung der Wert, den der Knopf sendet ‚Äì mal h√∂her, mal niedriger, je nach Ausgangszustand. Im Brick Viewer habt ihr das schon gesehen. Probieren wir es jetzt in einem Programm aus: Der folgende Code verbindet sich mit dem Drehknopf, liest den aktuellen Wert und gibt ihn in der Konsole aus. Denkt daran, eure eigene UID einzutragen:

```{python}
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
knob = BrickletRotaryEncoderV2('WZd', ipcon) # <1>
count = knob.get_count(reset=False) # <2>
print(count)
```
1. Wir erstellen eine virtuelle Repr√§sentation des Drehknopfs in unserem Programm, um seine Funktionen verwenden zu k√∂nnen.
2. √úber die virtuelle Repr√§sentation des Drehknopfs k√∂nnen wir mittels `get_count()` den aktuellen Wert abfragen. Der Parameter `reset` bestimmt, ob der Z√§hler nach dem Auslesen zur√ºckgesetzt werden soll oder nicht.

Die Ausgabe sollte mit dem Wert √ºbereinstimmen, den ihr auch im Brick Viewer seht ‚Äì kein Wunder, beide nutzen dieselbe Programmierschnittstelle. Damit habt ihr die erste Funktion des Drehknopfs erfolgreich aus Python getestet.

Dreht ihr den Knopf und startet das Programm erneut, erscheint nat√ºrlich ein anderer Wert. Klar! Aber jedes Mal neu starten? Das geht besser. Die L√∂sung kennt ihr schon aus @sec-colors: eine Schleife, die das Programm so lange wiederholt, bis wir es beenden:

```{python}
while True:
    count = knob.get_count(reset=False)
    print(count)
```

Zur Erinnerung: `while True` erzeugt eine Endlosschleife. Normalerweise wollen wir so etwas vermeiden ‚Äì au√üer, wir brauchen es genau daf√ºr. Endlosschleifen sind praktisch, wenn wir kontinuierlich Daten lesen oder auf Ereignisse warten. Und keine Sorge: Mit Strg+C k√∂nnt ihr das Programm jederzeit beenden.

Wenn ihr das Programm ausf√ºhrt, werdet ihr direkt ein Problem erkennen. Die Schleife rennt f√∂rmlich und gibt nacheinander immer wieder den selben Wert aus. Nur wenn wir am Knopf drehen √§ndert sich der Wert, wird aber von der Schleife X-Male auf die Konsole geschrieben. Wie k√∂nnten wir das verbessern?

## Kontrollstrukturen

Wie w√§re es hiermit?

```{python}
last_count = None
while True:
    new_count = knob.get_count(reset=False)

    if new_count != last_count:
        last_count = new_count
        print(last_count)
```

Gehen wir durch, was hier passiert: Zuerst setzen weisen wir der Variable `last_count` den Wert `None` zu, und zwar vor dem ersten Schleifendurchlauf. Anschlie√üend wird in der Schleife in jedem Durchlauf der aktuelle Z√§hlerwert ausgelesen und auf der zweiten Variable `new_count` gespeichert. Danach pr√ºfen wir, ob sich der neue Wert im Vergleich zum alten Wert ver√§ndert hat. Da auf dem alten Wert `last_count` im ersten Durchlauf `None` ist, wird die Bedingung in Zeile 5 im ersten Durchlauf immer `True` sein. Somit geben wir den Wert zu Beginn auf jeden Fall aus, was im Sinne der Anwendung ist.

Anschlie√üend wird in den darauffolgenden Schleifendurchl√§ufen aber nur etwas ausgegeben, wenn der Wert sich ver√§ndert hat, also der Benutzer tats√§chlich am Drehknopf gedreht hat. Ansonsten bleibt die Ausgabe unver√§ndert.

Die Pr√ºfung, ob der aktuelle Wert, den wir auf der zweiten Variable `new_count` speichern, sich vom alten Wert unterscheidet, erfolgt in Zeile 5. Hier lernen wir auch neues Konzept der Programmierung kennen, die Kontrollstruktur mit `if`, gefolgt von einer Bedingung.

Neu ist hier die Kontrollstruktur `if`. Sie pr√ºft eine Bedingung, die, wie ihr schon aus @sec-colors kennt, nur `True` oder `False` sein kann. Ist sie wahr (`True`), l√§uft der einger√ºckte Code darunter. Ist sie falsch (`False`), passiert nichts. 

√úbertragen auf unser Programm hei√üt das: `print(count)` l√§uft nur dann, wenn sich der Wert tats√§chlich ver√§ndert hat. In diesem Fall merken wir uns den neuen Wert und aktualisieren count. Beim n√§chsten Schleifendurchlauf pr√ºfen wir wieder, ob sich etwas getan hat. Meistens ist das nicht so ‚Äì und genau deshalb sehen wir nur dann eine Ausgabe, wenn wir wirklich am Knopf drehen. Ziemlich effizient, oder?

## Ein LED-Dimmer

Wenden wir das Gelernte an und bauen einen praktischen LED-Dimmer. Daf√ºr holen wir unsere LED aus Kapitel 1 mit dazu und kombinieren sie mit dem Drehknopf.

Die Idee ist simpel: Der Z√§hler des Knopfs steuert die Helligkeit der LED. Dreht ihr nach rechts, wird sie heller, nach links, dunkler. Wie bei der Stereoanlage in @fig-hifi-system.

Bevor wir uns an die eigentliche Anwendungslogik machen, brauchen wir Zugriff auf beide Ger√§te ‚Äì LED und Drehknopf. Dazu erweitern wir den bekannten Boilerplate-Code und speichern die Ger√§te in eigenen Variablen:

```{python}
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
knob = BrickletRotaryEncoderV2('WZd', ipcon) 
led = BrickletRGBLEDV2('ZG1', ipcon)
```

Dieser Teil muss immer am Anfang unseres Programms stehen, damit alles funktioniert. In den kommenden Beispielen setzen wir ihn als gegeben voraus und wiederholen ihn nicht jedes Mal.

## 0 bis 255

Als Startpunkt nehmen wir den Code von oben, der den Z√§hlerwert auf der Konsole ausgibt. Schlie√ülich brauchen wir genau diese Information ‚Äì wann sich der Wert √§ndert und wie er aktuell steht ‚Äì auch, um die LED zu steuern.

Damit wir die LED von aus bis volle Helligkeit dimmen k√∂nnen, legen wir uns zuerst auf eine Farbe fest. Ich bin zwar kein Fan von wei√üem LED-Licht, aber f√ºr dieses Kapitel ist es am einfachsten: voll aufgedreht leuchtet die LED wei√ü, ausgedreht ist sie schwarz ‚Äì klar! Sp√§ter k√ºmmern wir uns darum, wie wir das Licht w√§rmer machen k√∂nnen.

Erinnern wir uns also: Was bedeuten die Zust√§nde An und Aus im RGB-Farbraum?

```{python}
#| code-line-numbers: false
# White
led.set_rgb_value(255, 255, 255)

# Black (off)
led.set_rgb_value(0, 0, 0)
```

Damit haben wir die beiden Extremzust√§nde festgelegt. Doch was passiert dazwischen, wenn die LED gedimmt ist? Ganz einfach: Wir lassen die drei RGB-Werte gemeinsam von 1 bis 254 hoch- oder runterlaufen. H√∂here Werte ergeben ein helleres Wei√ü, niedrigere ein dunkleres.

Setzen wir diese Erkenntnisse in Programmcode um und weisen den Z√§hlerwert den RGB-Werten der LED zu. Spoiler-Alert: Das ist etwas naiv, aber lasst uns mal schauen, was passiert und wo m√∂glicherweise Probleme auftreten:

```{python}
last_count = None
while True:
    new_count = knob.get_count(reset=False)

    if new_count != last_count:
        last_count = new_count
        print(last_count)

        # Set RGB values zu counter value
        led.set_rgb_value(last_count, last_count, last_count)
```

Lasst mal laufen und dreht voll auf oder runter! Beobachtet dabei den Wert f√ºr `last_count`. Was passiert, wenn er kleiner als Null wird? Oder wenn er gr√∂√üer als 255 wird? Bumm! Das Programm st√ºrzt ab!

Warum? Auf der Kommandzeile bekommen wir eine lange Fehlermeldung mit der folgenden Aussage ganz am Ende:

```{bash}
#| code-line-numbers: false
struct.error: ubyte format requires 0 <= number <= 255
```

Wenn man die Fehlermeldung googelt oder ChatGPT befragt bekommt man Hilfe. Offensichtlich wird f√ºr einen RGB-Wert, den wir der Funktion `set_rgb_value()` √ºbergeben ein bestimmter Datentyp erwartet, der `ubyte` heisst. Das steht f√ºr "unsigned byte" und bedeutet, dass der Wert zwischen 0 und 255 liegen muss.

Moment üßê - was hat jetzt Byte mit 0 bis 255 zu tun? Bisher dachten wir doch, das w√§re wegen des RGB-Codes? Stimmt auch, aber der RGB-Code liegt nicht zuf√§llig im Wertebereich von 0 bis 255. 

Um das zu verstehen, m√ºssen wir das Bin√§rsystem kennen.

## Das Bin√§rsystem

...

## Das fertige Programm

```{python}
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2
import math

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
knob = BrickletRotaryEncoderV2('WZd', ipcon) 
led = BrickletRGBLEDV2('ZG1', ipcon)
led.set_rgb_value(0, 0, 0)  # Set initial color to off

count = math.inf
STEP = 10

last_count = knob.get_count(reset=True)
brightness = 0

while True:
    new_count = knob.get_count(reset=False)

    # Only do something if the counter changed
    if new_count != last_count:
        diff = new_count - last_count
        last_count = new_count

        # Adjust brightness
        brightness += diff * STEP
        brightness = max(0, min(255, brightness))

        # Print brightness for debugging purposes
        print(brightness)
        led.set_rgb_value(brightness, brightness, brightness)
```