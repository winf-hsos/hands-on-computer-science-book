<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Ein Online-Buch mit Hardware-Experimenten, die Schritt für Schritt in die Welt der Digitalisierung und Programmierung einführen.">

<title>4&nbsp; Bilder – Hands-On Computer Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./references.html" rel="next">
<link href="./text.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-670489e30afdd02925324b99e7f7a38e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>
<!-- DataTables assets -->
<link rel="stylesheet" href="https://cdn.datatables.net/1.13.8/css/jquery.dataTables.min.css">
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<script src="https://cdn.datatables.net/1.13.8/js/jquery.dataTables.min.js"></script>

<style>
/* linksbündig + volle Breite */
.datatable table, .datatable-nosearch table { width: 100% !important; }
.datatable table td, .datatable table th,
.datatable-nosearch table td, .datatable-nosearch table th { text-align: left; }

/* etwas Luft unter dem Suchfeld (nur .datatable mit Suche) */
.datatable .dataTables_filter { margin-bottom: 1.5rem; }
</style>

<style>
/* --- Quarto + DataTables: Floats neutralisieren --- */
.dataTables_wrapper { 
  display: flow-root;   /* enthält Floats, verhindert Überlaufen in die Margin */
  max-width: 100%;
}

/* Alle DataTables-Steuerelemente nicht mehr floaten lassen */
.dataTables_wrapper .dataTables_filter,
.dataTables_wrapper .dataTables_length,
.dataTables_wrapper .dataTables_info,
.dataTables_wrapper .dataTables_paginate {
  float: none !important;
  text-align: left;     /* oder right, aber ohne float */
  margin: 0 0 1rem 0;   /* etwas Luft unter die Zeile */
}

/* Sicherheitshalber: Tabelle bleibt im Content-Bereich */
.page-columns .content .dataTables_wrapper { margin-right: 0; }
</style>


<script>
(function () {
  function initDT() {
    if (!window.jQuery || !jQuery.fn || !jQuery.fn.DataTable) return;

    // 0) Vorhandene Instanzen zerstören (Hot-Reload zuverlässig)
    document.querySelectorAll('.datatable table, .datatable-nosearch table').forEach(function (tbl) {
      if (jQuery.fn.dataTable.isDataTable(tbl)) {
        try { jQuery(tbl).DataTable().destroy(); } catch(e) {}
      }
      tbl.removeAttribute('data-dt-inited');
      tbl.classList.remove('dataTable');
    });

    // 1) Tabellen MIT Suche (globales Glossar)
    document.querySelectorAll('.datatable table').forEach(function (tbl) {
      if (tbl.dataset.dtInited === '1') return;
      const wrap = tbl.closest('.datatable');
      let order = [[0,'asc']];
      try {
        const o = wrap && wrap.getAttribute('data-order');
        if (o) order = JSON.parse(o);
      } catch(e) {}
      jQuery(tbl).DataTable({
        dom: 'f',
        paging: false,
        info: false,
        ordering: true,
        order: order
      });
      tbl.dataset.dtInited = '1';
    });

    // 2) Tabellen OHNE Suche (Kapitel-Glossare)
    document.querySelectorAll('.datatable-nosearch table').forEach(function (tbl) {
      if (tbl.dataset.dtInited === '1') return;
      const wrap = tbl.closest('.datatable-nosearch');
      let order = [[0,'asc']]; // Fallback
      try {
        const o = wrap && wrap.getAttribute('data-order');
        if (o) order = JSON.parse(o);   // <-- liest z.B. [[2,"asc"]]
      } catch(e) {}
      jQuery(tbl).DataTable({
        dom: 't',        // nur Tabelle
        paging: false,
        info: false,
        ordering: true,
        order: order,
        orderMulti: false
      });
      tbl.dataset.dtInited = '1';
    });
  }
  document.addEventListener('DOMContentLoaded', initDT);
  document.addEventListener('quarto:rendered', initDT);
})();
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="partials/gloss.css">
<link rel="stylesheet" href="partials/collapsable.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./images.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Bilder</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Hands-On Computer Science</a> 
        <div class="sidebar-tools-main">
    <a href="./Hands-On-Computer-Science-Book.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vorwort</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./preparation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vorbereitung</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./colors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Farben</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./numbers.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Zahlen</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./text.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Texte</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./images.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Bilder</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Literaturverzeichnis</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#zusammenfassung" id="toc-zusammenfassung" class="nav-link active" data-scroll-target="#zusammenfassung">Zusammenfassung</a></li>
  <li><a href="#sec-images-experiment-setup" id="toc-sec-images-experiment-setup" class="nav-link" data-scroll-target="#sec-images-experiment-setup"><span class="header-section-number">4.1</span> Experimentaufbau</a>
  <ul class="collapse">
  <li><a href="#hardware" id="toc-hardware" class="nav-link" data-scroll-target="#hardware"><span class="header-section-number">4.1.1</span> Hardware</a></li>
  <li><a href="#das-oled-display-im-brick-viewer" id="toc-das-oled-display-im-brick-viewer" class="nav-link" data-scroll-target="#das-oled-display-im-brick-viewer"><span class="header-section-number">4.1.2</span> Das OLED-Display im Brick Viewer</a></li>
  </ul></li>
  <li><a href="#sec-images-pixels" id="toc-sec-images-pixels" class="nav-link" data-scroll-target="#sec-images-pixels"><span class="header-section-number">4.2</span> Pixel</a>
  <ul class="collapse">
  <li><a href="#was-ist-ein-pixel" id="toc-was-ist-ein-pixel" class="nav-link" data-scroll-target="#was-ist-ein-pixel"><span class="header-section-number">4.2.1</span> Was ist ein Pixel?</a></li>
  <li><a href="#ein-einzelnes-pixel-setzen" id="toc-ein-einzelnes-pixel-setzen" class="nav-link" data-scroll-target="#ein-einzelnes-pixel-setzen"><span class="header-section-number">4.2.2</span> Ein einzelnes Pixel setzen</a></li>
  </ul></li>
  <li><a href="#sec-images-bitmaps" id="toc-sec-images-bitmaps" class="nav-link" data-scroll-target="#sec-images-bitmaps"><span class="header-section-number">4.3</span> Bitmaps</a>
  <ul class="collapse">
  <li><a href="#quadrate" id="toc-quadrate" class="nav-link" data-scroll-target="#quadrate"><span class="header-section-number">4.3.1</span> Quadrate</a></li>
  <li><a href="#ein-kreuz-als-bitmap" id="toc-ein-kreuz-als-bitmap" class="nav-link" data-scroll-target="#ein-kreuz-als-bitmap"><span class="header-section-number">4.3.2</span> Ein Kreuz als Bitmap</a></li>
  <li><a href="#viele-kreuze-mit-schleifen" id="toc-viele-kreuze-mit-schleifen" class="nav-link" data-scroll-target="#viele-kreuze-mit-schleifen"><span class="header-section-number">4.3.3</span> Viele Kreuze mit Schleifen</a></li>
  </ul></li>
  <li><a href="#sec-images-letters" id="toc-sec-images-letters" class="nav-link" data-scroll-target="#sec-images-letters"><span class="header-section-number">4.4</span> Buchstaben</a></li>
  <li><a href="#sec-images-vector-graphics" id="toc-sec-images-vector-graphics" class="nav-link" data-scroll-target="#sec-images-vector-graphics"><span class="header-section-number">4.5</span> Vektorgrafiken</a></li>
  <li><a href="#sec-images-bits-to-display" id="toc-sec-images-bits-to-display" class="nav-link" data-scroll-target="#sec-images-bits-to-display"><span class="header-section-number">4.6</span> Von Bits zum Bild</a>
  <ul class="collapse">
  <li><a href="#darth-vader-als-pixelart" id="toc-darth-vader-als-pixelart" class="nav-link" data-scroll-target="#darth-vader-als-pixelart"><span class="header-section-number">4.6.1</span> Darth Vader als Pixelart</a></li>
  <li><a href="#excel-mit-python-einlesen" id="toc-excel-mit-python-einlesen" class="nav-link" data-scroll-target="#excel-mit-python-einlesen"><span class="header-section-number">4.6.2</span> Excel mit Python einlesen</a></li>
  <li><a href="#zeile-für-zeile-die-pixelwerte-extrahieren" id="toc-zeile-für-zeile-die-pixelwerte-extrahieren" class="nav-link" data-scroll-target="#zeile-für-zeile-die-pixelwerte-extrahieren"><span class="header-section-number">4.6.3</span> Zeile für Zeile die Pixelwerte extrahieren</a></li>
  <li><a href="#hexadezimale-farbwerte" id="toc-hexadezimale-farbwerte" class="nav-link" data-scroll-target="#hexadezimale-farbwerte"><span class="header-section-number">4.6.4</span> Hexadezimale Farbwerte</a></li>
  <li><a href="#die-liste-mit-bits-erstellen" id="toc-die-liste-mit-bits-erstellen" class="nav-link" data-scroll-target="#die-liste-mit-bits-erstellen"><span class="header-section-number">4.6.5</span> Die Liste mit Bits erstellen</a></li>
  <li><a href="#anzeige-auf-dem-display" id="toc-anzeige-auf-dem-display" class="nav-link" data-scroll-target="#anzeige-auf-dem-display"><span class="header-section-number">4.6.6</span> Anzeige auf dem Display</a></li>
  <li><a href="#sec-images-save-bitmap" id="toc-sec-images-save-bitmap" class="nav-link" data-scroll-target="#sec-images-save-bitmap"><span class="header-section-number">4.6.7</span> Eine Bitmap speichern</a></li>
  </ul></li>
  <li><a href="#sec-images-color" id="toc-sec-images-color" class="nav-link" data-scroll-target="#sec-images-color"><span class="header-section-number">4.7</span> Farbe</a>
  <ul class="collapse">
  <li><a href="#bitmaps-im-rgb-format" id="toc-bitmaps-im-rgb-format" class="nav-link" data-scroll-target="#bitmaps-im-rgb-format"><span class="header-section-number">4.7.1</span> Bitmaps im RGB-Format</a></li>
  <li><a href="#struktur-einer-bitmap-datei" id="toc-struktur-einer-bitmap-datei" class="nav-link" data-scroll-target="#struktur-einer-bitmap-datei"><span class="header-section-number">4.7.2</span> Struktur einer Bitmap-Datei</a></li>
  </ul></li>
  <li><a href="#sec-images-animation" id="toc-sec-images-animation" class="nav-link" data-scroll-target="#sec-images-animation"><span class="header-section-number">4.8</span> Animationen</a></li>
  <li><a href="#sec-images-transformations" id="toc-sec-images-transformations" class="nav-link" data-scroll-target="#sec-images-transformations"><span class="header-section-number">4.9</span> Transformationen</a>
  <ul class="collapse">
  <li><a href="#graustufen" id="toc-graustufen" class="nav-link" data-scroll-target="#graustufen"><span class="header-section-number">4.9.1</span> Graustufen</a></li>
  <li><a href="#bitmap-in-graustufen-umwandeln" id="toc-bitmap-in-graustufen-umwandeln" class="nav-link" data-scroll-target="#bitmap-in-graustufen-umwandeln"><span class="header-section-number">4.9.2</span> Bitmap in Graustufen umwandeln</a></li>
  <li><a href="#schwarzweiß" id="toc-schwarzweiß" class="nav-link" data-scroll-target="#schwarzweiß"><span class="header-section-number">4.9.3</span> Schwarzweiß</a></li>
  <li><a href="#informationsverlust" id="toc-informationsverlust" class="nav-link" data-scroll-target="#informationsverlust"><span class="header-section-number">4.9.4</span> Informationsverlust</a></li>
  </ul></li>
  <li><a href="#sec-images-pacman" id="toc-sec-images-pacman" class="nav-link" data-scroll-target="#sec-images-pacman"><span class="header-section-number">4.10</span> Pacman</a>
  <ul class="collapse">
  <li><a href="#von-farbe-zu-schwarzweiß" id="toc-von-farbe-zu-schwarzweiß" class="nav-link" data-scroll-target="#von-farbe-zu-schwarzweiß"><span class="header-section-number">4.10.1</span> Von Farbe zu Schwarzweiß</a></li>
  <li><a href="#pacman-animation" id="toc-pacman-animation" class="nav-link" data-scroll-target="#pacman-animation"><span class="header-section-number">4.10.2</span> Pacman-Animation</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-images" class="quarto-section-identifier"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Bilder</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="zusammenfassung" class="level2 unnumbered collapsable">
<h2 class="unnumbered collapsable anchored" data-anchor-id="zusammenfassung">Zusammenfassung</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>In diesem Kapitel arbeiten wir zum ersten Mal mit Bildern auf einem Display. Ausgehend von einem kleinen OLED-Display lernen wir Schritt für Schritt, wie Bilder im Computer repräsentiert werden und wie wir sie programmatisch erzeugen und anzeigen können.</p>
<p>Der Weg dahin führt über folgende Schritte:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 2%">
<col style="width: 75%">
<col style="width: 21%">
</colgroup>
<thead>
<tr class="header">
<th>#</th>
<th>Was?</th>
<th>Wo?</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Wir machen uns mit dem Display vertraut.</td>
<td><a href="#sec-images-experiment-setup" class="quarto-xref"><span>Abschnitt 4.1</span></a></td>
</tr>
<tr class="even">
<td>2</td>
<td>Wir lernen das Pixel kennen und schalten es im Display an und aus.</td>
<td><a href="#sec-images-pixels" class="quarto-xref"><span>Abschnitt 4.2</span></a></td>
</tr>
<tr class="odd">
<td>3</td>
<td>Wir führen die Bitmap als eine Sammlung von Pixelwerten ein.</td>
<td><a href="#sec-images-bitmaps" class="quarto-xref"><span>Abschnitt 4.3</span></a></td>
</tr>
<tr class="even">
<td>4</td>
<td>Wir lernen, wie man Buchstaben als Bitmaps darstellen kann.</td>
<td><a href="#sec-images-letters" class="quarto-xref"><span>Abschnitt 4.4</span></a></td>
</tr>
<tr class="odd">
<td>5</td>
<td>Wir lernen eine Alternative zu Bitmaps kennen.</td>
<td><a href="#sec-images-vector-graphics" class="quarto-xref"><span>Abschnitt 4.5</span></a></td>
</tr>
<tr class="even">
<td>6</td>
<td>Wir zeigen ein Bild als Bitfolge auf dem Display an.</td>
<td><a href="#sec-images-bits-to-display" class="quarto-xref"><span>Abschnitt 4.6</span></a></td>
</tr>
<tr class="odd">
<td>7</td>
<td>Wir betrachten Farben in Bitmaps.</td>
<td><a href="#sec-images-color" class="quarto-xref"><span>Abschnitt 4.7</span></a></td>
</tr>
<tr class="even">
<td>8</td>
<td>Wir lernen, was eine Animation im Computer ist.</td>
<td><a href="#sec-images-animation" class="quarto-xref"><span>Abschnitt 4.8</span></a></td>
</tr>
<tr class="odd">
<td>9</td>
<td>Wir wenden einfache Arithmetik auf Bilder an.</td>
<td><a href="#sec-images-transformations" class="quarto-xref"><span>Abschnitt 4.9</span></a></td>
</tr>
<tr class="even">
<td>10</td>
<td>Wir animieren Pacman und erwecken ihn auf dem Display zum Leben.</td>
<td><a href="#sec-images-pacman" class="quarto-xref"><span>Abschnitt 4.10</span></a></td>
</tr>
</tbody>
</table>
</details>
</section>
<section id="sec-images-experiment-setup" class="level2 collapsable" data-number="4.1">
<h2 class="collapsable anchored" data-number="4.1" data-anchor-id="sec-images-experiment-setup"><span class="header-section-number">4.1</span> Experimentaufbau</h2>
<details class="collapsable-section" open=""><summary></summary>
<section id="hardware" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="hardware"><span class="header-section-number">4.1.1</span> Hardware</h3>
<p>In den Experimenten dieses Kapitels verwenden wir ein kleines OLED-Display, das wir an unseren Master Brick anschließen. Das Display kann einzelne Pixel weiß aufleuchten lassen und damit einfache Bilder und Texte darstellen. Insgesamt stehen uns 128 × 64 Pixel zur Verfügung, also 8192 einzelne Bildpunkte.</p>
<p>Die vollständige Hardwareliste für dieses Kapitel sieht so aus:</p>
<ul>
<li>1 × <a href="https://www.tinkerforge.com/de/doc/Hardware/Bricks/Master_Brick.html">Master Brick 3.2</a></li>
<li>1 × <a href="https://www.tinkerforge.com/de/shop/distance-ir-4-30cm-v2-bricklet.html">Distance IR 4-30cm Bricklet 2.0</a></li>
<li>1 × <a href="https://www.tinkerforge.com/de/doc/Hardware/Bricklets/OLED_128x64_V2.html">OLED 128x64 Bricklet 2.0</a></li>
<li>1 × <a href="https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-plate-22x10.html">Montageplatte 22x10</a></li>
<li>2 × <a href="https://www.tinkerforge.com/de/shop/accessories/cable/bricklet-cable-15cm-7p-7p.html">Brickletkabel 15cm (7p-7p)</a></li>
</ul>
<p>Wenn ihr das Experiment aus <a href="text.html" class="quarto-xref"><span>Kapitel 3</span></a> gemacht habt, dann könnt ihr einfach des OLED-Display hinzufügen und wie in der <a href="#fig-setup-display" class="quarto-xref">Abbildung&nbsp;<span>4.1</span></a> gezeigt auf den Master Brick aufschrauben. Die LED und den Infrarotsensor benötigen wir zwar in diesem Experiment nicht, sie stören aber auch nicht.</p>
<div id="fig-setup-display" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-setup-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-setup-display" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-setup-display-1" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="setup-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-setup-display-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/setup_oled_display_closeup_1.jpg" class="lightbox" data-gallery="setup-display" title="Abbildung&nbsp;4.1&nbsp;(a): Seitenansicht."><img src="images/setup_oled_display_closeup_1.jpg" class="img-fluid figure-img" data-ref-parent="fig-setup-display"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-setup-display-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Seitenansicht.
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-setup-display" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-setup-display-2" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="setup-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-setup-display-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/setup_oled_display_closeup_2.jpg" class="lightbox" data-gallery="setup-display" title="Abbildung&nbsp;4.1&nbsp;(b): Draufsicht."><img src="images/setup_oled_display_closeup_2.jpg" class="img-fluid figure-img" data-ref-parent="fig-setup-display"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-setup-display-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Draufsicht.
</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-setup-display" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-setup-display-3" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="setup-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-setup-display-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/setup_oled_display_closeup_3.jpg" class="lightbox" data-gallery="setup-display" title="Abbildung&nbsp;4.1&nbsp;(c): Nahaufnahme des Displays auf dem Master Brick."><img src="images/setup_oled_display_closeup_3.jpg" class="img-fluid figure-img" data-ref-parent="fig-setup-display"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-setup-display-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(c) Nahaufnahme des Displays auf dem Master Brick.
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-setup-display" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-setup-display-4" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="setup-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-setup-display-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/setup_oled_display_closeup_4.jpg" class="lightbox" data-gallery="setup-display" title="Abbildung&nbsp;4.1&nbsp;(d): Seitenansicht, leicht von oben."><img src="images/setup_oled_display_closeup_4.jpg" class="img-fluid figure-img" data-ref-parent="fig-setup-display"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-setup-display-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(d) Seitenansicht, leicht von oben.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-setup-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.1: Einfaches Setup wie aus <a href="text.html" class="quarto-xref"><span>Kapitel 3</span></a> und erweitert um das OLED-Display.
</figcaption>
</figure>
</div>
</section>
<section id="das-oled-display-im-brick-viewer" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="das-oled-display-im-brick-viewer"><span class="header-section-number">4.1.2</span> Das OLED-Display im Brick Viewer</h3>
<p>Wie gewohnt starten wir im Brick Viewer. Verbindet euch mit dem Master Brick und ihr solltet die angeschlossenen Geräte sehen können. Den Infrarotsensor kennt ihr bereits aus dem letzten Kapitel. Wir konzentrieren uns hier auf das neue Display im Tab “OLED 128x64 Bricklet 2.0”.</p>
<p>Die Oberfläche für das Display seht ihr in <a href="#fig-images-brick-viewer-oled-display" class="quarto-xref">Abbildung&nbsp;<span>4.2</span></a>. Im Wesentlichen kann das Display drei Dinge:</p>
<ol type="1">
<li>Einzelne Pixel ein- und ausschalten</li>
<li>Seinen gesamten Inhalt löschen, also alle Pixel af einmal ausschalten</li>
<li>Text anzeigen (was im Kern nichts anderes ist als ein Spezialfall von 1)</li>
</ol>
<div id="fig-images-brick-viewer-oled-display" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-brick-viewer-oled-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/brick_viewer_oled_display.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Abbildung&nbsp;4.2: Im Brick Viewer können wir auf dem Display Text anzeigen oder zeichnen."><img src="images/brick_viewer_oled_display.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-brick-viewer-oled-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.2: Im Brick Viewer können wir auf dem Display Text anzeigen oder zeichnen.
</figcaption>
</figure>
</div>
<p>Alle genannten Funktionen könnt ihr direkt im Brick Viewer ausprobieren. Mit der Maus könnt ihr auf der schwarzen Fläche freihändig zeichnen und das Ergebnis mit “Draw on Display” auf das Display übertragen. Mit “Clear Display” löscht ihr den gesamten Inhalt wieder. Alternativ könnt ihr Text in das Textfeld eingeben und mit “Send” anzeigen lassen.</p>
<p>Für Text können wir die Position über die Angabe der Zeile (<code>Line</code>) sowie der Position in der Zeile (<code>Pos</code>) bestimmen. Im Dropdown seht ihr, dass die Zeilen von 0 bis 7 und die Positionen von 0 bis 21 nummeriert sind. Das Display teilt die 128 Pixel Breite in 22 Zeichenpositionen und die 64 Pixel Höhe in 8 Textzeilen auf. Die eingebaute Schrift nutzt ein 5×8-Pixel-Raster pro Zeichen und fügt noch passende Abstände ein.</p>
<div id="fig-images-display-drawing-vs-text-brick-viewer" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-display-drawing-vs-text-brick-viewer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-display-drawing-vs-text-brick-viewer" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-brick-viewer-oled-display-drawing-hocs" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="brick-viewer-oled-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-brick-viewer-oled-display-drawing-hocs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/brick_viewer_oled_display_drawing_hocs.png" class="lightbox" data-gallery="brick-viewer-oled-display" title="Abbildung&nbsp;4.3&nbsp;(a): Mein Versuch, den Titel des Buches mit der Maus zu zeichnen."><img src="images/brick_viewer_oled_display_drawing_hocs.png" class="img-fluid figure-img" data-ref-parent="fig-images-display-drawing-vs-text-brick-viewer"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-brick-viewer-oled-display-drawing-hocs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Mein Versuch, den Titel des Buches mit der Maus zu zeichnen.
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-display-drawing-vs-text-brick-viewer" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-brick-viewer-oled-display-text" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="brick-viewer-oled-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-brick-viewer-oled-display-text-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/brick_viewer_oled_display_text.png" class="lightbox" data-gallery="brick-viewer-oled-display" title="Abbildung&nbsp;4.3&nbsp;(b): Das Display unterstützt auch die direkte Textausgabe."><img src="images/brick_viewer_oled_display_text.png" class="img-fluid figure-img" data-ref-parent="fig-images-display-drawing-vs-text-brick-viewer"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-brick-viewer-oled-display-text-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Das Display unterstützt auch die direkte Textausgabe.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig quarto-uncaptioned" id="fig-images-display-drawing-vs-text-brick-viewer-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.3
</figcaption>
</figure>
</div>
<p>In <a href="#fig-images-display-drawing-vs-text" class="quarto-xref">Abbildung&nbsp;<span>4.4</span></a> könnt ihr den Unterschied zwischen meinem kläglichen Versuch, den Titel des Buches mit der Maus zu zeichnen, und der automatischen Textausgabe sehen. Das Display ist zwar nicht besonders groß, aber für einfache Grafiken und Texte reicht es allemal. Der Text “Hands-On Computer Science” ist aber mit 25 Zeichen zu lang und wird daher abgeschnitten.</p>
<div id="fig-images-display-drawing-vs-text" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-display-drawing-vs-text-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-display-drawing-vs-text" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-oled-display-hocs-drawing" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-oled-display-hocs-drawing-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/oled_display_hocs_drawing.jpg" class="lightbox" data-gallery="fig-images-display-drawing-vs-text" title="Abbildung&nbsp;4.4&nbsp;(a): So sieht meine Zeichnung auf dem Display aus."><img src="images/oled_display_hocs_drawing.jpg" class="img-fluid figure-img" data-ref-parent="fig-images-display-drawing-vs-text"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-oled-display-hocs-drawing-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) So sieht meine Zeichnung auf dem Display aus.
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-display-drawing-vs-text" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-oled-display-hocs-text" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-oled-display-hocs-text-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/oled_display_hocs_text.jpg" class="lightbox" data-gallery="fig-images-display-drawing-vs-text" title="Abbildung&nbsp;4.4&nbsp;(b): Es geht auch direkt als Text, allerdings abgeschnitten."><img src="images/oled_display_hocs_text.jpg" class="img-fluid figure-img" data-ref-parent="fig-images-display-drawing-vs-text"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-oled-display-hocs-text-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Es geht auch direkt als Text, allerdings abgeschnitten.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-display-drawing-vs-text-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.4: Gezeichneter vs.&nbsp;getippter Text auf dem Display.
</figcaption>
</figure>
</div>
<p>Was wir im Brick Viewer per Mausklick machen, wollen wir im nächsten Schritt in Python programmatisch steuern.</p>
</section></details>
</section>

<section id="sec-images-pixels" class="level2 collapsable" data-number="4.2">
<h2 class="collapsable anchored" data-number="4.2" data-anchor-id="sec-images-pixels"><span class="header-section-number">4.2</span> Pixel</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Nachdem wir das Display im Brick Viewer ausprobiert haben, steuern wir es nun aus Python an. Wie immer stellen wir zuerst die Verbindung her und erzeugen eine Instanz des Display-Objekts. Unser Boilperplate-Code sieht so aus:</p>
<div id="389f913b" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-1"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1"></a><span class="im">from</span> tinkerforge.ip_connection <span class="im">import</span> IPConnection</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1">1</button><span id="annotated-cell-1-2" class="code-annotation-target"><a href="#annotated-cell-1-2"></a><span class="im">from</span> tinkerforge.bricklet_oled_128x64_v2 <span class="im">import</span> BrickletOLED128x64V2</span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3"></a></span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4"></a>ipcon <span class="op">=</span> IPConnection()</span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5"></a>ipcon.<span class="ex">connect</span>(<span class="st">'localhost'</span>, <span class="dv">4223</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="2">2</button><span id="annotated-cell-1-6" class="code-annotation-target"><a href="#annotated-cell-1-6"></a>oled <span class="op">=</span> BrickletOLED128x64V2(<span class="st">'25zo'</span>, ipcon)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="3">3</button><span id="annotated-cell-1-7" class="code-annotation-target"><a href="#annotated-cell-1-7"></a>oled.clear_display()</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="2" data-code-annotation="1">Wir importieren die Klasse <code>BrickletOLED128x64V2</code> aus der Tinkerforge-Bibliothek, die uns die Funktionen des Displays zur Verfügung stellt.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="6" data-code-annotation="2">Tragt hier eure eigene UID ein.</span>
</dd>
<dt data-target-cell="annotated-cell-1" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="7" data-code-annotation="3">Wir löschen den Display-Inhalt, damit wir mit einem leeren Display starten. Die Funktion <code>clear_display()</code> erledigt das.</span>
</dd>
</dl>
</div>
</div>
<p>Über die Variable <code>oled</code> können wir von nun an die verschiedenen Funktionen des Displays verwenden. Eine davon seht ihr bereits im Codebeispiel, nämlich das Löschen des Displays mit <code>clear_display()</code>. Zu Beginn des Programms ist unser Display somit schwarz.</p>
<section id="was-ist-ein-pixel" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="was-ist-ein-pixel"><span class="header-section-number">4.2.1</span> Was ist ein Pixel?</h3>
<p>Das Wort Pixel wird vom englischen “picture element” (Bildelement) abgeleitet. Ein Pixel ist der kleinste darstellbare Punkt auf einem Display.</p>
<p>In unserem Fall kann ein Pixel entweder schwarz oder weiß sein. Auf anderen Bildschirmen, wie dem eures Smartphones oder Fernsehers, können Pixel auch farbig sein. Das schauen wir uns später noch genauer an. In diesem Kapitel konzentrieren wir uns zunächst auf die einfache Schwarzweiß-Darstellung. Auch, weil unser OLED-Display nur Schwarzweiß kann.</p>
<p>Unser Display hat eine Auflösung von 128 × 64 Pixeln. Das bedeutet, dass es 128 Pixel in der Breite und 64 Pixel in der Höhe hat. Insgesamt ergibt das 8192 Pixel, die wir individuell an- oder ausschalten können.</p>
<p>Damit wir mit einzelnen Pixeln sprechen können, hat jedes eine eigene Koordinate, die seine Position als Spalte (x) und Zeile (y) angibt. Genau wie in einer Excel-Tabelle, in der die Zelle in der dritten Spalte und vierten Zeile mit C4 adressiert würde – nur verwenden wir hier statt Buchstaben ausschließlich Zahlen.</p>
<p>Die Koordinaten beginnen bei (0, 0) in der linken oberen Ecke. Die erste Zahl ist die x-Koordinate (horizontal), die zweite die y-Koordinate (vertikal).</p>
</section>
<section id="ein-einzelnes-pixel-setzen" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="ein-einzelnes-pixel-setzen"><span class="header-section-number">4.2.2</span> Ein einzelnes Pixel setzen</h3>
<p>Beginnen wir damit, das Pixel in der linken oberen Ecke des Displays einzuschalten. Dazu verwenden wir die Funktion <code>write_pixels()</code>:</p>
<div id="93e024a1" class="cell" data-execution_count="2">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, [<span class="dv">1</span>])</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Warum so viele Argumente, wenn wir doch nur ein einziges Pixel setzen wollen? Der Grund: <code>write_pixels()</code> kann nicht nur einzelne Pixel, sondern beliebige rechteckige Flächen ansteuern. Die Funktion erwartet deshalb immer die Beschreibung eines Rechtecks plus die zugehörigen Pixelwerte.</p>
<div id="fig-images-write-pixels-single" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-write-pixels-single-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_write_pixel_coordinates_single.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Abbildung&nbsp;4.5: Die Funktion write_pixels() benötigt die Angabe eines Rechtecks und die entsprechenden Pixelwerte als 0 oder 1. Für ein einziges Pixel sind beide Punkte des Rechtecks identisch."><img src="https://winf-hsos.github.io/university-docs/images/images_write_pixel_coordinates_single.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-write-pixels-single-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.5: Die Funktion <code>write_pixels()</code> benötigt die Angabe eines Rechtecks und die entsprechenden Pixelwerte als 0 oder 1. Für ein einziges Pixel sind beide Punkte des Rechtecks identisch.
</figcaption>
</figure>
</div>
<p>Allgemein lautet die Signatur der Funktion so:</p>
<div id="cbbc6bcc" class="cell" data-execution_count="3">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>write_pixels(x_start, y_start, x_end, y_end, pixel_values)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Die ersten vier Argumente definieren die zwei Eckpunkte des Rechtecks: oben links und unten rechts (beide inklusive). Die Breite ergibt sich aus <code>x_end - x_start + 1</code>, die Höhe aus <code>y_end - y_start + 1</code>.</p>
<p>In unserem Fall sind beide Punkte (0, 0), wir sprechen also genau ein Pixel an. Der letzte Parameter ist eine Liste von Werten, die angibt, ob die Pixel in der definierten Fläche ein- oder ausgeschaltet werden sollen. Ein Wert von <code>1</code> bedeutet weiß, <code>0</code> bedeutet schwarz. Da wir nur ein Pixel ansprechen, enthält die Liste nur einen Wert: <code>[1]</code>.</p>
<p>Auch wenn es im Beispiel nur ein Wert ist, stellt <code>[1]</code> in Python eine Liste dar, darauf weisen die eckigen Klammern hin. Innerhalb der Klammern können beliebig viele Werte durch Kommas getrennt angegeben werden.</p>
<p>Wir können das Pixel wieder ausschalten, indem wir den Wert in der Liste auf 0 ändern:</p>
<div id="b6af15b3" class="cell" data-execution_count="4">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, [<span class="dv">1</span>])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">input</span>(<span class="st">"Drücke Enter um das Pixel auszuschalten..."</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, [<span class="dv">0</span>])</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Einzelne Pixel lassen sich so bequem schalten. Interessant wird es aber erst, wenn wir mehrere Pixel zu einem Bild kombinieren. Das führt uns zu Bitmaps.</p>
</section></details>
</section>

<section id="sec-images-bitmaps" class="level2 collapsable" data-number="4.3">
<h2 class="collapsable anchored" data-number="4.3" data-anchor-id="sec-images-bitmaps"><span class="header-section-number">4.3</span> Bitmaps</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Eine Bitmap ist nichts anderes als eine rechteckige Matrix von Pixelwerten, die zusammen ein Bild ergeben. Mit <code>write_pixels()</code> können wir solche Rechtecke direkt auf dem Display zeichnen.</p>
<section id="quadrate" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="quadrate"><span class="header-section-number">4.3.1</span> Quadrate</h3>
<p>Sagen wir, wir wollen ein 2×2 großes Quadrat in der Mitte des Displays zeichnen. Die Mitte des Displays liegt rechnerisch bei (64, 32). Da wir bei 0 zu zählen beginnen, korrigieren wir auf (63, 31).</p>
<p>Um ein 2×2-Quadrat zu zeichnen, setzen wir die Koordinaten des oberen linken Punkts auf (62, 30) und die Koordinaten des unteren rechten Punkts auf (63, 31). Die Liste der Werte für die Pixel in dieser Fläche muss 4 Werte enthalten, alle auf 1 gesetzt:</p>
<div id="6d9c1d07" class="cell" data-execution_count="5">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">62</span>, <span class="dv">30</span>, <span class="dv">63</span>, <span class="dv">31</span>, [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>])</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Genau genommen ist die Liste eine flache Struktur, sie wird aber als 2×2-Matrix interpretiert. Die Bitmap sieht also so aus:</p>
<pre><code>1 1
1 1</code></pre>
<p><a href="#fig-images-write-pixels" class="quarto-xref">Abbildung&nbsp;<span>4.6</span></a> zeigt das Konzept der Bitmap für unser 2×2-Quadrat.</p>
<div id="fig-images-write-pixels" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-write-pixels-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_write_pixel_coordinates.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Abbildung&nbsp;4.6: Ein 2x2 Quadrat über die Angabe der linken oberen sowie der unteren rechten Ecke."><img src="https://winf-hsos.github.io/university-docs/images/images_write_pixel_coordinates.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-write-pixels-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.6: Ein 2x2 Quadrat über die Angabe der linken oberen sowie der unteren rechten Ecke.
</figcaption>
</figure>
</div>
<p>Was ist, wenn wir das Quadrat auf 3×3 vergrößern wollen? Dann ändern wir den unteren rechten Punkt auf (64, 32) oder alternativ den oberen linken Punkt auf (61, 29). Die Liste der Werte erweitern wir auf 9 Einträge:</p>
<div id="9fd02097" class="cell" data-execution_count="6">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">61</span>, <span class="dv">29</span>, <span class="dv">63</span>, <span class="dv">31</span>, [<span class="dv">1</span>] <span class="op">*</span> <span class="dv">9</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Die Python-Syntax <code>[1] * 9</code> erzeugt eine Liste mit 9 Einsen. Das ist eine praktische Abkürzung, um lange Listen mit gleichen Werten zu erstellen.</p>
<p>Die Länge der Liste <code>pixel_values</code> muss immer genau der Anzahl der Pixel in der Fläche entsprechen. Die Werte werden zeilenweise von links nach rechts und von oben nach unten gelesen und auf das Display projiziert.</p>
</section>
<section id="ein-kreuz-als-bitmap" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="ein-kreuz-als-bitmap"><span class="header-section-number">4.3.2</span> Ein Kreuz als Bitmap</h3>
<p>In <a href="#fig-images-write-pixel-coordinates-cross" class="quarto-xref">Abbildung&nbsp;<span>4.7</span></a> sehen wir ein weiteres Beispiel, diesmal für eine Bitmap mit 3×3 Pixeln. Es leuchten nur die Pixel, die ein Kreuzmuster ergeben. Als Liste sieht das so aus:</p>
<pre><code>[0, 1, 0, 1, 1, 1, 0, 1, 0]</code></pre>
<p>Als Matrix dargestellt:</p>
<pre><code>0 1 0
1 1 1
0 1 0</code></pre>
<div id="fig-images-write-pixel-coordinates-cross" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-write-pixel-coordinates-cross-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_write_pixel_coordinates_cross.png" class="lightbox" data-gallery="quarto-lightbox-gallery-12" title="Abbildung&nbsp;4.7: Über die Pixelwerte lassen sich beliebige Symbole darstellen, hier ein Kreuz."><img src="https://winf-hsos.github.io/university-docs/images/images_write_pixel_coordinates_cross.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-write-pixel-coordinates-cross-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.7: Über die Pixelwerte lassen sich beliebige Symbole darstellen, hier ein Kreuz.
</figcaption>
</figure>
</div>
<p>Wenn wir dieses Kreuz öfter zeichnen wollen, speichern wir die Liste der Pixelwerte am besten in einer Variablen:</p>
<div id="de2084f4" class="cell" data-execution_count="7">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>cross_bitmap <span class="op">=</span> [</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Jetzt können wir das Kreuz einfach zeichnen, indem wir die Variable <code>cross_bitmap</code> an <code>write_pixels()</code> übergeben:</p>
<div id="a53b0f85" class="cell" data-execution_count="8">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">2</span>, cross_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Da wir das Quadrat (0, 0) bis (2, 2) angegeben haben, erscheint das Kreuz in der linken oberen Ecke. Wir können die x- und y-Koordinaten anpassen, um das Kreuz an einer anderen Position zu zeichnen, z.B. direkt daneben noch eins, mit einem Pixel Abstand:</p>
<div id="fbdb24f6" class="cell" data-execution_count="9">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">2</span>, cross_bitmap)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">4</span>, <span class="dv">0</span>, <span class="dv">6</span>, <span class="dv">2</span>, cross_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="viele-kreuze-mit-schleifen" class="level3" data-number="4.3.3">
<h3 data-number="4.3.3" class="anchored" data-anchor-id="viele-kreuze-mit-schleifen"><span class="header-section-number">4.3.3</span> Viele Kreuze mit Schleifen</h3>
<p>Was, wenn wir Kreuze über das gesamte Display zeichnen wollen? Ein Kreuz inklusive Abstand benötigt 4 Pixel in der Breite (3 Pixel für das Kreuz, 1 Pixel Abstand). Mit 128 Pixeln in der Breite können wir 32 solcher Blöcke nebeneinander unterbringen.</p>
<p>Anstatt jede Position per Hand zu kodieren, nutzen wir eine Schleife:</p>
<div id="2c0d9ce4" class="cell" data-execution_count="10">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">128</span>, <span class="dv">4</span>):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    oled.write_pixels(x, <span class="dv">0</span>, x <span class="op">+</span> <span class="dv">2</span>, <span class="dv">2</span>, cross_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Erinnert euch: Die <code>range()</code>-Funktion erzeugt eine Folge von Zahlen. In diesem Fall starten wir bei 0, enden vor 128 und erhöhen die Zahl in jedem Schritt um 4. Dadurch erhalten wir die x-Koordinaten 0, 4, 8, …, 124. In jedem Schleifendurchlauf zeichnen wir ein Kreuz an der aktuellen x-Position.</p>
<p>Wollen wir das gesamte Display mit Kreuzen füllen, verschachteln wir zwei Schleifen – eine für die Zeilen (y), eine für die Spalten (x):</p>
<div id="b0f216ab" class="cell" data-execution_count="11">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">64</span>, <span class="dv">4</span>):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">0</span>, <span class="dv">128</span>, <span class="dv">4</span>):</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        oled.write_pixels(x, y, x <span class="op">+</span> <span class="dv">2</span>, y <span class="op">+</span> <span class="dv">2</span>, cross_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Wenn ihr den Code ausführt, könnt ihr dem Display beim Zeichnen zuschauen. Es füllt sich nach und nach mit Kreuzen, bis das gesamte Display bedeckt ist.</p>
<p>Wir haben damit alle Bausteine beisammen, um nicht nur geometrische Formen, sondern auch komplexere Symbole wie Buchstaben zu zeichnen.</p>
</section></details>
</section>

<section id="sec-images-letters" class="level2 collapsable" data-number="4.4">
<h2 class="collapsable anchored" data-number="4.4" data-anchor-id="sec-images-letters"><span class="header-section-number">4.4</span> Buchstaben</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Auch Buchstaben auf dem Bildschirm sind nichts anderes als Pixelmuster. Wie bereits erwähnt, ist ein Buchstabe auf dem Tinkerforge-Display 5 Pixel breit und 8 Pixel hoch. Das bedeutet, dass wir für jeden Buchstaben eine Bitmap mit 40 Werten benötigen.</p>
<p>Tinkerforge stellt eine Übersicht der unterstützten Zeichen und deren Pixelmuster auf <a href="https://www.tinkerforge.com/en/doc/Hardware/Bricklets/OLED_128x64_V2.html#font">seiner Webseite</a> bereit. Daraus habe ich den Buchstaben “A” als Bitmap in eine einfache Tabelle übertragen und Pixel, die an sind, schwarz eingefärbt. Das Ergebnis seht ihr in <a href="#fig-images-bitmap-letter-a" class="quarto-xref">Abbildung&nbsp;<span>4.8</span></a>.</p>
<div id="fig-images-bitmap-letter-a" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-bitmap-letter-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_letter_a.png" class="lightbox" data-gallery="quarto-lightbox-gallery-13" title="Abbildung&nbsp;4.8: Der Buchstabe “A” als Bitmap."><img src="https://winf-hsos.github.io/university-docs/images/images_letter_a.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-bitmap-letter-a-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.8: Der Buchstabe “A” als Bitmap.
</figcaption>
</figure>
</div>
<p>Anhand dieser Darstellung können wir die Liste mit Einsen und Nullen ableiten, die wir benötigen, um das “A” auf dem Display darzustellen:</p>
<div id="c1170562" class="cell" data-execution_count="12">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>letter_a_bitmap <span class="op">=</span> [</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>,</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>In der Matrixdarstellung erkennt man das “A” recht gut. Jetzt ein Rätsel: Welcher Buchstabe verbirgt sich in der folgenden Bitmap?</p>
<div id="e956b5db" class="cell" data-execution_count="13">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>letter_unknown_bitmap <span class="op">=</span> [</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>,</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>,</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Zeichnen wir den Buchstaben auf dem Display, um es herauszufinden. Wir kennen die Dimensionen (5×8 Pixel), haben die Bitmap als Liste und müssen nur noch die Position bestimmen. Ich habe mich für die Position (6, 10) als oberen linken Punkt entschieden:</p>
<div id="3a3a1f3b" class="cell" data-execution_count="14">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">6</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">17</span>, letter_unknown_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Und? Seht ihr auch ein großes “S”?</p>
<div id="fig-images-bitmap-letter-s" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-bitmap-letter-s-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_letter_s.png" class="lightbox" data-gallery="quarto-lightbox-gallery-14" title="Abbildung&nbsp;4.9: Der Buchstabe “S” als Bitmap."><img src="https://winf-hsos.github.io/university-docs/images/images_letter_s.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-bitmap-letter-s-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.9: Der Buchstabe “S” als Bitmap.
</figcaption>
</figure>
</div>
<p>Versuchen wir, davor noch das “A” zu schreiben:</p>
<div id="5f45af10" class="cell" data-execution_count="15">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">5</span>, <span class="dv">17</span>, letter_a_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Wir haben richtig gerechnet: Das “A” soll vor dem “S” stehen, also müssen wir mit der x-Koordinate 5 Pixel nach links gehen. Lasst uns noch ein Pixel Platz zwischen beiden Buchstaben lassen. Dann setzen wir die x-Koordinate des “A” auf 0 und die des rechten unteren Punkts auf 4:</p>
<div id="590e1d0c" class="cell" data-execution_count="16">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">17</span>, letter_a_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Und nun noch ein “S” ans Ende, damit wir ein sinnvolles Wort schreiben:</p>
<div id="13c88371" class="cell" data-execution_count="17">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">17</span>, letter_a_bitmap)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">6</span>, <span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">17</span>, letter_unknown_bitmap)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">12</span>, <span class="dv">10</span>, <span class="dv">16</span>, <span class="dv">17</span>, letter_unknown_bitmap)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Entscheidet selbst, ob ihr bei dem geschriebenen Wort an eine Spielkarte, den Namen eines Schmerzmittels oder das englische Schimpfwort denkt. Technisch haben wir schlicht drei Buchstaben als Bitmaps auf dem Display dargestellt. Und das ganz ohne die Textfunktion des Displays zu verwenden.</p>
<p>Zur Erinnerung: Das wäre auch viel einfacher gegangen, nur weniger lehrreich:</p>
<div id="4d8bf9cc" class="cell" data-execution_count="18">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>oled.write_line(<span class="dv">0</span>, <span class="dv">0</span>, <span class="st">"Ass"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Wenn ihr beides hintereinander ausführt, steht oben “Ass” per Textfunktion und darunter “ASS” als eigene Bitmaps. Die <code>write_line()</code>-Funktion verwendet intern eine eingebaute Schriftart: Für jedes Zeichen ist in einer Tabelle hinterlegt, welche Pixel im 5×8-Raster leuchten.</p>
<p>Schriftarten für Pixel-Displays sind im Kern nichts anderes als Sammlungen von Bitmaps: Für jedes Zeichen wird festgelegt, welche Pixel leuchten. Wenn ihr eine andere Schrift wollt, erstellt ihr einfach eine neue Bitmap-Tabelle, etwa eine fette oder schmale Variante, und verwendet diese beim Zeichnen.</p>
<p>Diese Bitmap-Schriften funktionieren hervorragend in festen Rastergrößen, stoßen aber an Grenzen, sobald die Größe der Buchstaben beliebig geändert werden soll. Beim Vergrößern treten dann unschöne Treppeneffekte auf. Hier kommen Vektorgrafiken ins Spiel.</p>
</details>
</section>
<section id="sec-images-vector-graphics" class="level2 collapsable" data-number="4.5">
<h2 class="collapsable anchored" data-number="4.5" data-anchor-id="sec-images-vector-graphics"><span class="header-section-number">4.5</span> Vektorgrafiken</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Während Bitmaps jedes Pixel explizit speichern, beschreiben Vektorgrafiken Objekte über geometrische Formen, etwa “eine Linie von A nach B” oder “ein Kreis mit Mittelpunkt M und Radius r”.</p>
<p>Eine Vektor-Schriftart (wie TrueType) enthält keine 5×8-Raster pro Zeichen, sondern Pfade für die Konturen von “A”, “S” etc. Der Vorteil: Diese Formen lassen sich beliebig vergrößern oder verkleinern, ohne dass Treppeneffekte entstehen. Das ist ideal für hochauflösende Displays und Druck.</p>
<p>Schaut euch zur Verdeutlichung der Problematik einmal die beiden “a” aus <a href="#fig-images-truetype-vs-bitmap" class="quarto-xref">Abbildung&nbsp;<span>4.10</span></a> an. Das linke “a” ist eine TrueType-Schriftart, die als Vektorgrafik beschrieben wird. Das rechte “a” ist über eine Bitmap definiert und wurde stark vergrößert. Während das rechte “a” pixelig wirkt – wir sprechen vom Treppeneffekt – ist die als Vektorgrafik beschriebene Variante gestochen scharf, auch in großen Größen.</p>
<div id="fig-images-truetype-vs-bitmap" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-truetype-vs-bitmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://winf-hsos.github.io/university-docs/images/images_truetype_vs_bitmap.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-truetype-vs-bitmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.10: Das linke “a” ist eine TrueType-Schriftart, das rechte “a” eine Bitmap. Quelle: <a href="https://de.wikipedia.org/wiki/TrueType#/media/Datei:TTvsBmpFont.svg">Wikipedia</a>.
</figcaption>
</figure>
</div>
<p>Wie funktioniert das? Dazu betrachten wir ein anderes Beispiel für eine Vektorgrafik im weit verbreiteten Format <em>Scalable Vector Graphics</em> (SVG). Kopiert den folgenden Code in eine Textdatei und benennt sie <code>vector_graphics.svg</code>. Öffnet die Datei anschließend in einem Webbrowser.</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb21"><pre class="sourceCode numberSource xml number-lines code-with-copy"><code class="sourceCode xml"><span id="cb21-1"><a href="#cb21-1"></a>&lt;<span class="kw">svg</span><span class="ot"> width=</span><span class="st">"440"</span><span class="ot"> height=</span><span class="st">"220"</span><span class="ot"> xmlns=</span><span class="st">"http://www.w3.org/2000/svg"</span>&gt;</span>
<span id="cb21-2"><a href="#cb21-2"></a>  &lt;<span class="kw">circle</span><span class="ot"> cx=</span><span class="st">"60"</span><span class="ot"> cy=</span><span class="st">"60"</span><span class="ot"> r=</span><span class="st">"50"</span><span class="ot"> stroke=</span><span class="st">"#0085C7"</span><span class="ot"> stroke-width=</span><span class="st">"10"</span><span class="ot"> fill=</span><span class="st">"none"</span> /&gt;</span>
<span id="cb21-3"><a href="#cb21-3"></a>  &lt;<span class="kw">circle</span><span class="ot"> cx=</span><span class="st">"180"</span><span class="ot"> cy=</span><span class="st">"60"</span><span class="ot"> r=</span><span class="st">"50"</span><span class="ot"> stroke=</span><span class="st">"#000000"</span><span class="ot"> stroke-width=</span><span class="st">"10"</span><span class="ot"> fill=</span><span class="st">"none"</span> /&gt;</span>
<span id="cb21-4"><a href="#cb21-4"></a>  &lt;<span class="kw">circle</span><span class="ot"> cx=</span><span class="st">"300"</span><span class="ot"> cy=</span><span class="st">"60"</span><span class="ot"> r=</span><span class="st">"50"</span><span class="ot"> stroke=</span><span class="st">"#DF0024"</span><span class="ot"> stroke-width=</span><span class="st">"10"</span><span class="ot"> fill=</span><span class="st">"none"</span> /&gt;</span>
<span id="cb21-5"><a href="#cb21-5"></a>  &lt;<span class="kw">circle</span><span class="ot"> cx=</span><span class="st">"120"</span><span class="ot"> cy=</span><span class="st">"110"</span><span class="ot"> r=</span><span class="st">"50"</span><span class="ot"> stroke=</span><span class="st">"#FFD500"</span><span class="ot"> stroke-width=</span><span class="st">"10"</span><span class="ot"> fill=</span><span class="st">"none"</span> /&gt;</span>
<span id="cb21-6"><a href="#cb21-6"></a>  &lt;<span class="kw">circle</span><span class="ot"> cx=</span><span class="st">"240"</span><span class="ot"> cy=</span><span class="st">"110"</span><span class="ot"> r=</span><span class="st">"50"</span><span class="ot"> stroke=</span><span class="st">"#009F3D"</span><span class="ot"> stroke-width=</span><span class="st">"10"</span><span class="ot"> fill=</span><span class="st">"none"</span> /&gt;</span>
<span id="cb21-7"><a href="#cb21-7"></a>&lt;/<span class="kw">svg</span>&gt;</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<p>Ihr solltet ein Bild wie in <a href="#fig-images-vector-example" class="quarto-xref">Abbildung&nbsp;<span>4.11</span></a> sehen. Zoomt nun einmal stark hinein (Strg + Plus bzw. Cmd + Plus). Die Kreise bleiben scharf, ohne Treppeneffekte. Das liegt daran, dass Vektorgrafiken mathematisch beschrieben werden und nicht auf eine feste Pixelauflösung angewiesen sind.</p>
<div id="fig-images-vector-example" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-vector-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_vector_example.png" class="lightbox" data-gallery="quarto-lightbox-gallery-15" title="Abbildung&nbsp;4.11: Ein Versuch der Olympischen Ringe als Vektorgrafik, die man ohne Qualitätsverlust beliebig vergrößern kann."><img src="https://winf-hsos.github.io/university-docs/images/images_vector_example.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-vector-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.11: Ein Versuch der Olympischen Ringe als Vektorgrafik, die man ohne Qualitätsverlust beliebig vergrößern kann.
</figcaption>
</figure>
</div>
<p>Aber Moment: Wenn Vektorgrafiken auf einem Bildschirm angezeigt werden, müssen sie dann nicht auch als Pixel dargestellt werden? Schließlich besteht doch jedes Bild im Endeffekt aus Pixeln.</p>
<p>Genau. Während Vektorgrafiken das, was auf dem Bildschirm erscheinen soll, über geometrische Formen beschreiben, muss das Bild letztlich in eine Bitmap umgewandelt werden, damit es auf dem Bildschirm angezeigt werden kann. Dieser Prozess wird als Rasterisierung bezeichnet.</p>
<p>In <a href="#fig-images-vector-to-bitmap" class="quarto-xref">Abbildung&nbsp;<span>4.12</span></a> seht ihr die Vektorgrafik von oben, die in eine Bitmap mit niedriger Auflösung (100 × 50 Pixel) umgewandelt wurde. Wenn man dieses Bild stark vergrößert oder auf ein großes Werbeplakat druckt, erkennt man die Treppeneffekte deutlich. Die Auflösung einer Bitmap ist somit entscheidend für die Bildqualität.</p>
<div id="fig-images-vector-to-bitmap" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-vector-to-bitmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_vector_example_rasterization.png" class="lightbox" data-gallery="quarto-lightbox-gallery-16" title="Abbildung&nbsp;4.12: Die Beschreibung der geometrischen Objekte muss irgendwann in ein Bild aus Pixeln überführt werden. Dann spielt die Auflösung die entscheidende Rolle."><img src="https://winf-hsos.github.io/university-docs/images/images_vector_example_rasterization.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-vector-to-bitmap-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.12: Die Beschreibung der geometrischen Objekte muss irgendwann in ein Bild aus Pixeln überführt werden. Dann spielt die Auflösung die entscheidende Rolle.
</figcaption>
</figure>
</div>
<p>Bei Vektorgrafiken spielt die Auflösung dagegen erst bei der Rasterisierung eine Rolle: Wir können für ein 3×2 m Werbeplakat einfach eine entsprechend hochauflösende Bitmap generieren, ohne dass die Qualität leidet, weil die Vektorgrafik immer die gleichen geometrischen Formen <em>beschreibt</em>.</p>
<p>Aufgrund ihrer Eigenschaften werden Vektorgrafiken insbesondere für Logos, Icons und Schriftarten verwendet, die in verschiedenen Größen dargestellt werden müssen. Für komplexe Bilder mit vielen Farben und Details, wie Fotos, sind Bitmaps jedoch besser geeignet, weil eine Beschreibung als reine Geometrie zu aufwendig wäre.</p>
<p>Am Ende landen aber sowohl Bitmaps als auch Vektorgrafiken auf unserem Display immer als dasselbe: als Liste von Bits für die Pixel. Genau diese Perspektive nehmen wir im nächsten Abschnitt ein.</p>
</details>
</section>
<section id="sec-images-bits-to-display" class="level2 collapsable" data-number="4.6">
<h2 class="collapsable anchored" data-number="4.6" data-anchor-id="sec-images-bits-to-display"><span class="header-section-number">4.6</span> Von Bits zum Bild</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Wir bleiben in diesem Kapitel bei Bitmaps, denn ein Bildschirm kennt nur Pixel. Egal, ob ein Bild ursprünglich eine Vektorgrafik war oder direkt als Bitmap vorliegt: Um es auf unserem Display anzuzeigen, müssen wir es in eine Liste von Pixelwerten umwandeln und mit <code>write_pixels()</code> zeichnen.</p>
<p>Auf unserem OLED reicht eine Liste mit Binärwerten (0 und 1) aus, um jedes Pixel als ein- oder ausgeschaltet zu kennzeichnen. Für farbige Displays (z.B. Smartphone, TV) werden mehrere Bits pro Pixel benötigt. Ihr erinnert euch an den RGB-Farbcode aus <a href="colors.html" class="quarto-xref"><span>Kapitel 1</span></a>.</p>
<section id="darth-vader-als-pixelart" class="level3" data-number="4.6.1">
<h3 data-number="4.6.1" class="anchored" data-anchor-id="darth-vader-als-pixelart"><span class="header-section-number">4.6.1</span> Darth Vader als Pixelart</h3>
<p>Betrachtet einmal das Bild in <a href="#fig-images-bitmap-darth-vader" class="quarto-xref">Abbildung&nbsp;<span>4.13</span></a>. Ihr erkennt bestimmt, was es zeigt: eine Bitmap-Darstellung von Darth Vaders Kopf aus Star Wars. Das Bild ist 27 Pixel breit und 24 Pixel hoch, also insgesamt 648 Pixel. Jedes Pixel ist entweder schwarz oder weiß, das passt problemlos auf unser Display.</p>
<div id="fig-images-bitmap-darth-vader" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-bitmap-darth-vader-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_darth_vader.png" class="lightbox" data-gallery="quarto-lightbox-gallery-17" title="Abbildung&nbsp;4.13: Darth Vaders Kopf aus Star Wars als Bitmap"><img src="https://winf-hsos.github.io/university-docs/images/images_darth_vader.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-bitmap-darth-vader-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.13: Darth Vaders Kopf aus Star Wars als Bitmap
</figcaption>
</figure>
</div>
<p>Unser Ziel ist es, dieses Bild auf dem Display anzuzeigen. Dafür brauchen wir eine Liste aus Nullen und Einsen, die jedes Pixel repräsentiert. Die Idee, diese Liste per Hand aus einem Bild abzulesen, ist sehr mühsam und fehleranfällig.</p>
<p>Glücklicherweise liegt das Bild bereits digital vor – nicht als Bilddatei, sondern als Excel-Tabelle. Die Idee habe ich aus dem <a href="https://cs50.harvard.edu/x/2024/notes/4/#pixel-art">CS50-Kurs der Harvard University</a> übernommen: Dort erstellen Studierende Pixelbilder in Excel, indem sie die Zellen einfärben. Jede Zelle entspricht einem Pixel, das entweder schwarz oder weiß ist.</p>
<p>Die Excel-Datei mit Darth Vaders Maske könnt ihr euch <a href="resources/Darth Vader Pixel Art.xlsx">herunterladen</a> und das Ganze selbst ausprobieren.</p>
<p>Wir können das Problem im Sinne des EVA-Modells auffassen: Eingabe sind die Zellfarben in der Excel-Tabelle, Ausgabe soll eine Liste von Bits sein. Dazwischen liegt die Verarbeitung, die wir mit Python programmieren.</p>
<div id="fig-images-darth-vader-input-output" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-darth-vader-input-output-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_darth_vader_input_output.png" class="lightbox" data-gallery="quarto-lightbox-gallery-18" title="Abbildung&nbsp;4.14: Die Überführung einer Excel-basierten Bitmap in eine Liste aus Bits im EVA-Modell."><img src="https://winf-hsos.github.io/university-docs/images/images_darth_vader_input_output.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-darth-vader-input-output-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.14: Die Überführung einer Excel-basierten Bitmap in eine Liste aus Bits im EVA-Modell.
</figcaption>
</figure>
</div>
</section>
<section id="excel-mit-python-einlesen" class="level3" data-number="4.6.2">
<h3 data-number="4.6.2" class="anchored" data-anchor-id="excel-mit-python-einlesen"><span class="header-section-number">4.6.2</span> Excel mit Python einlesen</h3>
<p>Um Excel-Dateien in Python zu lesen, müssen wir das Rad nicht neu erfinden. Es gibt verschiedene Bibliotheken für diesen Job, eine der beliebtesten und einfachsten ist <code>openpyxl</code>. Installiert sie mit:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb22"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install openpyxl</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<p>(MacOS-Nutzer verwenden <code>pip3</code>.)</p>
<p><code>openpyxl</code> stellt uns die Funktion <code>load_workbook()</code> zur Verfügung, der wir den Pfad der Excel-Datei übergeben können:</p>
<div id="1b04332c" class="cell" data-execution_count="19">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-24"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-24" data-target-annotation="1">1</button><span id="annotated-cell-24-1" class="code-annotation-target"><a href="#annotated-cell-24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> openpyxl <span class="im">import</span> load_workbook</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-24" data-target-annotation="2">2</button><span id="annotated-cell-24-2" class="code-annotation-target"><a href="#annotated-cell-24-2" aria-hidden="true" tabindex="-1"></a>workbook <span class="op">=</span> load_workbook(<span class="st">"Darth Vader Pixel Art.xlsx"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-24" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-24" data-code-lines="1" data-code-annotation="1">Wir kündigen an, dass wir die Funktion <code>load_workbook()</code> verwenden möchten.</span>
</dd>
<dt data-target-cell="annotated-cell-24" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-24" data-code-lines="2" data-code-annotation="2">Wir laden die Excel-Datei und speichern das Ergebnis in der Variable <code>workbook</code>.</span>
</dd>
</dl>
</div>
</div>
<p>Ein Excel-Dokument kann mehrere Tabellenblätter enthalten. Wir wählen das Blatt “Darth Vader” aus:</p>
<div id="59de7e6c" class="cell" data-execution_count="20">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>sheet <span class="op">=</span> workbook[<span class="st">"Darth Vader"</span>]</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="zeile-für-zeile-die-pixelwerte-extrahieren" class="level3" data-number="4.6.3">
<h3 data-number="4.6.3" class="anchored" data-anchor-id="zeile-für-zeile-die-pixelwerte-extrahieren"><span class="header-section-number">4.6.3</span> Zeile für Zeile die Pixelwerte extrahieren</h3>
<p>Um aus der Excel-Darstellung zu einer Liste mit 0 und 1 zu kommen, schreiben wir ein Programm, das genau das Vorgehen simuliert, das wir per Hand machen würden: Zeile für Zeile durch die Tabelle gehen und für jede Zelle von links nach rechts prüfen, ob sie schwarz oder weiß ist.</p>
<p>Für wiederholte Abläufe verwenden wir Schleifen. Die Methode <code>sheet.iter_rows()</code> liefert uns alle Zeilen, über die wir mit einer <code>for</code>-Schleife iterieren können. Jede Zeile ist wiederum eine Liste von Zellen, über die wir ebenfalls iterieren:</p>
<div id="126e04c5" class="cell" data-execution_count="21">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-26"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-26" data-target-annotation="1">1</button><span id="annotated-cell-26-1" class="code-annotation-target"><a href="#annotated-cell-26-1"></a><span class="cf">for</span> row <span class="kw">in</span> sheet.iter_rows():</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-26" data-target-annotation="2">2</button><span id="annotated-cell-26-2" class="code-annotation-target"><a href="#annotated-cell-26-2"></a>    <span class="cf">for</span> cell <span class="kw">in</span> row:</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-26" data-target-annotation="3">3</button><span id="annotated-cell-26-3" class="code-annotation-target"><a href="#annotated-cell-26-3"></a>        ...</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-26" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-26" data-code-lines="1" data-code-annotation="1">Die äußere Schleife iteriert über jede Zeile im Tabellenblatt.</span>
</dd>
<dt data-target-cell="annotated-cell-26" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-26" data-code-lines="2" data-code-annotation="2">Die innere Schleife iteriert über jede Zelle in der aktuellen Zeile.</span>
</dd>
<dt data-target-cell="annotated-cell-26" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-26" data-code-lines="3" data-code-annotation="3">Hier ergänzen wir gleich den Code, der die Farbe der Zelle prüft.</span>
</dd>
</dl>
</div>
</div>
<p>Was passiert nun in der inneren Schleife? Wir müssen die Farbe der Zelle auslesen. Das geht über die Attribute <code>cell.fill.fgColor.rgb</code>. Die Details muss man nicht auswendig wissen, sie stehen in der <a href="https://openpyxl.readthedocs.io/en/stable/api/openpyxl.styles.fills.html">Dokumentation</a>.</p>
<p>Probieren wir, die Farbe der Zelle auszulesen und auszugeben:</p>
<div id="350d41a6" class="cell" data-execution_count="22">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-27"><pre class="sourceCode numberSource python code-annotation-code number-lines code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-27-1"><a href="#annotated-cell-27-1"></a><span class="cf">for</span> row <span class="kw">in</span> sheet.iter_rows():</span>
<span id="annotated-cell-27-2"><a href="#annotated-cell-27-2"></a>    <span class="cf">for</span> cell <span class="kw">in</span> row:</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-27" data-target-annotation="1">1</button><span id="annotated-cell-27-3" class="code-annotation-target"><a href="#annotated-cell-27-3"></a>        color <span class="op">=</span> <span class="bu">getattr</span>(cell.fill.fgColor, <span class="st">"rgb"</span>, <span class="va">None</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-27" data-target-annotation="2">2</button><span id="annotated-cell-27-4" class="code-annotation-target"><a href="#annotated-cell-27-4"></a>        <span class="bu">print</span>(color)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-27" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-27" data-code-lines="3" data-code-annotation="1">Wir lesen den Farbwert als Hexadezimalzahl aus.</span>
</dd>
<dt data-target-cell="annotated-cell-27" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-27" data-code-lines="4" data-code-annotation="2">Wir geben den Farbwert aus, um zu sehen, wie er aussieht.</span>
</dd>
</dl>
</div>
</div>
<p>Die Ausgabe sieht ungefähr so aus:</p>
<pre><code>00000000
00000000
...
FF000000
FF000000
...</code></pre>
<p>Offenbar bekommen wir 8-stellige Hexadezimalzahlen. Was bedeuten die noch gleich?</p>
</section>
<section id="hexadezimale-farbwerte" class="level3" data-number="4.6.4">
<h3 data-number="4.6.4" class="anchored" data-anchor-id="hexadezimale-farbwerte"><span class="header-section-number">4.6.4</span> Hexadezimale Farbwerte</h3>
<p>Im vorigen Kapitel <a href="numbers.html" class="quarto-xref"><span>Kapitel 2</span></a> haben wir das Binärsystem kennengelernt. Es ist ein Stellenwertsystem zur Basis 2. Ein weiteres, in der Informatik wichtiges System, ist das Hexadezimalsystem zur Basis 16. Es verwendet die Ziffern 0 bis 9 und anschließend die Buchstaben A bis F für die Werte 10 bis 15.</p>
<p>Hexadezimale Zahlen werden häufig verwendet, um Bytes kompakt darzustellen. Wie ihr gleich sehen werdet, passt ein Byte nämlich perfekt in zwei Hexadezimalziffern.</p>
<p>Wir können unser bekanntes Stellenwertschema auf die Basis 16 anwenden:</p>
<div id="fig-images-hexadecimal-places" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-hexadecimal-places-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_places_hexadecimal.png" class="lightbox" data-gallery="quarto-lightbox-gallery-19" title="Abbildung&nbsp;4.15: Das Stellenwertschema für das Hexadezimalsystem zur Basis 16. Funktioniert wie jedes andere Stellenwertsystem."><img src="https://winf-hsos.github.io/university-docs/images/images_places_hexadecimal.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-hexadecimal-places-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.15: Das Stellenwertschema für das Hexadezimalsystem zur Basis 16. Funktioniert wie jedes andere Stellenwertsystem.
</figcaption>
</figure>
</div>
<p>Die rechte Stelle hat den Wert <span class="math inline">\(16^0 = 1\)</span>, die nächste links den Wert <span class="math inline">\(16^1 = 16\)</span>, dann <span class="math inline">\(16^2 = 256\)</span> usw. Um den Wert einer Hexadezimalzahl zu berechnen, multiplizieren wir jede Ziffer mit ihrer Stellenwertigkeit und addieren die Ergebnisse.</p>
<p>Warum ist das interessant? Mit einer Hexadezimalziffer können wir Werte von 0 bis 15 darstellen. Im Binärsystem benötigen wir dafür vier Bits. Vier Bits entsprechen genau einem halben Byte, einem so genannten Nibble. Zwei Hexadezimalziffern können also alle 256 möglichen Werte eines Bytes (0–255) darstellen.</p>
<div id="fig-images-byte-compact-1" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-byte-compact-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_byte_compact_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-20" title="Abbildung&nbsp;4.16: Ein Byte lässt sich schön kompakt mit zwei Hexadezimalziffern darstellen."><img src="https://winf-hsos.github.io/university-docs/images/images_byte_compact_1.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-byte-compact-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.16: Ein Byte lässt sich schön kompakt mit zwei Hexadezimalziffern darstellen.
</figcaption>
</figure>
</div>
<div id="fig-images-byte-compact" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-byte-compact-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-byte-compact" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-images-byte-compact-2" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-byte-compact-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_byte_compact_2.png" class="lightbox" data-gallery="fig-images-byte-compact" title="Abbildung&nbsp;4.17&nbsp;(a): 0 entspricht dem Hexadezimalwert 0x00."><img src="https://winf-hsos.github.io/university-docs/images/images_byte_compact_2.png" class="img-fluid figure-img" data-ref-parent="fig-images-byte-compact"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-byte-compact-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) 0 entspricht dem Hexadezimalwert 0x00.
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-byte-compact" style="flex-basis: 50.0%;justify-content: flex-start;">
<div id="fig-images-byte-compact-3" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-byte-compact-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_byte_compact_3.png" class="lightbox" data-gallery="fig-images-byte-compact" title="Abbildung&nbsp;4.17&nbsp;(b): 255 entspricht dem Hexadezimalwert 0xFF."><img src="https://winf-hsos.github.io/university-docs/images/images_byte_compact_3.png" class="img-fluid figure-img" data-ref-parent="fig-images-byte-compact"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-byte-compact-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) 255 entspricht dem Hexadezimalwert 0xFF.
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-byte-compact-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.17: Darstellung von Bytes als Hexadezimalzahlen.
</figcaption>
</figure>
</div>
<p>Kleine Randnotiz: In der Informatik wird eine Hexadezimalzahl häufig mit einem vorangestellten <code>0x</code> gekennzeichnet, um klarzumachen, dass es sich um eine Hexadezimalzahl handelt. So wird aus der Zahl 255 im Dezimalsystem die Zahl <code>0xFF</code> im Hexadezimalsystem.</p>
<section id="alpha-werte" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="alpha-werte">Alpha-Werte</h4>
<p>Zurück zur Ausgabe von oben: Wir haben 8-stellige Hexadezimalzahlen gesehen, obwohl ein RGB-Wert aus drei Bytes (also 6 Hexziffern) besteht. Die Erklärung: Die ersten beiden Ziffern repräsentieren die Transparenz (Alpha-Kanal), gefolgt von den sechs Ziffern für Rot, Grün und Blau.</p>
<p>In unserem Fall sind die Farben entweder komplett schwarz (<code>FF000000</code>) oder komplett weiß (<code>FF000000</code> für schwarz mit vollem Alpha, später <code>FFFFFFFF</code> für weiß). Die ersten beiden Ziffern <code>FF</code> stehen dabei für den Alpha-Wert: vollständig sichtbar.</p>
<p>Macht einmal den Test und färbt die obere linke Zelle in Rot ein. Nach einem erneuten Lauf (Excel speichern und schließen!) erhaltet ihr z.B.:</p>
<pre><code>FFFF0000
00000000
...</code></pre>
<p><code>FFFF0000</code> steht für: FF (Alpha, voll sichtbar), FF (Rot, volle Intensität), 00 (Grün, 0), 00 (Blau, 0) – also Rot.</p>
</section>
</section>
<section id="die-liste-mit-bits-erstellen" class="level3" data-number="4.6.5">
<h3 data-number="4.6.5" class="anchored" data-anchor-id="die-liste-mit-bits-erstellen"><span class="header-section-number">4.6.5</span> Die Liste mit Bits erstellen</h3>
<p>Jetzt, da wir die Farbwerte verstehen, können wir sie auswerten. Für Darth Vader ist jede schwarze Zelle ein gesetztes Pixel (<code>1</code>), jede nicht-schwarze Zelle ein ausgeschaltetes Pixel (<code>0</code>):</p>
<div id="556c88e3" class="cell" data-execution_count="23">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb26"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1"></a><span class="im">from</span> openpyxl <span class="im">import</span> load_workbook</span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a>workbook <span class="op">=</span> load_workbook(<span class="st">"Darth Vader Pixel Art.xlsx"</span>)</span>
<span id="cb26-4"><a href="#cb26-4"></a>sheet <span class="op">=</span> workbook[<span class="st">"Darth Vader"</span>]</span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a>bits <span class="op">=</span> []</span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="cf">for</span> row <span class="kw">in</span> sheet.iter_rows():</span>
<span id="cb26-8"><a href="#cb26-8"></a>    <span class="cf">for</span> cell <span class="kw">in</span> row:</span>
<span id="cb26-9"><a href="#cb26-9"></a>        color <span class="op">=</span> <span class="bu">getattr</span>(cell.fill.fgColor, <span class="st">"rgb"</span>, <span class="va">None</span>)</span>
<span id="cb26-10"><a href="#cb26-10"></a>        <span class="cf">if</span> color <span class="op">==</span> <span class="st">"FF000000"</span>:        <span class="co"># schwarz</span></span>
<span id="cb26-11"><a href="#cb26-11"></a>            bits.append(<span class="dv">1</span>)</span>
<span id="cb26-12"><a href="#cb26-12"></a>        <span class="cf">else</span>:                           <span class="co"># alles andere behandeln wir als weiß</span></span>
<span id="cb26-13"><a href="#cb26-13"></a>            bits.append(<span class="dv">0</span>)</span>
<span id="cb26-14"><a href="#cb26-14"></a></span>
<span id="cb26-15"><a href="#cb26-15"></a><span class="bu">print</span>(<span class="ss">f"Bitmap with </span><span class="sc">{</span><span class="bu">len</span>(bits)<span class="sc">}</span><span class="ss"> bits: </span><span class="sc">{</span>bits<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Die <code>if</code>-Anweisung entscheidet, ob wir eine 1 oder 0 anhängen. Das Hinzufügen am Ende der Liste erledigt die <code>append()</code>-Methode. Am Ende haben wir eine Liste mit 648 Einträgen, genau so viele wie das Bild Pixel hat.</p>
</section>
<section id="anzeige-auf-dem-display" class="level3" data-number="4.6.6">
<h3 data-number="4.6.6" class="anchored" data-anchor-id="anzeige-auf-dem-display"><span class="header-section-number">4.6.6</span> Anzeige auf dem Display</h3>
<p>Wie wir Pixel auf dem Display anzeigen, haben wir in <a href="#sec-images-pixels" class="quarto-xref"><span>Abschnitt 4.2</span></a> gelernt. Jetzt nutzen wir dieselbe <code>write_pixels()</code>-Funktion, um Darth Vaders Maske darzustellen.</p>
<p>Wir müssen nur die Position und Größe des Bildes festlegen. Ich habe mich für die Position (50, 20) als oberen linken Punkt entschieden, so erscheint das Bild ungefähr in der Mitte. Das Bild ist 27 Pixel breit und 24 Pixel hoch, der untere rechte Punkt ist also (76, 43):</p>
<div id="3516439c" class="cell" data-execution_count="24">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">50</span>, <span class="dv">20</span>, <span class="dv">76</span>, <span class="dv">43</span>, bits)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Natürlich müssen wir zuvor wie gewohnt den Boilerplate-Code zum Initialisieren des Displays ergänzen. Das komplette Programm sieht dann so aus:</p>
<div id="5a15120a" class="cell" data-execution_count="25">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb28"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1"></a><span class="im">from</span> openpyxl <span class="im">import</span> load_workbook</span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="im">from</span> tinkerforge.ip_connection <span class="im">import</span> IPConnection</span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="im">from</span> tinkerforge.bricklet_oled_128x64_v2 <span class="im">import</span> BrickletOLED128x64V2</span>
<span id="cb28-4"><a href="#cb28-4"></a></span>
<span id="cb28-5"><a href="#cb28-5"></a>ipcon <span class="op">=</span> IPConnection()</span>
<span id="cb28-6"><a href="#cb28-6"></a>ipcon.<span class="ex">connect</span>(<span class="st">'localhost'</span>, <span class="dv">4223</span>)</span>
<span id="cb28-7"><a href="#cb28-7"></a>oled <span class="op">=</span> BrickletOLED128x64V2(<span class="st">'25zo'</span>, ipcon)</span>
<span id="cb28-8"><a href="#cb28-8"></a>oled.clear_display()</span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a>workbook <span class="op">=</span> load_workbook(<span class="st">"xlsx/Darth Vader Pixel Art.xlsx"</span>)</span>
<span id="cb28-11"><a href="#cb28-11"></a>sheet <span class="op">=</span> workbook[<span class="st">"Darth Vader"</span>]</span>
<span id="cb28-12"><a href="#cb28-12"></a></span>
<span id="cb28-13"><a href="#cb28-13"></a>bits <span class="op">=</span> []</span>
<span id="cb28-14"><a href="#cb28-14"></a><span class="cf">for</span> row <span class="kw">in</span> sheet.iter_rows():</span>
<span id="cb28-15"><a href="#cb28-15"></a>    <span class="cf">for</span> cell <span class="kw">in</span> row:</span>
<span id="cb28-16"><a href="#cb28-16"></a>        color <span class="op">=</span> <span class="bu">getattr</span>(cell.fill.fgColor, <span class="st">"rgb"</span>, <span class="va">None</span>)</span>
<span id="cb28-17"><a href="#cb28-17"></a>        <span class="cf">if</span> color <span class="op">==</span> <span class="st">"FF000000"</span>:</span>
<span id="cb28-18"><a href="#cb28-18"></a>            bits.append(<span class="dv">1</span>)</span>
<span id="cb28-19"><a href="#cb28-19"></a>        <span class="cf">else</span>:</span>
<span id="cb28-20"><a href="#cb28-20"></a>            bits.append(<span class="dv">0</span>)</span>
<span id="cb28-21"><a href="#cb28-21"></a></span>
<span id="cb28-22"><a href="#cb28-22"></a><span class="bu">print</span>(<span class="ss">f"Bitmap with </span><span class="sc">{</span><span class="bu">len</span>(bits)<span class="sc">}</span><span class="ss"> bits: </span><span class="sc">{</span>bits<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb28-23"><a href="#cb28-23"></a>oled.write_pixels(<span class="dv">50</span>, <span class="dv">20</span>, <span class="dv">76</span>, <span class="dv">43</span>, bits)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Und voilà: Darth Vader erscheint auf dem Display!</p>
<div id="fig-images-oled-display-darth-vader" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-oled-display-darth-vader-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/oled_display_darth_vader.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-23" title="Abbildung&nbsp;4.18: Darth Vaders Maske als Bitmap aus dem OLED-Display."><img src="images/oled_display_darth_vader.jpg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-oled-display-darth-vader-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.18: Darth Vaders Maske als Bitmap aus dem OLED-Display.
</figcaption>
</figure>
</div>
</section>
<section id="sec-images-save-bitmap" class="level3" data-number="4.6.7">
<h3 data-number="4.6.7" class="anchored" data-anchor-id="sec-images-save-bitmap"><span class="header-section-number">4.6.7</span> Eine Bitmap speichern</h3>
<p>Wir haben ein Programm geschrieben, das eine Bitmap aus Excel ausliest und auf dem Display anzeigt. Excel ist dafür aber eher eine Notlösung. Für Bitmaps gibt es besser geeignete Formate, z.B. BMP (Bitmap). Es ist ein einfaches, unkomprimiertes Format, das die Pixelwerte direkt als Abfolge von Bits speichert.</p>
<p>Wenn wir das händisch machen wollten, müssten wir uns mit dem genauen Aufbau des BMP-Formats beschäftigen. Das besteht neben den Farbwerten nämlich auch aus einem so genannten Header, der Metainformationen wie Breite, Höhe oder die Farbtiefe eines Bildes speichert. Das sparen wir uns an dieser Stelle und nutzen stattdessen wieder eine Bibliothek, die alle einfacher macht: <code>Pillow</code>.</p>
<p>Installiert sie mit:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb29"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">pip</span> install Pillow</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<p>(MacOS-Nutzer: <code>pip3</code>.)</p>
<p>Mit <code>Pillow</code> können wir Bilder bequem erstellen und speichern. Für Darth Vader (27×24 Pixel, Schwarzweiß) sieht das so aus:</p>
<div id="a529eaf2" class="cell" data-execution_count="26">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-34"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-34" data-target-annotation="1">1</button><span id="annotated-cell-34-1" class="code-annotation-target"><a href="#annotated-cell-34-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="annotated-cell-34-2"><a href="#annotated-cell-34-2" aria-hidden="true" tabindex="-1"></a>...</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-34" data-target-annotation="2">2</button><span id="annotated-cell-34-3" class="code-annotation-target"><a href="#annotated-cell-34-3" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.new(<span class="st">'1'</span>, (<span class="dv">27</span>, <span class="dv">24</span>))</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-34" data-target-annotation="3">3</button><span id="annotated-cell-34-4" class="code-annotation-target"><a href="#annotated-cell-34-4" aria-hidden="true" tabindex="-1"></a>image.putdata(bits)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-34" data-target-annotation="4">4</button><span id="annotated-cell-34-5" class="code-annotation-target"><a href="#annotated-cell-34-5" aria-hidden="true" tabindex="-1"></a>image.save(<span class="st">"xlsx/darth_vader.bmp"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-34" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-34" data-code-lines="1" data-code-annotation="1">Wir importieren die <code>Image</code>-Klasse aus <code>PIL</code> (Teil von <code>Pillow</code>).</span>
</dd>
<dt data-target-cell="annotated-cell-34" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-34" data-code-lines="3" data-code-annotation="2">Wir erstellen ein neues Bildobjekt mit der Größe 27×24 Pixel im Modus <code>"1"</code> (Schwarzweiß).</span>
</dd>
<dt data-target-cell="annotated-cell-34" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-34" data-code-lines="4" data-code-annotation="3">Wir setzen die Pixelwerte des Bildes mit unserer Liste <code>bits</code> (zeilenweise von links nach rechts, oben nach unten).</span>
</dd>
<dt data-target-cell="annotated-cell-34" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-34" data-code-lines="5" data-code-annotation="4">Wir speichern das Bild als BMP-Datei.</span>
</dd>
</dl>
</div>
</div>
<p>Zuerst erstellen wir eine leere Hülle für unsere Bild und geben die Dimensionen sowie die Farbtiefe an. Anschließend übergeben wir dem Bild die Daten, hier unsere Liste <code>bits</code> mit den Nullen und Einsen. Mit <code>image.save()</code> speichern wir die Bitmap-Datei ab. Im Ordner <code>xlsx</code> solltet ihr nun die Datei <code>darth_vader.bmp</code> finden.</p>
<div id="fig-images-darth-vader-saved-bmp" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-darth-vader-saved-bmp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="images/darth_vader_saved_bmp.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-darth-vader-saved-bmp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.19: Darth Vader als Bitmap-Datei auf eurer Festplatte.
</figcaption>
</figure>
</div>
<p>Damit haben wir die Kette geschlossen: Excel-Pixel → Bitliste → Anzeige auf dem Display → echte Bitmap-Datei. Im nächsten Schritt erweitern wir das Ganze auf Farbbilder.</p>
</section></details>
</section>

<section id="sec-images-color" class="level2 collapsable" data-number="4.7">
<h2 class="collapsable anchored" data-number="4.7" data-anchor-id="sec-images-color"><span class="header-section-number">4.7</span> Farbe</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Bisher haben wir nur Schwarzweiß-Bitmaps verwendet, in denen ein Pixel entweder 0 (schwarz) oder 1 (weiß) ist. Für unser Display reicht das, aber typische Bildschirme arbeiten mit Farben.</p>
<p>Die wichtigste Grundlage dafür, nämlich den RGB-Code, haben wir bereits in <a href="colors.html" class="quarto-xref"><span>Kapitel 1</span></a> kennengelernt.</p>
<section id="bitmaps-im-rgb-format" class="level3" data-number="4.7.1">
<h3 data-number="4.7.1" class="anchored" data-anchor-id="bitmaps-im-rgb-format"><span class="header-section-number">4.7.1</span> Bitmaps im RGB-Format</h3>
<p>In <a href="#fig-images-super-mario" class="quarto-xref">Abbildung&nbsp;<span>4.20</span></a> seht ihr eine farbige Bitmap von Super Mario, wie sie auf der 8-Bit-Konsole Nintendo Entertainment System (NES) über den Bildschirm geflimmert ist. Die Auflösung der NES-Konsole war 256 × 240 Pixel – deutlich weniger als heutige Full-HD-Bildschirme, aber für viel Spielspaß ausreichend.</p>
<div id="fig-images-super-mario" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-super-mario-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_super_mario.png" class="lightbox" data-gallery="quarto-lightbox-gallery-24" title="Abbildung&nbsp;4.20: Super Mario aus der 8-Bit Nintendo-Spielkonsole NES als Bitmap"><img src="https://winf-hsos.github.io/university-docs/images/images_super_mario.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-super-mario-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.20: Super Mario aus der 8-Bit Nintendo-Spielkonsole NES als Bitmap
</figcaption>
</figure>
</div>
<p>Super Mario in dieser Darstellung ist 16 Pixel breit und 16 Pixel hoch, also 256 Pixel. Jedes Pixel ist farbig und wird durch einen RGB-Wert (3 Bytes) repräsentiert. Damit benötigt die gesamte Bitmap 256 Pixel × 3 Bytes = 768 Bytes Speicherplatz. Übrigens: Die NES-Spielekonsole konnte nur 256 Farben gleichzeitig darstellen, was 8 Bits pro Pixel entspricht. In diesem Fall wären es 256 Pixel × 1 Byte = 256 Bytes. Heute sind 24 Bits (3 Bytes) pro Pixel üblich, was 16,7 Millionen Farben ermöglicht.</p>
<p>Zum Vergleich: Darth Vader hatte 27×24 = 648 Pixel, aber nur 1 Bit pro Pixel. Das sind 648 Bits = 81 Bytes. Ein größeres Bild kann also <em>weniger</em> Speicher benötigen, wenn es nur Schwarzweiß ist. Die Farbtiefe spielt neben der Auflösung eine entscheidende Rolle für die Dateigröße.</p>
<p>Auch Super Mario habe ich als Excel-Tabelle erstellt, genau wie Darth Vader. Ihr könnt die Datei <a href="resources/Super Mario Pixel Art.xlsx">hier herunterladen</a>.</p>
<p>Wir können unser Programm von oben grundsätzlich wiederverwenden, müssen es aber anpassen: Statt 0 oder 1 pro Pixel wollen wir die RGB-Werte in eine Liste von Dreiertupeln überführen: Ein Wert für jeden Farbkanal im RGB-Code.</p>
<p>Wir laden zunächst die neue Excel-Datei und das Tabellenblatt:</p>
<div id="631e7003" class="cell" data-execution_count="27">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>workbook <span class="op">=</span> load_workbook(<span class="st">"Super Mario Pixel Art.xlsx"</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>sheet <span class="op">=</span> workbook[<span class="st">"Super Mario"</span>]</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Die verschachtelten Schleifen bleiben, aber diesmal interessieren uns nicht nur Schwarz und Weiß, sondern die vollen RGB-Farben. <code>openpyxl</code> liefert die Farbwerte wieder als 8-stellige Hexadezimalzahlen (inklusive Alpha-Kanal). Uns interessieren nur die letzten 6 Ziffern:</p>
<div id="20bfd93d" class="cell" data-execution_count="28">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-36"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-36-1"><a href="#annotated-cell-36-1" aria-hidden="true" tabindex="-1"></a>bitmap <span class="op">=</span> []</span>
<span id="annotated-cell-36-2"><a href="#annotated-cell-36-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> sheet.iter_rows():</span>
<span id="annotated-cell-36-3"><a href="#annotated-cell-36-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> cell <span class="kw">in</span> row:</span>
<span id="annotated-cell-36-4"><a href="#annotated-cell-36-4" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">getattr</span>(cell.fill.fgColor, <span class="st">"rgb"</span>, <span class="va">None</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-36" data-target-annotation="1">1</button><span id="annotated-cell-36-5" class="code-annotation-target"><a href="#annotated-cell-36-5" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> color[<span class="dv">2</span>:]</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-36" data-target-annotation="2">2</button><span id="annotated-cell-36-6" class="code-annotation-target"><a href="#annotated-cell-36-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(color)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-36" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-36" data-code-lines="5" data-code-annotation="1">Wir schneiden die ersten beiden Ziffern (Alpha-Wert) ab.</span>
</dd>
<dt data-target-cell="annotated-cell-36" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-36" data-code-lines="6" data-code-annotation="2">Wir prüfen, ob wir tatsächlich 6-stellige RGB-Werte erhalten.</span>
</dd>
</dl>
</div>
</div>
<p>Die Ausgabe sieht z.B. so aus:</p>
<pre><code>FFFFFF
FFFFFF
...
B53120
B53120
...</code></pre>
<p>Für die Bildspeicherung im RGB-Format benötigt <code>Pillow</code> pro Pixel ein Dreiertupel mit Dezimalwerten, z.B. für drei weiße Pixel:</p>
<div id="d9a1be53" class="cell" data-execution_count="29">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>bitmap <span class="op">=</span> [(<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>), (<span class="dv">255</span>, <span class="dv">255</span>, <span class="dv">255</span>)]</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Wir müssen also:</p>
<ol type="1">
<li>Den Hex-String <code>RRGGBB</code> in seine Bestandteile zerlegen und</li>
<li>Jede Komponente in eine Dezimalzahl umwandeln.</li>
</ol>
<p>Beides erledigt Python für uns:</p>
<div id="ec41c4e7" class="cell" data-execution_count="30">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-39"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-39-1"><a href="#annotated-cell-39-1" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="annotated-cell-39-2"><a href="#annotated-cell-39-2" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> <span class="bu">getattr</span>(cell.fill.fgColor, <span class="st">"rgb"</span>, <span class="va">None</span>)</span>
<span id="annotated-cell-39-3"><a href="#annotated-cell-39-3" aria-hidden="true" tabindex="-1"></a>color <span class="op">=</span> color[<span class="dv">2</span>:]</span>
<span id="annotated-cell-39-4"><a href="#annotated-cell-39-4" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-39" data-target-annotation="1">1</button><span id="annotated-cell-39-5" class="code-annotation-target"><a href="#annotated-cell-39-5" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="bu">int</span>(color[<span class="dv">0</span>:<span class="dv">2</span>], <span class="dv">16</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-39" data-target-annotation="2">2</button><span id="annotated-cell-39-6" class="code-annotation-target"><a href="#annotated-cell-39-6" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="bu">int</span>(color[<span class="dv">2</span>:<span class="dv">4</span>], <span class="dv">16</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-39" data-target-annotation="3">3</button><span id="annotated-cell-39-7" class="code-annotation-target"><a href="#annotated-cell-39-7" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="bu">int</span>(color[<span class="dv">4</span>:<span class="dv">6</span>], <span class="dv">16</span>)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-39" data-target-annotation="4">4</button><span id="annotated-cell-39-8" class="code-annotation-target"><a href="#annotated-cell-39-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(r, g, b)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-39" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-39" data-code-lines="5" data-code-annotation="1">Wir extrahieren die ersten beiden Ziffern (Rot) und wandeln sie in eine Dezimalzahl um.</span>
</dd>
<dt data-target-cell="annotated-cell-39" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-39" data-code-lines="6" data-code-annotation="2">Wir extrahieren die nächsten beiden Ziffern (Grün).</span>
</dd>
<dt data-target-cell="annotated-cell-39" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-39" data-code-lines="7" data-code-annotation="3">Wir extrahieren die letzten beiden Ziffern (Blau).</span>
</dd>
<dt data-target-cell="annotated-cell-39" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-39" data-code-lines="8" data-code-annotation="4">Wir prüfen, ob die Umwandlung funktioniert hat.</span>
</dd>
</dl>
</div>
</div>
<p>Die Ausgabe beginnt z.B. so:</p>
<pre><code>255 255 255
255 255 255
...
181 49 32
...</code></pre>
<p>Nun sammeln wir die RGB-Werte in einer Liste von Tupeln:</p>
<div id="feda6401" class="cell" data-execution_count="31">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>bitmap <span class="op">=</span> []</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> row <span class="kw">in</span> sheet.iter_rows():</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> cell <span class="kw">in</span> row:</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> <span class="bu">getattr</span>(cell.fill.fgColor, <span class="st">"rgb"</span>, <span class="va">None</span>)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>        color <span class="op">=</span> color[<span class="dv">2</span>:]</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        r <span class="op">=</span> <span class="bu">int</span>(color[<span class="dv">0</span>:<span class="dv">2</span>], <span class="dv">16</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> <span class="bu">int</span>(color[<span class="dv">2</span>:<span class="dv">4</span>], <span class="dv">16</span>)</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> <span class="bu">int</span>(color[<span class="dv">4</span>:<span class="dv">6</span>], <span class="dv">16</span>)</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>        rgb_tuple <span class="op">=</span> (r, g, b)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>        bitmap.append(rgb_tuple)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Mit dieser Liste <code>bitmap</code> können wir nun ein farbiges Bild von Super Mario erzeugen und speichern. Das funktioniert analog zu Darth Vader oben, nur dass wir diesmal den Modus <code>'RGB'</code> und eine Dimensionierung von 16 × 16 Pixeln verwenden:</p>
<div id="e1bd1b4f" class="cell" data-execution_count="32">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.new(<span class="st">'RGB'</span>, (<span class="dv">16</span>, <span class="dv">16</span>))</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>image.putdata(bitmap)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>image.save(<span class="st">"xlsx/super_mario_color.bmp"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Wenn ihr die Datei <code>super_mario_color.bmp</code> öffnet, seht ihr Mario in Farbe.</p>
</section>
<section id="struktur-einer-bitmap-datei" class="level3" data-number="4.7.2">
<h3 data-number="4.7.2" class="anchored" data-anchor-id="struktur-einer-bitmap-datei"><span class="header-section-number">4.7.2</span> Struktur einer Bitmap-Datei</h3>
<p>Schauen wir uns nun die Dateigröße an. Im Datei-Explorer oder im Terminal könnt ihr euch die Details einer Datei anzeigen lassen. Auf der Kommandozeile in Windows mit dem Befehl <code>dir</code>, unter Mac/Linux geht das mit <code>ls -lh</code>. So ungefähr sieht die Ausgabe aus:</p>
<pre><code>28.10.2025  19:41    822 super_mario_color.bmp</code></pre>
<p>Die Zahl direkt vor dem Dateinamen ist die Dateigröße in Bytes. In meinem Fall sind es 822 Bytes.</p>
<p>Rein rechnerisch bräuchten wir aber nur:</p>
<p><span class="math display">\[16 \cdot 16 \cdot 3 = 768\]</span></p>
<p>Bytes, denn wir haben 16×16 = 256 Pixel und jedes Pixel benötigt 3 Bytes. Wo kommen also die restlichen 54 Bytes her?</p>
<p>Die Erklärung: Eine Bitmap-Datei (und praktisch jede andere Datei auch) enthält neben den eigentlichen Informationen (hier: Pixelwerte) noch Metainformationen, also Informationen <em>über</em> das Bild. Dazu gehören z.B. Breite, Höhe und Farbtiefe. Diese Metadaten stehen im sogenannten Header am Anfang der Datei.</p>
<p>Die wichtigsten Strukturelemente einer Bitmap-Datei sind in <a href="#fig-images-bitmap-structure" class="quarto-xref">Abbildung&nbsp;<span>4.21</span></a> dargestellt. Wir sehen dort die Datei in einem Hexadezimal-Editor. Jedes Kästchen repräsentiert ein Byte (2 Hexadezimalziffern). Die farbigen Bereiche kennzeichnen die verschiedenen Abschnitte der Datei.</p>
<div id="fig-images-bitmap-structure" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-bitmap-structure-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_bitmap_structure.png" class="lightbox" data-gallery="quarto-lightbox-gallery-25" title="Abbildung&nbsp;4.21: Die Struktur einer Bitmap-Datei am Beispiel der super_mario_color.bmp von oben"><img src="https://winf-hsos.github.io/university-docs/images/images_bitmap_structure.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-bitmap-structure-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.21: Die Struktur einer Bitmap-Datei am Beispiel der super_mario_color.bmp von oben
</figcaption>
</figure>
</div>
<ul>
<li>Der kleine gelbe Bereich am Anfang ist 14 Bytes lang und stellt den Datei-Header dar. Die ersten beiden Bytes <code>42</code> und <code>4D</code> stehen für die ASCII-Zeichen “B” und “M” – ein Kennzeichen für Bitmap-Dateien. Hier steht auch die Gesamtgröße der Datei (z.B. <code>36 03 00 00</code>, was 822 Bytes entspricht; im sogenannten Little-Endian-Format sind die Bytes in umgekehrter Reihenfolge gespeichert) und die Position, an der die eigentlichen Pixelwerte beginnen (hier: Byte 54).</li>
<li>Direkt danach folgt der rosafarbene Bereich mit 40 Bytes: der DIB-Header (Device Independent Bitmap). Hier sind u.a. Breite, Höhe und Farbtiefe gespeichert. Die <code>18</code> steht z.B. für 24 Bits Farbtiefe.</li>
<li>Erst danach folgen die eigentlichen Pixelwerte (grün markiert). In unserem Fall sind das 768 Bytes.</li>
</ul>
<p>Probiert es am besten selbst aus: Öffnet die Webseite <a href="https://hexed.it/">hexed.it</a> in eurem Browser, ladet <code>super_mario_color.bmp</code> und schaut euch die Datei an. Der Editor zeigt jedes Byte als Hexadezimalzahl an. In <a href="#fig-images-hex-editor-mario" class="quarto-xref">Abbildung&nbsp;<span>4.22</span></a> sind die Farbwerte der ersten drei Pixel rot umrandet.</p>
<div id="fig-images-hex-editor-mario" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-hex-editor-mario-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_hex_editor_mario.png" class="lightbox" data-gallery="quarto-lightbox-gallery-26" title="Abbildung&nbsp;4.22: Marios Bitmap im Hex-Editor. Hier wird jedes Byte als Hexadezimalzahl angezeigt."><img src="https://winf-hsos.github.io/university-docs/images/images_hex_editor_mario.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-hex-editor-mario-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.22: Marios Bitmap im Hex-Editor. Hier wird jedes Byte als Hexadezimalzahl angezeigt.
</figcaption>
</figure>
</div>
<p>Es passt also alles zusammen:</p>
<ul>
<li>14 Bytes Datei-Header</li>
<li>40 Bytes DIB-Header</li>
<li>768 Bytes Pixelwerte</li>
</ul>
<p>Das macht insgesamt 822 Bytes. Wir haben damit ein sehr konkretes Beispiel dafür, wie Bilddaten im Computer gespeichert werden.</p>
<p>Im nächsten Schritt machen wir diese Bilder lebendig.</p>
</section></details>
</section>

<section id="sec-images-animation" class="level2 collapsable" data-number="4.8">
<h2 class="collapsable anchored" data-number="4.8" data-anchor-id="sec-images-animation"><span class="header-section-number">4.8</span> Animationen</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Viele Anwendungen, z.B. Videospiele wie Super Mario, kommen mit statischen Bildern nicht aus. Mario kann laufen, hüpfen und Feuerkugeln schleudern. Auch bei Videoclips auf YouTube oder Filmen auf Netflix stehen bewegte Bilder im Vordergrund. Wie funktionieren solche bewegten Bilder?</p>
<p>Das Verständnis von statischen Bildern ist die Grundvoraussetzung dafür. Eine Animation besteht im Kern aus einer schnellen Abfolge von Einzelbildern (Frames), die nacheinander angezeigt werden. Wenn die Bilder schnell genug wechseln, entsteht der Eindruck von Bewegung. Unser Gehirn kann ab einer bestimmten Bildwechselrate nicht mehr zwischen einzelnen Bildern unterscheiden.</p>
<p>Um das einmal Hands-On zu erfahren, versuchen wir, Mario zum Laufen zu bringen. Dazu benötigen wir mehrere Bilder, die nacheinander die unterschiedlichen Posen abbilden, die Mario beim Laufen einnimmt. In <a href="#fig-images-super-mario-walk" class="quarto-xref">Abbildung&nbsp;<span>4.23</span></a> seht ihr drei solcher Bilder (die werden auch Sprites genannt) – direkt aus dem Spiel “Super Mario Bros.” der 1980er-Jahre.</p>
<div id="fig-images-super-mario-walk" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-super-mario-walk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-super-mario-walk" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-images-super-mario-walk-1" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="super-mario-walk">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-super-mario-walk-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_super_mario_walk_1.png" class="lightbox" data-gallery="super-mario-walk" title="Abbildung&nbsp;4.23&nbsp;(a): Erster Frame"><img src="https://winf-hsos.github.io/university-docs/images/images_super_mario_walk_1.png" class="img-fluid figure-img" data-ref-parent="fig-images-super-mario-walk"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-super-mario-walk-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Erster Frame
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-super-mario-walk" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-images-super-mario-walk-2" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="super-mario-walk">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-super-mario-walk-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_super_mario_walk_2.png" class="lightbox" data-gallery="super-mario-walk" title="Abbildung&nbsp;4.23&nbsp;(b): Zweiter Frame"><img src="https://winf-hsos.github.io/university-docs/images/images_super_mario_walk_2.png" class="img-fluid figure-img" data-ref-parent="fig-images-super-mario-walk"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-super-mario-walk-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Zweiter Frame
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-super-mario-walk" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-images-super-mario-walk-3" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="super-mario-walk">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-super-mario-walk-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_super_mario_walk_3.png" class="lightbox" data-gallery="super-mario-walk" title="Abbildung&nbsp;4.23&nbsp;(c): Dritter Frame"><img src="https://winf-hsos.github.io/university-docs/images/images_super_mario_walk_3.png" class="img-fluid figure-img" data-ref-parent="fig-images-super-mario-walk"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-super-mario-walk-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(c) Dritter Frame
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-super-mario-walk-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.23: Drei Bilder – oder Frames – um Mario zum Laufen zu bringen.
</figcaption>
</figure>
</div>
<p>Ein Sprite ist ein kleines Bild, das in Videospielen Figuren oder Objekte darstellt. In der Regel sind Sprites Teil einer größeren Grafikdatei, des sogenannten Sprite-Sheets. Jedes Bild im Sprite-Sheet repräsentiert eine bestimmte Pose oder Aktion. Indem das Spiel schnell zwischen diesen Bildern wechselt, entsteht der Eindruck von Bewegung.</p>
<p>Das fertige Ergebnis einer Mario-Animation seht ihr in <a href="#fig-images-super-mario-animation" class="quarto-xref">Abbildung&nbsp;<span>4.24</span></a>. Es handelt sich um ein GIF (Graphics Interchange Format). Ein GIF ist ein Bildformat, das mehrere Einzelbilder in einer Datei speichern kann. Jedes Einzelbild wird als Frame bezeichnet, und die Frames werden in schneller Abfolge abgespielt.</p>
<div id="fig-images-super-mario-animation" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-super-mario-animation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/super_mario_walking_animation.gif" class="lightbox" data-gallery="quarto-lightbox-gallery-30" title="Abbildung&nbsp;4.24: Die Einzelbilder hintereinander ergeben eine Animation"><img src="images/super_mario_walking_animation.gif" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-super-mario-animation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.24: Die Einzelbilder hintereinander ergeben eine Animation
</figcaption>
</figure>
</div>
<p>Wir können dasselbe Prinzip nutzen, um eine Animation auf unser OLED-Display zu bringen: Wir zeigen mehrere Bitmaps nacheinander an und legen dazwischen kurze Pausen ein. Unser Display hat allerdings eine Einschränkung: Es kann nur Schwarzweiß. Also müssen wir unsere farbigen Sprites zunächst in Graustufen und dann in Schwarzweiß umwandeln.</p>
</details>
</section>
<section id="sec-images-transformations" class="level2 collapsable" data-number="4.9">
<h2 class="collapsable anchored" data-number="4.9" data-anchor-id="sec-images-transformations"><span class="header-section-number">4.9</span> Transformationen</h2>
<details class="collapsable-section" open=""><summary></summary>
<p>Der große Vorteil digitaler Bilder ist, dass wir sie mit einfacher Arithmetik fast beliebig bearbeiten können. Viele Fotofilter (z.B. in Instagram oder Snapchat) basieren auf relativ einfachen Berechnungen pro Pixel.</p>
<p>Für unsere Zwecke, ein Bild von Farbe zu Schwarzweiß zu transformieren, brauchen wir zwei Schritte:</p>
<ol type="1">
<li>Wir transformieren jedes Pixel eines Farbbilds in einen Grauwert (Graustufenbild).</li>
<li>Wir wandeln die Graustufen in Schwarzweiß um, indem wir einen Schwellenwert festlegen.</li>
</ol>
<p>Wir demonstrieren das wieder an Super Mario.</p>
<section id="graustufen" class="level3" data-number="4.9.1">
<h3 data-number="4.9.1" class="anchored" data-anchor-id="graustufen"><span class="header-section-number">4.9.1</span> Graustufen</h3>
<p>In <a href="#fig-images-grayscale-transformation" class="quarto-xref">Abbildung&nbsp;<span>4.25</span></a> seht ihr ein Farbbild und die entsprechende Graustufenversion.</p>
<div id="fig-images-grayscale-transformation" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-grayscale-transformation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_grayscale_transformation.png" class="lightbox" data-gallery="quarto-lightbox-gallery-31" title="Abbildung&nbsp;4.25: Ein Drohnenbild in Farbe und in Graustufen."><img src="https://winf-hsos.github.io/university-docs/images/images_grayscale_transformation.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-grayscale-transformation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.25: Ein Drohnenbild in Farbe und in Graustufen.
</figcaption>
</figure>
</div>
<p>Um ein Farbbild in ein Graustufenbild zu verwandeln, müssen wir für jedes Pixel einen Helligkeitswert (Luminanz) berechnen. Eine einfache Möglichkeit wäre der Durchschnitt der drei Farbkanäle:</p>
<p><span class="math display">\[ \text{luminance} = \frac{R + G + B}{3} \]</span></p>
<p>Besser an die menschliche Wahrnehmung angepasst ist jedoch eine gewichtete Summe, denn unser Auge reagiert empfindlicher auf Grün und Rot als auf Blau:</p>
<p><span class="math display">\[ \text{luminance} = 0.299 \cdot R + 0.587 \cdot G + 0.114 \cdot B \]</span></p>
<p>Wir wollen Mario möglichst menschenähnlich erscheinen lassen und verwenden deshalb diese gewichtete Summe.</p>
<p>In Python sieht die Luminanzberechnung so aus:</p>
<div id="00093ba7" class="cell" data-execution_count="33">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>luminance <span class="op">=</span> <span class="fl">0.299</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.587</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.114</span> <span class="op">*</span> b</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>luminance <span class="op">=</span> <span class="bu">round</span>(luminance)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p><code>round()</code> wandelt den berechneten Wert in eine Ganzzahl um, denn die RGB-Werte müssen schließlich Ganzzahlen sein.</p>
<p>Zuerst laden wir das Farbbild von Mario mit <code>Pillow</code>:</p>
<div id="3f2e0770" class="cell" data-execution_count="34">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-45"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-45-1"><a href="#annotated-cell-45-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-45" data-target-annotation="1">1</button><span id="annotated-cell-45-2" class="code-annotation-target"><a href="#annotated-cell-45-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">"super_mario_color.bmp"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-45" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-45" data-code-lines="2" data-code-annotation="1">Mit <code>Image.open()</code> laden wir die Bitmap-Datei und erhalten ein Bildobjekt.</span>
</dd>
</dl>
</div>
</div>
<p>Sobald wir ein Bild geladen haben, können wir über <code>image.getpixel()</code> den Farbwert eines bestimmten Pixels auslesen. Testen wir das Pixel in der linken oberen Ecke (0, 0):</p>
<div id="f24066f0" class="cell" data-execution_count="35">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>pixel <span class="op">=</span> image.getpixel((<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pixel)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Die Ausgabe lautet:</p>
<pre><code>(255, 255, 255)</code></pre>
<p>Wir erhalten also ein Tupel mit den RGB-Werten. Extrahieren wir sie und berechnen die Luminanz:</p>
<div id="08f8739b" class="cell" data-execution_count="36">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>pixel <span class="op">=</span> image.getpixel((<span class="dv">0</span>, <span class="dv">0</span>))</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> pixel[<span class="dv">0</span>]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> pixel[<span class="dv">1</span>]</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> pixel[<span class="dv">2</span>]</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>luminance <span class="op">=</span> <span class="fl">0.299</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.587</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.114</span> <span class="op">*</span> b</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>luminance <span class="op">=</span> <span class="bu">round</span>(luminance)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"R: </span><span class="sc">{</span>r<span class="sc">}</span><span class="ss">, G: </span><span class="sc">{</span>g<span class="sc">}</span><span class="ss">, B: </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">, Luminance: </span><span class="sc">{</span>luminance<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Für das sechste Pixel in der ersten Reihe (x = 5, y = 0) erwarten wir einen rötlichen Wert (Marios Mütze):</p>
<div id="1ea5eac8" class="cell" data-execution_count="37">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>pixel <span class="op">=</span> image.getpixel((<span class="dv">5</span>, <span class="dv">0</span>))</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> pixel[<span class="dv">0</span>]</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> pixel[<span class="dv">1</span>]</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> pixel[<span class="dv">2</span>]</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>luminance <span class="op">=</span> <span class="fl">0.299</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.587</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.114</span> <span class="op">*</span> b</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>luminance <span class="op">=</span> <span class="bu">round</span>(luminance)</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"R: </span><span class="sc">{</span>r<span class="sc">}</span><span class="ss">, G: </span><span class="sc">{</span>g<span class="sc">}</span><span class="ss">, B: </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss">, Luminance: </span><span class="sc">{</span>luminance<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Die Ausgabe sieht z.B. so aus:</p>
<pre><code>R: 181, G: 49, B: 32, Luminance: 87</code></pre>
<p>Damit wir die Umrechnung nicht für jedes Pixel neu schreiben müssen, kapseln wir sie in einer Funktion:</p>
<div id="687fb327" class="cell" data-execution_count="38">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-51"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-51" data-target-annotation="1">1</button><span id="annotated-cell-51-1" class="code-annotation-target"><a href="#annotated-cell-51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rgb_to_luminance(rgb_tuple):</span>
<span id="annotated-cell-51-2"><a href="#annotated-cell-51-2" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> rgb_tuple[<span class="dv">0</span>]</span>
<span id="annotated-cell-51-3"><a href="#annotated-cell-51-3" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> rgb_tuple[<span class="dv">1</span>]</span>
<span id="annotated-cell-51-4"><a href="#annotated-cell-51-4" aria-hidden="true" tabindex="-1"></a>    b <span class="op">=</span> rgb_tuple[<span class="dv">2</span>]</span>
<span id="annotated-cell-51-5"><a href="#annotated-cell-51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-51-6"><a href="#annotated-cell-51-6" aria-hidden="true" tabindex="-1"></a>    luminance <span class="op">=</span> <span class="fl">0.299</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.587</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.114</span> <span class="op">*</span> b</span>
<span id="annotated-cell-51-7"><a href="#annotated-cell-51-7" aria-hidden="true" tabindex="-1"></a>    luminance <span class="op">=</span> <span class="bu">round</span>(luminance)</span>
<span id="annotated-cell-51-8"><a href="#annotated-cell-51-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> luminance</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-51" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-51" data-code-lines="1" data-code-annotation="1">Die Funktion <code>rgb_to_luminance</code> erwartet ein Tupel <code>(R, G, B)</code> und gibt die Luminanz als Ganzzahl zurück.</span>
</dd>
</dl>
</div>
</div>
<p>Jetzt können wir für beliebige Pixel einfach:</p>
<div id="f42125e2" class="cell" data-execution_count="39">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb43"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1"></a>pixel <span class="op">=</span> image.getpixel((<span class="dv">4</span>, <span class="dv">0</span>))</span>
<span id="cb43-2"><a href="#cb43-2"></a>luminance <span class="op">=</span> rgb_to_luminance(pixel)</span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="bu">print</span>(<span class="ss">f"Luminance of pixel (4,0): </span><span class="sc">{</span>luminance<span class="sc">}</span><span class="ss">"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section>
<section id="bitmap-in-graustufen-umwandeln" class="level3" data-number="4.9.2">
<h3 data-number="4.9.2" class="anchored" data-anchor-id="bitmap-in-graustufen-umwandeln"><span class="header-section-number">4.9.2</span> Bitmap in Graustufen umwandeln</h3>
<p>Jetzt müssen wir nur noch die neue Funktion auf alle Pixel anwenden und das Ergebnis speichern. Dazu können wir erneut zwei Schleifen einsetzen, die eine für jede Zeile, die andere für jedes Pixel in einer Zeile. Dafür benötigen wir die Breite und Höhe des Bildes, die wir beide auf einen Schlag mit <code>image.size</code> auslesen können:</p>
<div id="0c4f02bc" class="cell" data-execution_count="40">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>w, h <span class="op">=</span> image.size</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Nun iterieren wir mit zwei verschachtelten <code>for</code>-Schleifen über alle Pixelkoordinaten und sammeln die Luminanzwerte in einer Liste:</p>
<div id="20531e60" class="cell" data-execution_count="41">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>w, h <span class="op">=</span> image.size</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>grayscale_values <span class="op">=</span> []</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(h):</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(w):</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        r, g, b <span class="op">=</span> image.getpixel((x, y))</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        luminance <span class="op">=</span> rgb_to_luminance((r, g, b))</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>        grayscale_values.append(luminance)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>(Vertipper in der Variablenname sind in eurem Code bitte zu vermeiden – hier nennen wir sie besser <code>grayscale_values</code>.)</p>
<p>Mit den gesammelten Graustufenwerten erzeugen wir ein neues Bild:</p>
<div id="6e6ac02f" class="cell" data-execution_count="42">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>grayscale_image <span class="op">=</span> Image.new(<span class="st">"L"</span>, (w, h))  <span class="co"># Modus "L" für Graustufen</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>grayscale_image.putdata(grayscale_values)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>grayscale_image.save(<span class="st">"super_mario_grayscale.bmp"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Das Ergebnis seht ihr in <a href="#fig-images-super-mario-grayscale" class="quarto-xref">Abbildung&nbsp;<span>4.26</span></a>.</p>
<div id="fig-images-super-mario-grayscale" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-super-mario-grayscale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_super_mario_grayscale.png" class="lightbox" data-gallery="quarto-lightbox-gallery-32" title="Abbildung&nbsp;4.26: Mario als Graustufenbild, das unser Programm erzeugt hat."><img src="https://winf-hsos.github.io/university-docs/images/images_super_mario_grayscale.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-super-mario-grayscale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.26: Mario als Graustufenbild, das unser Programm erzeugt hat.
</figcaption>
</figure>
</div>
<p>Der vollständige Code zur Umwandlung von Farbe in Graustufen sieht so aus:</p>
<div id="79546c44" class="cell" data-execution_count="43">
<div id="lst-images-color-to-grayscale" class="python cell-code listing quarto-float quarto-figure quarto-figure-left anchored" data-code-fold="show">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-images-color-to-grayscale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;4.1: Der vollständige Code zur Umwandlung von Farbe in Graustufen.
</figcaption>
<div aria-describedby="lst-images-color-to-grayscale-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb47"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb47-2"><a href="#cb47-2"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">"xlsx/super_mario_color.bmp"</span>)</span>
<span id="cb47-3"><a href="#cb47-3"></a></span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="kw">def</span> rgb_to_luminance(rgb_tuple):</span>
<span id="cb47-5"><a href="#cb47-5"></a>    r <span class="op">=</span> rgb_tuple[<span class="dv">0</span>]</span>
<span id="cb47-6"><a href="#cb47-6"></a>    g <span class="op">=</span> rgb_tuple[<span class="dv">1</span>]</span>
<span id="cb47-7"><a href="#cb47-7"></a>    b <span class="op">=</span> rgb_tuple[<span class="dv">2</span>]</span>
<span id="cb47-8"><a href="#cb47-8"></a></span>
<span id="cb47-9"><a href="#cb47-9"></a>    luminance <span class="op">=</span> <span class="fl">0.299</span> <span class="op">*</span> r <span class="op">+</span> <span class="fl">0.587</span> <span class="op">*</span> g <span class="op">+</span> <span class="fl">0.114</span> <span class="op">*</span> b</span>
<span id="cb47-10"><a href="#cb47-10"></a>    luminance <span class="op">=</span> <span class="bu">round</span>(luminance)</span>
<span id="cb47-11"><a href="#cb47-11"></a>    <span class="cf">return</span> luminance</span>
<span id="cb47-12"><a href="#cb47-12"></a></span>
<span id="cb47-13"><a href="#cb47-13"></a>w, h <span class="op">=</span> image.size</span>
<span id="cb47-14"><a href="#cb47-14"></a>grayscale_values <span class="op">=</span> []</span>
<span id="cb47-15"><a href="#cb47-15"></a><span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(h):</span>
<span id="cb47-16"><a href="#cb47-16"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(w):</span>
<span id="cb47-17"><a href="#cb47-17"></a>        r, g, b <span class="op">=</span> image.getpixel((x, y))</span>
<span id="cb47-18"><a href="#cb47-18"></a>        luminance <span class="op">=</span> rgb_to_luminance((r, g, b))</span>
<span id="cb47-19"><a href="#cb47-19"></a>        grayscale_values.append(luminance)</span>
<span id="cb47-20"><a href="#cb47-20"></a></span>
<span id="cb47-21"><a href="#cb47-21"></a><span class="bu">print</span>(<span class="ss">f"Grayscale bitmap with </span><span class="sc">{</span><span class="bu">len</span>(grayscale_values)<span class="sc">}</span><span class="ss"> pixel values: </span><span class="sc">{</span>grayscale_values<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb47-22"><a href="#cb47-22"></a></span>
<span id="cb47-23"><a href="#cb47-23"></a>grayscale_image <span class="op">=</span> Image.new(<span class="st">"L"</span>, (w, h))</span>
<span id="cb47-24"><a href="#cb47-24"></a>grayscale_image.putdata(grayscale_values)</span>
<span id="cb47-25"><a href="#cb47-25"></a>grayscale_image.save(<span class="st">"xlsx/super_mario_grayscale.bmp"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</figure>
</div>
</div>
</section>
<section id="schwarzweiß" class="level3" data-number="4.9.3">
<h3 data-number="4.9.3" class="anchored" data-anchor-id="schwarzweiß"><span class="header-section-number">4.9.3</span> Schwarzweiß</h3>
<p>Unser Display kann nur zwei Zustände: Pixel an oder aus. Aus dem Graustufenbild müssen wir also im letzten Schritt ein reines Schwarzweißbild erzeugen. Aber wie?</p>
<p>Die Frage ist: Welche Pixel aus dem Graustufenbild sollen im Schwarzweißbild schwarz oder weiß sein? Dazu wäre es sinnvoll, dass wir uns einen Schwellenwert setzen, der die Grenze zwischen schwarz und weiß definiert. Alle dunkleren Graustufenwerte unterhalb des Schwellenwerts werden zu schwarz (0), alle darüber oder gleich dazu zu weiß (1). Wir implementieren das direkt als Funktion:</p>
<div id="5104c427" class="cell" data-execution_count="44">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-57"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-57" data-target-annotation="1">1</button><span id="annotated-cell-57-1" class="code-annotation-target"><a href="#annotated-cell-57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> luminance_to_bw(luminance, threshold<span class="op">=</span><span class="dv">128</span>):</span>
<span id="annotated-cell-57-2"><a href="#annotated-cell-57-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> luminance <span class="op">&lt;</span> threshold:</span>
<span id="annotated-cell-57-3"><a href="#annotated-cell-57-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="annotated-cell-57-4"><a href="#annotated-cell-57-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="annotated-cell-57-5"><a href="#annotated-cell-57-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-57" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-57" data-code-lines="1" data-code-annotation="1">Die Funktion erwartet einen Luminanzwert und einen optionalen Schwellenwert (Standard: 128) und liefert 0 (schwarz) oder 1 (weiß).</span>
</dd>
</dl>
</div>
</div>
<p>Wie zuvor mit der Graustufenumwandulung können wir die neue Funktion auf jedes Pixel anwenden. Und zwar in der inneren Schleife, damit wir die neue Funktion auf alle Pixel des Graustufenbildes anwenden können:</p>
<div id="1f8ae96f" class="cell" data-execution_count="45">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb48"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb48-2"><a href="#cb48-2"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">"xlsx/super_mario_grayscale.bmp"</span>)</span>
<span id="cb48-3"><a href="#cb48-3"></a></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="kw">def</span> luminance_to_bw(luminance, threshold<span class="op">=</span><span class="dv">128</span>):</span>
<span id="cb48-5"><a href="#cb48-5"></a>    <span class="cf">if</span> luminance <span class="op">&lt;</span> threshold:</span>
<span id="cb48-6"><a href="#cb48-6"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>    <span class="cf">else</span>:</span>
<span id="cb48-8"><a href="#cb48-8"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb48-9"><a href="#cb48-9"></a></span>
<span id="cb48-10"><a href="#cb48-10"></a>w, h <span class="op">=</span> image.size</span>
<span id="cb48-11"><a href="#cb48-11"></a>bw_values <span class="op">=</span> []</span>
<span id="cb48-12"><a href="#cb48-12"></a><span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(h):</span>
<span id="cb48-13"><a href="#cb48-13"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(w):</span>
<span id="cb48-14"><a href="#cb48-14"></a>        grayscale_value <span class="op">=</span> image.getpixel((x, y))</span>
<span id="cb48-15"><a href="#cb48-15"></a>        bw <span class="op">=</span> luminance_to_bw(grayscale_value, <span class="dv">128</span>)</span>
<span id="cb48-16"><a href="#cb48-16"></a>        bw_values.append(bw)</span>
<span id="cb48-17"><a href="#cb48-17"></a></span>
<span id="cb48-18"><a href="#cb48-18"></a><span class="bu">print</span>(<span class="ss">f"Black and white bitmap with </span><span class="sc">{</span><span class="bu">len</span>(bw_values)<span class="sc">}</span><span class="ss"> pixel values: </span><span class="sc">{</span>bw_values<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb48-19"><a href="#cb48-19"></a></span>
<span id="cb48-20"><a href="#cb48-20"></a>bw_image <span class="op">=</span> Image.new(<span class="st">"1"</span>, (w, h))</span>
<span id="cb48-21"><a href="#cb48-21"></a>bw_image.putdata(bw_values)</span>
<span id="cb48-22"><a href="#cb48-22"></a>bw_image.save(<span class="st">"xlsx/super_mario_bw.bmp"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
<p>Das Ergebnis seht ihr in <a href="#fig-images-super-mario-bw" class="quarto-xref">Abbildung&nbsp;<span>4.27</span></a>. Wie ihr sicher erkennt, verlieren wir auf dem Weg von Links nach Rehcts eine Menge Informationen.</p>
<div id="fig-images-super-mario-bw" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-super-mario-bw-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_super_mario_bw.png" class="lightbox" data-gallery="quarto-lightbox-gallery-33" title="Abbildung&nbsp;4.27: Mario in Schwarzweiß, was offensichtlich ein großer Informationsverlust ist."><img src="https://winf-hsos.github.io/university-docs/images/images_super_mario_bw.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-super-mario-bw-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.27: Mario in Schwarzweiß, was offensichtlich ein großer Informationsverlust ist.
</figcaption>
</figure>
</div>
</section>
<section id="informationsverlust" class="level3" data-number="4.9.4">
<h3 data-number="4.9.4" class="anchored" data-anchor-id="informationsverlust"><span class="header-section-number">4.9.4</span> Informationsverlust</h3>
<p>Was fällt an der Kaskade von Farbe über Graustufen zu Schwarzweiß auf? Es geht eine Menge Information verloren.</p>
<ul>
<li>In Farbe haben wir 256 Farbstufen pro Kanal, also über 16 Millionen mögliche Farben.</li>
<li>In Graustufen haben wir 256 Helligkeitswerte.</li>
<li>In Schwarzweiß bleiben nur noch 2 Zustände.</li>
</ul>
<p>Mario ist am Ende zwar noch erkennbar, aber viele Details sind verloren gegangen. Besonders die seine Haut ist jetzt weiß und setzt sich nicht mehr vom Hintergrund ab. Wir könnten mit dem Schwellenwert experimentieren, aber mit nur zwei Farben bleibt die Darstellungsqualität stark begrenzt.</p>
<p>Eine wichtige Erkenntnis: Die Anzahl an Informationen im Bild (Farbtiefe und Auflösung) bestimmt maßgeblich die Qualität. Mehr Farben und mehr Pixel bedeuten ein detailreicheres Bild, aber auch größere Dateien. Dieser Trade-off zwischen Qualität und Größe begleitet uns überall in der Informatik.</p>
<p>Für Mario, der in seinem echten Klempnerdasein farbig ist, funktioniert die schwarzweiße Welt nicht gut. Wir nutzen deshalb für die Animation auf unserem Display eine Figur, die sowieso in Unifarbe daher kommt. Wenn ihr aber trotzdem mal ausprobieren wollt, wie Mario in Schwarzweiß auf dem Laufsteg aussieht, könnt ihr das gerne ausprobieren. Ihr findet die drei Bilder in dem zu diesem Buch gehörigen <a href="https://github.com/winf-hsos/hands-on-computer-science-code/tree/main/chapter_04/xlsx">GitHub-Repository</a>.</p>
<p>Für eine Animation auf unserem kleinen Display suchen wir uns eine Figur, die auch in Schwarzweiß gut funktioniert: Pacman.</p>
</section></details>
</section>

<section id="sec-images-pacman" class="level2 collapsable" data-number="4.10">
<h2 class="collapsable anchored" data-number="4.10" data-anchor-id="sec-images-pacman"><span class="header-section-number">4.10</span> Pacman</h2>
<details class="collapsable-section" open=""><summary></summary>
<section id="von-farbe-zu-schwarzweiß" class="level3" data-number="4.10.1">
<h3 data-number="4.10.1" class="anchored" data-anchor-id="von-farbe-zu-schwarzweiß"><span class="header-section-number">4.10.1</span> Von Farbe zu Schwarzweiß</h3>
<p>Am Beispiel von Mario haben wir bereits eine Verarbeitungslogik von Farbe zu Schwarzweiß kennengelernt. Für Pacman können wir uns das Leben noch weiter vereinfachen.</p>
<p>Pacman ist ein weiterer Spieleklassiker aus den 1980er Jahren, mit dem ich meine ganz eigene Geschichte habe: Mein erstes größeres Programmierprojekt war die Entwicklung eines Pacman-Spiels in Turbo Pascal. Das ist 1998 während meines Ausslandsaufenthaltes in North Carolina in der elften Schulklasse entstanden. Für das Projekt habe ich Pacman Pixel für Pixel gezeichnet und animiert.</p>
<p>Das Spiel ist schnell erklärt. Pacman ist eine kreisförmige, gelbe Figur, die der Spieler durch ein Labyrinth steuert und dabei möglichst viele Punkte frisst. Währendessen wird Pacman von Geistern gejagt. Einen Eindruck vom Originalspiel seht ihr in <a href="#fig-images-pacman-screenshot" class="quarto-xref">Abbildung&nbsp;<span>4.28</span></a>.</p>
<div id="fig-images-pacman-screenshot" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-pacman-screenshot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_pacman_screenshot.png" class="lightbox" data-gallery="quarto-lightbox-gallery-34" title="Abbildung&nbsp;4.28: So sah Pacman früher als Arcade-Game aus."><img src="https://winf-hsos.github.io/university-docs/images/images_pacman_screenshot.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-pacman-screenshot-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.28: So sah Pacman früher als Arcade-Game aus.
</figcaption>
</figure>
</div>
<p>Wenn Pacman läuft, öffnet und schließt sich sein Mund im Wechsel. In <a href="#fig-images-pacman-animation" class="quarto-xref">Abbildung&nbsp;<span>4.29</span></a> seht ihr diese Mundbewegung in drei Bildern. Diese drei Sprites wollen wir im Folgenden auf unser Display übertragen.</p>
<div id="fig-images-pacman-animation" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-pacman-animation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/images_pacman_animation.png" class="lightbox" data-gallery="quarto-lightbox-gallery-35" title="Abbildung&nbsp;4.29: Pacman öffnet den Mund in 3 Bildern"><img src="https://winf-hsos.github.io/university-docs/images/images_pacman_animation.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-pacman-animation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.29: Pacman öffnet den Mund in 3 Bildern
</figcaption>
</figure>
</div>
<p>Pacman von Farbe zu Schwarzweiß umzuwandeln ist denkbar einfach: Es gibt im Wesentlichen nur eine relevante Farbe (Gelb). Wir entscheiden also: Alle gelben Pixel werden weiß (1), alle anderen schwarz (0). Praktisch prüfen wir einfach, ob ein Pixel <em>nicht</em> weiß ist.</p>
<p>Wir laden zunächst das Bitmap-Bild von Pacman mit geschlossenem Mund und iterieren dann über alle Pixel, um die Schwarzweiß-Werte zu erzeugen:</p>
<div id="c1241d92" class="cell" data-execution_count="46">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="annotated-cell-59"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-59-1"><a href="#annotated-cell-59-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-59" data-target-annotation="1">1</button><span id="annotated-cell-59-2" class="code-annotation-target"><a href="#annotated-cell-59-2" aria-hidden="true" tabindex="-1"></a>image <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">"bmp/pacman_closed.bmp"</span>)</span>
<span id="annotated-cell-59-3"><a href="#annotated-cell-59-3" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-59" data-target-annotation="2">2</button><span id="annotated-cell-59-4" class="code-annotation-target"><a href="#annotated-cell-59-4" aria-hidden="true" tabindex="-1"></a>w, h <span class="op">=</span> image.size</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-59" data-target-annotation="3">3</button><span id="annotated-cell-59-5" class="code-annotation-target"><a href="#annotated-cell-59-5" aria-hidden="true" tabindex="-1"></a>pacman_closed <span class="op">=</span> []</span>
<span id="annotated-cell-59-6"><a href="#annotated-cell-59-6" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-59" data-target-annotation="4">4</button><span id="annotated-cell-59-7" class="code-annotation-target"><a href="#annotated-cell-59-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(h):</span>
<span id="annotated-cell-59-8"><a href="#annotated-cell-59-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(w):</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-59" data-target-annotation="5">5</button><span id="annotated-cell-59-9" class="code-annotation-target"><a href="#annotated-cell-59-9" aria-hidden="true" tabindex="-1"></a>        r, g, b <span class="op">=</span> image.getpixel((x, y))</span>
<span id="annotated-cell-59-10"><a href="#annotated-cell-59-10" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-59" data-target-annotation="6">6</button><span id="annotated-cell-59-11" class="code-annotation-target"><a href="#annotated-cell-59-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r <span class="op">==</span> <span class="dv">255</span> <span class="kw">and</span> g <span class="op">==</span> <span class="dv">255</span> <span class="kw">and</span> b <span class="op">==</span> <span class="dv">255</span>:</span>
<span id="annotated-cell-59-12"><a href="#annotated-cell-59-12" aria-hidden="true" tabindex="-1"></a>            pacman_closed.append(<span class="dv">0</span>)</span>
<span id="annotated-cell-59-13"><a href="#annotated-cell-59-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="annotated-cell-59-14"><a href="#annotated-cell-59-14" aria-hidden="true" tabindex="-1"></a>            pacman_closed.append(<span class="dv">1</span>)</span>
<span id="annotated-cell-59-15"><a href="#annotated-cell-59-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-59-16"><a href="#annotated-cell-59-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pacman_closed)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-59" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-59" data-code-lines="2" data-code-annotation="1">Wir laden die Bitmap-Datei von Pacman mit geschlossenem Mund.</span>
</dd>
<dt data-target-cell="annotated-cell-59" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-59" data-code-lines="4" data-code-annotation="2">Wir lesen Breite und Höhe aus.</span>
</dd>
<dt data-target-cell="annotated-cell-59" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-59" data-code-lines="5" data-code-annotation="3">Wir erstellen eine Liste für die Schwarzweiß-Werte.</span>
</dd>
<dt data-target-cell="annotated-cell-59" data-target-annotation="4">4</dt>
<dd>
<span data-code-cell="annotated-cell-59" data-code-lines="7" data-code-annotation="4">Zwei verschachtelte Schleifen iterieren über alle Pixelkoordinaten.</span>
</dd>
<dt data-target-cell="annotated-cell-59" data-target-annotation="5">5</dt>
<dd>
<span data-code-cell="annotated-cell-59" data-code-lines="9" data-code-annotation="5">Wir lesen den RGB-Wert des aktuellen Pixels.</span>
</dd>
<dt data-target-cell="annotated-cell-59" data-target-annotation="6">6</dt>
<dd>
<span data-code-cell="annotated-cell-59" data-code-lines="11" data-code-annotation="6">Ist das Pixel weiß, fügen wir eine 0 hinzu, sonst eine 1.</span>
</dd>
</dl>
</div>
</div>
<p>Die Logik in der Schleife ist einfach: Wenn alle Farbkomponenten den Wert 255 haben, dann ist das Pixel weiß und gehört somit nicht zu Pacman. Wir notieren also eine 0. Ansonsten ist das Pixel Teil von Pacman, und wir notieren eine 1.</p>
<p>Die Ausgabe in der letzten Zeile ist eine Liste, die etwa so aussieht:</p>
<pre><code>[0, 0, 0, 0, 1, 1, 1, 1, ... 1, 1, 1, 1, 0, 0, 0, 0]</code></pre>
<p>Genau dieses Format benötigen wir, um das Bild auf dem Display darzustellen. Perfekt!</p>
<p>Jetzt ergänzen wir wieder unseren Tinkerforge-Boilerplate und zeigen Pacman an:</p>
<div id="e6d4b1a8" class="cell" data-execution_count="47">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tinkerforge.ip_connection <span class="im">import</span> IPConnection</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tinkerforge.bricklet_oled_128x64_v2 <span class="im">import</span> BrickletOLED128x64V2</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>ipcon <span class="op">=</span> IPConnection()</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>ipcon.<span class="ex">connect</span>(<span class="st">'localhost'</span>, <span class="dv">4223</span>)</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>oled <span class="op">=</span> BrickletOLED128x64V2(<span class="st">'25zo'</span>, ipcon)</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>oled.clear_display()</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Code zum Laden und Umwandeln des Bildes in Schwarzweiß (siehe oben)</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>...</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_closed)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Wir setzen Pacmans obere linke Ecke auf (10, 10). Pacman ist 12×13 Pixel groß, der untere rechte Eckpunkt ist also (21, 22). Wenn ihr das Programm ausführt, sollte Pacman mit geschlossenem Mund auf dem Display erscheinen (siehe <a href="#fig-images-pacman-closed-display" class="quarto-xref">Abbildung&nbsp;<span>4.30 (a)</span></a>).</p>
</section>
<section id="pacman-animation" class="level3" data-number="4.10.2">
<h3 data-number="4.10.2" class="anchored" data-anchor-id="pacman-animation"><span class="header-section-number">4.10.2</span> Pacman-Animation</h3>
<p>Dasselbe Vorgehen können wir für die beiden anderen Bilder (halb geöffneter und geöffneter Mund) wiederholen. Anstatt den Code zu kopieren, kapseln wir die Umwandlung in eine Funktion:</p>
<div id="1f3a4105" class="cell" data-execution_count="48">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> convert_rgb_to_bw(image_path):</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    image <span class="op">=</span> Image.<span class="bu">open</span>(image_path)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    w, h <span class="op">=</span> image.size</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>    bw_values <span class="op">=</span> []</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(h):</span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(w):</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>            r, g, b <span class="op">=</span> image.getpixel((x, y))</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> r <span class="op">==</span> <span class="dv">255</span> <span class="kw">and</span> g <span class="op">==</span> <span class="dv">255</span> <span class="kw">and</span> b <span class="op">==</span> <span class="dv">255</span>:</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>                bw_values.append(<span class="dv">0</span>)</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>                bw_values.append(<span class="dv">1</span>)</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> bw_values</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Die Funktion <code>convert_rgb_to_bw</code> nimmt den Pfad eines Bildes entgegen, lädt es, wandelt alle Pixel in 0 oder 1 um und gibt die resultierende Liste zurück.</p>
<p>Wir rufen sie für alle drei Pacman-Bilder auf:</p>
<div id="790f31a7" class="cell" data-execution_count="49">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>pacman_half <span class="op">=</span> convert_rgb_to_bw(<span class="st">"bmp/pacman_half.bmp"</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>pacman_closed <span class="op">=</span> convert_rgb_to_bw(<span class="st">"bmp/pacman_closed.bmp"</span>)</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>pacman_open <span class="op">=</span> convert_rgb_to_bw(<span class="st">"bmp/pacman_open.bmp"</span>)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Jetzt können wir die drei Bitmaps mit <code>write_pixels()</code> nacheinander anzeigen. Dazwischen legen wir kurze Pausen ein, damit unser Auge die Bilder wahrnehmen kann. Das Ganze läuft in einer Endlosschleife:</p>
<div id="c73358f4" class="cell" data-execution_count="50">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>wait_time <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_closed)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    time.sleep(wait_time)</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_half)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    time.sleep(wait_time)</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_open)</span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>    time.sleep(wait_time <span class="op">*</span> <span class="dv">2</span>)</span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_half)</span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>    time.sleep(wait_time)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</div>
<p>Über die Variable <code>wait_time</code> könnt ihr die Geschwindigkeit der Animation steuern. In der letzten Phase (<code>pacman_open</code>) verdoppeln wir die Wartezeit, damit Pacman mit offenem Mund etwas länger sichtbar ist.</p>
<div id="fig-images-pacman-display" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-pacman-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-pacman-display" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-images-pacman-closed-display" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="pacman-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-pacman-closed-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/pacman_closed_display.jpg" class="lightbox" data-gallery="pacman-display" title="Abbildung&nbsp;4.30&nbsp;(a): Erster Frame"><img src="images/pacman_closed_display.jpg" class="img-fluid figure-img" data-ref-parent="fig-images-pacman-display"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-pacman-closed-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Erster Frame
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-pacman-display" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-images-pacman-half-display" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="pacman-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-pacman-half-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/pacman_half_display.jpg" class="lightbox" data-gallery="pacman-display" title="Abbildung&nbsp;4.30&nbsp;(b): Zweiter Frame"><img src="images/pacman_half_display.jpg" class="img-fluid figure-img" data-ref-parent="fig-images-pacman-display"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-pacman-half-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Zweiter Frame
</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-images-pacman-display" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-images-pacman-open-display" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-group="pacman-display">
<figure class="quarto-float quarto-subfloat-fig figure">
<div aria-describedby="fig-images-pacman-open-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/pacman_open_display.jpg" class="lightbox" data-gallery="pacman-display" title="Abbildung&nbsp;4.30&nbsp;(c): Dritter Frame"><img src="images/pacman_open_display.jpg" class="img-fluid figure-img" data-ref-parent="fig-images-pacman-display"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-subfloat-caption quarto-subfloat-fig" id="fig-images-pacman-open-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(c) Dritter Frame
</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-pacman-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.30: Die drei Pacman-Frames auf dem OLED-Display.
</figcaption>
</figure>
</div>
<p>So sieht das Ganze als bewegtes Bild auf dem Display aus (siehe <a href="#fig-images-pacman-animation-display" class="quarto-xref">Abbildung&nbsp;<span>4.31</span></a>):</p>
<div id="fig-images-pacman-animation-display" class="lightbox quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-images-pacman-animation-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/pacman_animation_display.gif" class="lightbox" data-gallery="quarto-lightbox-gallery-39" title="Abbildung&nbsp;4.31: Pacman als Animation auf dem Display."><img src="images/pacman_animation_display.gif" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-images-pacman-animation-display-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;4.31: Pacman als Animation auf dem Display.
</figcaption>
</figure>
</div>
<p>In <a href="#lst-images-pacman-animation" class="quarto-xref">Listing&nbsp;<span>4.2</span></a> findet ihr den vollständigen Code für die Pacman-Animation, den ihr auch im <a href="https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_04/4_10_pacman.py">GitHub-Repository</a> findet:</p>
<div id="765f98bf" class="cell" data-execution_count="51">
<div id="lst-images-pacman-animation" class="python cell-code listing quarto-float quarto-figure quarto-figure-left anchored" data-code-fold="show">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-images-pacman-animation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;4.2: Der vollständige Code für die Pacman-Animation
</figcaption>
<div aria-describedby="lst-images-pacman-animation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<details open="" class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb54"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1"></a><span class="im">from</span> tinkerforge.ip_connection <span class="im">import</span> IPConnection</span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="im">from</span> tinkerforge.bricklet_oled_128x64_v2 <span class="im">import</span> BrickletOLED128x64V2</span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="im">import</span> time</span>
<span id="cb54-4"><a href="#cb54-4"></a><span class="im">from</span> PIL <span class="im">import</span> Image</span>
<span id="cb54-5"><a href="#cb54-5"></a></span>
<span id="cb54-6"><a href="#cb54-6"></a>ipcon <span class="op">=</span> IPConnection()</span>
<span id="cb54-7"><a href="#cb54-7"></a>ipcon.<span class="ex">connect</span>(<span class="st">"localhost"</span>, <span class="dv">4223</span>)</span>
<span id="cb54-8"><a href="#cb54-8"></a>oled <span class="op">=</span> BrickletOLED128x64V2(<span class="st">"&lt;YOUR_UID&gt;"</span>, ipcon)</span>
<span id="cb54-9"><a href="#cb54-9"></a>oled.clear_display()</span>
<span id="cb54-10"><a href="#cb54-10"></a></span>
<span id="cb54-11"><a href="#cb54-11"></a><span class="kw">def</span> convert_rgb_to_bw(image_path):</span>
<span id="cb54-12"><a href="#cb54-12"></a>    image <span class="op">=</span> Image.<span class="bu">open</span>(image_path)</span>
<span id="cb54-13"><a href="#cb54-13"></a>    w, h <span class="op">=</span> image.size</span>
<span id="cb54-14"><a href="#cb54-14"></a></span>
<span id="cb54-15"><a href="#cb54-15"></a>    bw_values <span class="op">=</span> []</span>
<span id="cb54-16"><a href="#cb54-16"></a>    <span class="cf">for</span> y <span class="kw">in</span> <span class="bu">range</span>(h):</span>
<span id="cb54-17"><a href="#cb54-17"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(w):</span>
<span id="cb54-18"><a href="#cb54-18"></a>            r, g, b <span class="op">=</span> image.getpixel((x, y))</span>
<span id="cb54-19"><a href="#cb54-19"></a></span>
<span id="cb54-20"><a href="#cb54-20"></a>            <span class="cf">if</span> r <span class="op">==</span> <span class="dv">255</span> <span class="kw">and</span> g <span class="op">==</span> <span class="dv">255</span> <span class="kw">and</span> b <span class="op">==</span> <span class="dv">255</span>:</span>
<span id="cb54-21"><a href="#cb54-21"></a>                bw_values.append(<span class="dv">0</span>)</span>
<span id="cb54-22"><a href="#cb54-22"></a>            <span class="cf">else</span>:</span>
<span id="cb54-23"><a href="#cb54-23"></a>                bw_values.append(<span class="dv">1</span>)</span>
<span id="cb54-24"><a href="#cb54-24"></a></span>
<span id="cb54-25"><a href="#cb54-25"></a>    <span class="cf">return</span> bw_values</span>
<span id="cb54-26"><a href="#cb54-26"></a></span>
<span id="cb54-27"><a href="#cb54-27"></a>pacman_half <span class="op">=</span> convert_rgb_to_bw(<span class="st">"bmp/pacman_half.bmp"</span>)</span>
<span id="cb54-28"><a href="#cb54-28"></a>pacman_closed <span class="op">=</span> convert_rgb_to_bw(<span class="st">"bmp/pacman_closed.bmp"</span>)</span>
<span id="cb54-29"><a href="#cb54-29"></a>pacman_open <span class="op">=</span> convert_rgb_to_bw(<span class="st">"bmp/pacman_open.bmp"</span>)</span>
<span id="cb54-30"><a href="#cb54-30"></a></span>
<span id="cb54-31"><a href="#cb54-31"></a>wait_time <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb54-32"><a href="#cb54-32"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb54-33"><a href="#cb54-33"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_closed)</span>
<span id="cb54-34"><a href="#cb54-34"></a>    time.sleep(wait_time)</span>
<span id="cb54-35"><a href="#cb54-35"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_half)</span>
<span id="cb54-36"><a href="#cb54-36"></a>    time.sleep(wait_time)</span>
<span id="cb54-37"><a href="#cb54-37"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_open)</span>
<span id="cb54-38"><a href="#cb54-38"></a>    time.sleep(wait_time <span class="op">*</span> <span class="dv">2</span>)</span>
<span id="cb54-39"><a href="#cb54-39"></a>    oled.write_pixels(<span class="dv">10</span>, <span class="dv">10</span>, <span class="dv">21</span>, <span class="dv">22</span>, pacman_half)</span>
<span id="cb54-40"><a href="#cb54-40"></a>    time.sleep(wait_time)</span></code></pre></div><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></div>
</details>
</div>
</figure>
</div>
</div>
<p>Im echten Spiel bewegt Pacman nicht nur seinen Mund, sondern wandert durch das Labyrinth. Dafür müssten wir die Koordinaten des Rechtecks verändern und Pacman Pixel für Pixel über das Display bewegen. Ihr könnt das einmal selbst ausprobieren: Lasst Pacman von Links nach Rechts über den Bildschirm laufen. Wenn er am Ende angekommen ist, beginnt wieder von Vorne.</p>
<p>Für ein echtes Spiel müssten wir zusätzlich weitere Sprites für die Bewegungen in die anderen drei Richtungen erzeugen. Wenn Pacman nach rechts läuft, dann sollte er auch in die entsprechende Richtung blicken. Das selbe gilt für Oben und Unten. Das sparen wir uns an dieser Stelle, denn schließlich wollen wir kein komplettes Spiel entwickeln, sondern etwas über die Grundlagen moderner Computer lernen. Das haben wir hoffentlicht für das Theme Bilder heute geschafft.</p>
<p>Im nächsten Kapitel wenden wir uns wieder einem anderen spannenden Thema zu, das eine große Relevanz im Zusammenhang mit Computern hat: Töne und Klänge.</p>


</section></details>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-adami_what_2016" class="csl-entry" role="listitem">
Adami, Christoph. 2016. <span>„What is <span>Information</span>?“</span> <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em> 374 (2063): 20150230. <a href="https://doi.org/10.1098/rsta.2015.0230">https://doi.org/10.1098/rsta.2015.0230</a>.
</div>
<div id="ref-brookshear_computer_2020" class="csl-entry" role="listitem">
Brookshear, J. Glenn, und Dennis Brylow. 2020. <em>Computer science: an overview</em>. 13th edition, global edition. NY, NY: Pearson.
</div>
<div id="ref-gallenbacher_abenteuer_2020" class="csl-entry" role="listitem">
Gallenbacher, Jens. 2020. <em>Abenteuer <span>Informatik</span>: <span>IT</span> zum <span>Anfassen</span> für alle von 9 bis 99, vom <span>Navi</span> bis <span>Social</span> <span>Media</span></em>. 4. Auflage, korrigierte Publikation. Berlin Heidelberg: Springer.
</div>
<div id="ref-petzold_code_2022" class="csl-entry" role="listitem">
Petzold, Charles. 2022. <em>Code: the hidden language of computer hardware and software</em>. 2. Aufl. Hoboken: Microsoft Press.
</div>
<div id="ref-polya" class="csl-entry" role="listitem">
Pólya, George, und John Horton Conway. 2004. <em>How to solve it: a new aspect of mathematical method</em>. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.
</div>
<div id="ref-scott_but_2009" class="csl-entry" role="listitem">
Scott, John C. 2009. <em>But how do it know?: the basic principles of computers for everyone</em>. Oldsmar, FL: John C. Scott.
</div>
</div>
</section>


</main> <!-- /main -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  if (document.documentElement.dataset.collapsableInit) return;
  document.documentElement.dataset.collapsableInit = "1";

  document.querySelectorAll(
    "h1.collapsable, h2.collapsable, h3.collapsable, h4.collapsable, h5.collapsable, h6.collapsable"
  ).forEach(h => {
    const details = h.nextElementSibling;
    if (!details || details.tagName.toLowerCase() !== "details") return;

    // Icon-Status initial
    h.classList.toggle("closed", !details.open);

    h.style.cursor = "pointer";
    h.addEventListener("click", () => {
      details.open = !details.open;
      h.classList.toggle("closed", !details.open);
    });
  });
});
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Kopiert");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Kopiert");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
        for (let i=0; i<annoteTargets.length; i++) {
          const annoteTarget = annoteTargets[i];
          const targetCell = annoteTarget.getAttribute("data-target-cell");
          const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
          const contentFn = () => {
            const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            if (content) {
              const tipContent = content.cloneNode(true);
              tipContent.classList.add("code-annotation-tip-content");
              return tipContent.outerHTML;
            }
          }
          const config = {
            allowHTML: true,
            content: contentFn,
            onShow: (instance) => {
              selectCodeLines(instance.reference);
              instance.reference.classList.add('code-annotation-active');
              window.tippy.hideAll();
            },
            onHide: (instance) => {
              unselectCodeLines();
              instance.reference.classList.remove('code-annotation-active');
            },
            maxWidth: 300,
            delay: [50, 0],
            duration: [200, 0],
            offset: [5, 10],
            arrow: true,
            appendTo: function(el) {
              return el.parentElement.parentElement.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'quarto',
            placement: 'right',
            popperOptions: {
              modifiers: [
              {
                name: 'flip',
                options: {
                  flipVariations: false, // true by default
                  allowedAutoPlacements: ['right'],
                  fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
                },
              },
              {
                name: 'preventOverflow',
                options: {
                  mainAxis: false,
                  altAxis: false
                }
              }
              ]        
            }      
          };
          window.tippy(annoteTarget, config); 
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./text.html" class="pagination-link" aria-label="Texte">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Texte</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./references.html" class="pagination-link" aria-label="Literaturverzeichnis">
        <span class="nav-page-text">Literaturverzeichnis</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>