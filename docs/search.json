[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Computer Science",
    "section": "",
    "text": "Vorwort\nGl√ºckwunsch ‚Äì du bist angekommen! Wie auch immer dein Weg hierher aussah, du hast es geschafft, dieses Buch zu √∂ffnen. Vielleicht bist du Student oder Studentin an der Hochschule Osnabr√ºck und wurdest (zu deinem Gl√ºck) gezwungen, oder du bist ganz bewusst hier gelandet und freust dich darauf, etwas Neues zu lernen ‚Äì genau wie ich.\nDieses Buch entstand urspr√ºnglich, um meinen Veranstaltungen an der Hochschule Osnabr√ºck eine verst√§ndliche und praxisnahe Grundlage zu geben. Es dient als Hauptlekt√ºre f√ºr meine Vorlesungen, aber auch als Nachschlagewerk f√ºr alle, die vielleicht mal eine Sitzung verpasst haben oder Themen eigenst√§ndig vertiefen wollen. Besonders willkommen sind dabei Quereinsteiger, Wiederholer oder einfach neugierige Menschen, die bisher noch gar keinen Kontakt mit der Hochschule Osnabr√ºck hatten.\nHier bekommst du keine trockene Theorie pr√§sentiert, sondern eine spannende, praxisnahe Einf√ºhrung in die Grundlagen moderner Computer und unserer digitalen Welt. Das Fach, das sich dahinter verbirgt, hei√üt auf Deutsch Informatik, international auch bekannt als Computer Science. Der Titel Hands-On Computer Science verr√§t bereits: Hier wird es praktisch ‚Äì und zwar von Anfang an.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#was-macht-dieses-buch-besonders",
    "href": "index.html#was-macht-dieses-buch-besonders",
    "title": "Hands-On Computer Science",
    "section": "Was macht dieses Buch besonders?",
    "text": "Was macht dieses Buch besonders?\nLehrb√ºcher zur Informatik gibt es reichlich. Viele davon sind gro√üartig, aber kaum eines passt perfekt zu dem, was ich mit meinen Studierenden vorhabe. Woran liegt das?\nViele klassische Informatikb√ºcher versuchen, das gesamte Fachgebiet m√∂glichst umfassend abzubilden. Das ist sinnvoll f√ºr angehende Informatiker, aber meine Zielgruppe bist Du: Studierende in Studieng√§ngen wie Management nachhaltiger Ern√§hrungssysteme, Lebensmittelproduktion oder Agrarsystemtechnologien ‚Äì oder vielleicht bist du nicht mal Student oder Studentin, sondern einfach interessiert daran, einen besseren Zugang zur digitalen Welt zu finden.\nKurz gesagt: Dieses Buch ist f√ºr alle gedacht, die Lust haben, in die digitale Welt einzutauchen, ohne sich gleich mit komplizierten Details zu √ºberfordern. Daf√ºr brauchst du kein allumfassendes Nachschlagewerk, sondern einen klaren roten Faden, der dich Schritt f√ºr Schritt an die grundlegenden Konzepte heranf√ºhrt.\nViele B√ºcher versprechen Praxisn√§he, doch oft endet diese in n√ºchternen √úbungsaufgaben am Kapitelende. Genau hier setzt Hands-On Computer Science an und macht zwei Dinge anders:\n\nDu lernst informatische Konzepte anhand spannender Experimente mit Microcontrollern, Sensoren, Buttons, LEDs und Displays kennen.\nDu arbeitest kontinuierlich am LiFi-Projekt, das dich durch alle Kapitel begleitet und dabei immer weiter w√§chst.\nTheorie und Praxis sind nicht getrennt, sondern eng miteinander verbunden ‚Äì Programmieren und informatische Grundlagen lernst du gleichzeitig.\n\nSchon ab Kapitel 1 beginnst du zu programmieren und zwar nicht abstrakt, sondern konkret mit Bauteilen wie LEDs. Im Laufe des Buches lernst du Schritt f√ºr Schritt neue Hardware-Komponenten kennen, die immer direkt mit relevanten informatischen Konzepten verkn√ºpft sind. So schlie√üt du am Ende nicht nur eine Reihe Experimente erfolgreich ab, sondern verf√ºgst fast nebenbei √ºber ein solides Fundament in der Informatik und der Programmierung. Wenn alles gut l√§uft, merkst du kaum, wie schnell du gelernt hast.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#tipps-f√ºr-die-lekt√ºre",
    "href": "index.html#tipps-f√ºr-die-lekt√ºre",
    "title": "Hands-On Computer Science",
    "section": "Tipps f√ºr die Lekt√ºre",
    "text": "Tipps f√ºr die Lekt√ºre\nWeil es in diesem Buch viel ums Programmieren geht, findest auch viele Codebl√∂cke oder Codesnippets. Als Einstiegssprache verwenden wir Python. Warum ausgerechnet Python? Das erf√§hrst du sp√§ter genauer.\nCodebl√∂cke sind deutlich sichtbar vom √ºbrigen Text abgehoben, grau hinterlegt und in einer Schreibmaschinenschrift dargestellt, etwa Courier New oder Consolas. Hier ein kleines Beispiel:\n\n1led.set_rgb_value(0, 0, 0)\n2led.set_rgb_value(255, 255, 255)\n\nprint(\"Diese Zeile hat keine Annotation\")\n\n3# Lasse die LED blau aufleuchten\nled.set_rgb_value(0, 0, 255)\n\n\n1\n\nSchaltet die LED aus, weil der RGB-Code (0,0,0) schwarz erzeugt.\n\n2\n\nSchaltet die LED auf wei√ües Licht, weil drei Mal die 255 die Farbe Wei√ü ergibt.\n\n3\n\nAuch Kommentare sind f√ºr kurze Erl√§uterungen n√ºtzlich.\n\n\n\n\nKommentare sind mit einer kleinen Zahl versehen. Wenn du das Buch online liest und mit der Maus √ºber diese Zahl f√§hrst, erscheint ein Tooltip, der die Codezeile erkl√§rt. Das funktioniert nur online, nicht in PDF oder Druckversion. Dort sind die Erl√§uterungen unter dem Codeblock aufgef√ºhrt.\nNoch ein kleiner Tipp: Wenn du mit der Maus √ºber den Codeblock f√§hrst, siehst du rechts oben ein Clipboard-Symbol. Ein Klick darauf kopiert den Code direkt in deine Zwischenablage, und du kannst ihn problemlos in dein ge√∂ffnetes Visual Studio Code oder eine andere IDE einf√ºgen und ausprobieren.\nAlle Codebeispiele findest du au√üerdem im GitHub-Repository, das zu diesem Buch geh√∂rt.\nAlles klar? Dann schauen wir mal, was uns in diesem Buch erwartet!\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "experiments.html",
    "href": "experiments.html",
    "title": "Experimente",
    "section": "",
    "text": "Hands-On Programmieren lernen\nHast du dich schon einmal gefragt, wie man Informationen √ºber Licht √ºbertragen kann? Oder wie man mit Licht den Puls messen kann? Oder wie man mit zwei einfachen Kabeln einen Wasserstandssensor baut? Das alles klingt vielleicht weit hergeholt, ist aber tats√§chlich machbar ‚Äì und wie genau, das wollen wir in diesem Buch herausfinden! Dabei werden wir nicht nur die digitale Welt der Computer und Programmierung kennenlernen, sondern auch mit spannenden Ger√§ten in der analogen Welt arbeiten. In jedem Kapitel arbeiten wir mit anderen Ger√§ten, die dir unterschiedliche Facetten der digitalen Welt n√§herbringen und gleichzeitig erm√∂glichen, das Programmieren spielerisch zu erlernen.\nHier ein √úberblick √ºber die Ger√§te, mit denen wir gemeinsam experimentieren werden. Zusammengefasst kosten alle Komponenten 249 ‚Ç¨. Aber keine Sorge: Wenn du das Buch im Rahmen meines Moduls ‚ÄûDigitalisierung und Programmierung‚Äú an der Hochschule Osnabr√ºck liest, erh√§ltst du f√ºr das gesamte Semester ein komplettes Hardware-Kit.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#hands-on-programmieren-lernen",
    "href": "experiments.html#hands-on-programmieren-lernen",
    "title": "Experimente",
    "section": "",
    "text": "Abbildung¬†1: Tinkerforge Workbench mit vielen Ger√§ten\n\n\n\n\n\n\n\nWas?\nBauteil\nAnzahl\nPreis pro St√ºck\n\n\n\n\nBunte LED\nRGB LED Bricklet 2.0\n1\n8 ‚Ç¨\n\n\nButton mit integrierter, bunter LED\nRGB LED Button Bricklet\n1\n15 ‚Ç¨\n\n\nLicht- und Farbsensor\nColor Bricklet 2.0\n1\n17 ‚Ç¨\n\n\nLCD Touchdisplay\nLCD 128x64 Bricklet\n1\n33 ‚Ç¨\n\n\nPiezo Lautsprecher\nPiezo Speaker Bricklet 2.0\n1\n19 ‚Ç¨\n\n\nInfrarot-Entfernungsmesser\nDistance IR 4-30cm Bricklet 2.0\n1\n20 ‚Ç¨\n\n\nAnaloger Spannungssensor\nAnalog In Bricklet 3.0\n1\n14 ‚Ç¨\n\n\nSchalldruckpegelsenor\nSound Pressure Level Bricklet\n1\n35 ‚Ç¨\n\n\nMikrocontroller\nMaster Brick 3.2\n2\n35 ‚Ç¨\n\n\nAnschlusskabel 15 cm\nBricklet Kabel 15cm (7p-7p)\n8\n1 ‚Ç¨\n\n\nUSB-A- auf USB-C Kabel\nUSB-A auf USB-C Kabel 100 cm\n1\n6 ‚Ç¨\n\n\nMontageplatte\nMontageplatte 22x22 (12x12cm)\n2\n7 ‚Ç¨\n\n\nSchrauben, Abstandshalter und Muttern\nBefestigungskit 12mm\n4\n2 ‚Ç¨",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#spannende-experimente",
    "href": "experiments.html#spannende-experimente",
    "title": "Experimente",
    "section": "Spannende Experimente",
    "text": "Spannende Experimente\nKapitel f√ºr Kapitel werden wir an unterschiedlichen Experimenten arbeiten. Dabei lernst du nicht nur, wie man Hardware-Komponenten miteinander verbindet, sondern vor allem auch, wie man Computer ‚Äì diese universellen Probleml√∂sungsmaschinen ‚Äì f√ºr eigene Ideen und L√∂sungen programmieren kann. Hier ist der √úberblick, was dich in diesem Buch erwartet:\n\n\n\n\n\n\n\nKapitel\nExperiment(e)\n\n\n\n\n1¬† Farben\nWir lassen eine LED einen Regenbogenfarbverlauf √ºber die Zeit erzeugen.\n\n\n3¬† Texte\nWir lernen, wie man Texte umst√§ndlich und ohne Tastatur eingeben kann ‚Äì √ºber Handgesten.\n\n\n4¬† Bilder\nWir verbinden Tabellenkalkulation mit Bildern und Touchdisplays ü§Ø\n\n\n5¬† Codes\nWir lernen Morse-Code und wie wir diesen √ºber einen Lautsprecher ausgeben k√∂nnen.\n\n\n6¬† Umwandlung\nWir verwenden einfache Kippschalter, um analoge Werte in digitale Werte umzuwandeln.\n\n\n7¬† Information\n\n\n\n8¬† Sensoren\nWir bauen einen Wasserstandssensor mit einem analogen Spannungssensor.\n\n\n9¬† Signale\nWir basteln einen Pulsmesser aus einem Farbsensor üíì\n\n\n10¬† Protokolle\nWir √ºbertragen Nachrichten √ºber Lichtsignale üî¶\n\n\n11¬† Verschl√ºsselung\nWir verstecken geheime Botschaften in harmlosen Nachrichten üïµÔ∏è‚Äç‚ôÄÔ∏è\n\n\n12¬† Algorithmen\n\n\n\n13¬† Kompression\nWir entwickeln ein Verfahren, um Information zu komprimieren.\n\n\n14¬† Computer\nWir entwickeln eine Rechenmaschine, die zwei Bytes addieren kann, mit nur einem einem Bauteil.\n\n\n15¬† Probleme",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "href": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "title": "Experimente",
    "section": "Frust ist dein Freund ‚Äì zumindest ein bisschen",
    "text": "Frust ist dein Freund ‚Äì zumindest ein bisschen\nEins m√∂chte ich gleich vorwegnehmen: Beim Programmierenlernen ist eine gewisse Portion Frust unvermeidbar. Klingt unangenehm? Ist es auch! Aber es ist zugleich Teil eines enorm wertvollen Lernprozesses. Jeder Fehler, den du machst, ist eine Gelegenheit, um zu verstehen, wie Computer wirklich funktionieren ‚Äì n√§mlich absolut pr√§zise und ohne jede Toleranz f√ºr Fehler.\nComputer sind gnadenlose Lehrer. Sie zeigen dir sofort und unerbittlich, wenn etwas nicht stimmt ‚Äì sei es ein vergessener Punkt, ein falscher Buchstabe oder ein simpler Zahlendreher. Das kann frustrieren, aber genau dieses direkte und sofortige Feedback hilft dir auch, schnell und effektiv zu lernen. Sobald du verstehst, wie du aus Fehlermeldungen sinnvolle Schl√ºsse ziehst und deine Programme entsprechend korrigierst, wirst du belohnt ‚Äì mit Erfolgserlebnissen und einer steilen Lernkurve.\n\n\n\n\n\n\nAbbildung¬†2: Ein frustrierter Frosch\n\n\n\nAlso, wenn mal etwas nicht klappt: Nimm es nicht pers√∂nlich, sondern sieh es als Herausforderung. Atme tief durch, mach dir klar, dass Fehler unvermeidbar und sogar wichtig sind, und probier es noch einmal. Ich verspreche dir: Es lohnt sich!\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "prerequisites.html",
    "href": "prerequisites.html",
    "title": "Voraussetzungen",
    "section": "",
    "text": "Visual Studio Code\nUm die Experimente in diesem Buch durchf√ºhren zu k√∂nnen, ben√∂tigt ihr die folgende Software auf eurem Computer:\nEine beliebte Entwicklungsumgebung, die ihr kostenlos herunterladen k√∂nnt. Hier geht‚Äôs zur Download-Seite.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "prerequisites.html#python",
    "href": "prerequisites.html#python",
    "title": "Voraussetzungen",
    "section": "Python",
    "text": "Python\nEine Programmiersprache, die f√ºr die Experimente verwendet wird. Ihr k√∂nnt Python von der offiziellen Website herunterladen: Python Download.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "prerequisites.html#software-von-tinkerforge",
    "href": "prerequisites.html#software-von-tinkerforge",
    "title": "Voraussetzungen",
    "section": "Software von Tinkerforge",
    "text": "Software von Tinkerforge\n\nTinkerforge-Bibliothek f√ºr Python\nEine Sammlung von Funktionen, die die Programmierung der Tinkerforge-Hardware erleichtern. Ihr k√∂nnt die Bibliothek mit dem folgenden Befehl installieren: pip install tinkerforge.\n\n\nBrick Daemon\nEin Hintergrundprozess, der die Kommunikation mit der Tinkerforge-Hardware erm√∂glicht. Ihr k√∂nnt den Brick Daemon von der Tinkerforge-Website herunterladen: Brick Daemon Download.\n\n\nBrick Viewer\nEin Tool, das eine grafische Benutzeroberfl√§che f√ºr die Interaktion mit der Tinkerforge-Hardware bietet. Ihr k√∂nnt den Brick Viewer von der Tinkerforge-Website herunterladen: Brick Viewer Download.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "colors.html",
    "href": "colors.html",
    "title": "1¬† Farben",
    "section": "",
    "text": "Zusammenfassung\nIm ersten Kapitel steigen wir gleich voll ein und schreiben unser erstes Programm. Unser Ziel ist es, eine LED nacheinander in allen Farben des Regenbogens leuchten zu lassen. Um dahin zu kommen, lernen wir in Abschnitt 1.1 zuerst, wie man √ºberhaupt eine LED aus einem Programm heraus steuern kann. In Abschnitt 1.2 werfen wir einen kurzen Blick auf Farben im allgemeinen und wie diese im Computer erzeugt werden. Dabei unterscheiden wir die additive von der subtraktiven Farbmischung. Danach bereiten wir uns in Abschnitt 1.3 auf den Regenbogenfarbverlauf vor, indem wir zuerst eine pulsierende LED programmieren. Wir lernen dann in Abschnitt 1.4, wie man mittels RGB-Farbcode √ºberhaupt einen Regenbogen erzeugen kann und warum das f√ºr uns Menschen n√ºtzlich ist. Am Ende in Abschnitt 1.5 schreiben wir schlie√ülich das Programm, das die LED in allen Farben des Regenbogens leuchten l√§sst.\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#zusammenfassung",
    "href": "colors.html#zusammenfassung",
    "title": "1¬† Farben",
    "section": "",
    "text": "Wir verstehen, wie Farben im Computer funktionieren und beschrieben werden.\nWir entwickeln unser erstes Programm am Beispiel einer LED-Steuerung.\nWir lernen Schleifen als wichtiges Konzept in der Programmierung kennen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#experimentaufbau",
    "href": "colors.html#experimentaufbau",
    "title": "1¬† Farben",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardwareaufbau\nBereit f√ºr euer erstes Hardware-Experiment? Perfekt! Ihr braucht daf√ºr eine LED (RGB LED Bricklet 2.0) und einen Mikrocontroller (Master Brick 3.2). Befestigt beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in Abbildung¬†1.1 gezeigt. Zwei Schrauben pro Ger√§t reichen v√∂llig. Denkt an die kleinen, wei√üen Unterlegscheiben aus Kunststoff. Sie sch√ºtzen eure Platinen vor Druckstellen.\nNeben der Hardware ben√∂tigt ihr auch die passende Software. Diese solltet ihr bereits installiert haben. Falls nicht, schaut im Abschnitt zu den Voraussetzungen vorbei. Dort ist alles genau beschrieben. Im Folgenden gehe ich davon aus, dass ihr alles am Laufen habt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Nahaufnahme der LED.\n\n\n\n\n\n\n\n\n\n\n\n(c) Montageplatte mit allen Komponenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Untenansicht.\n\n\n\n\n\n\n\n\n\n\n\n(e) Ansicht der vier Steckpl√§tze.\n\n\n\n\n\n\n\nAbbildung¬†1.1: Einfaches Setup mit einem Mikrocontroller und einer LED.\n\n\n\n\n\nErste Schritte\nIm ersten Schritt wollen wir die LED und ihre Funktionen testen! Das geht ganz leicht mit dem Brick Viewer. Schlie√üt zuerst den Master Brick √ºber das USB-Kabel an euren Computer an und √∂ffnet den Brick Viewer. Klickt dann auf den Connect-Button.\n\n\n\n\n\n\nAbbildung¬†1.2: √úber den Connect-Button verbindet ihr den Brick Viewer mit dem angeschlossenen Master Brick.\n\n\n\nWenn alles geklappt hat, zeigt euch der Brick Viewer alle angeschlossenen Ger√§te in Tabs an. Schaut euch Abbildung¬†1.3 an ‚Äì so etwa sollte es aussehen.\n\n\n\n\n\n\nAbbildung¬†1.3: Der Brick Viewer, nachdem ihr mit dem Master Brick verbunden seid.\n\n\n\nWechselt nun zum Tab der RGB LED. Hier k√∂nnt ihr auf unterschiedlichen Wegen die Farbe der LED einstellen. Mehr kann eine LED nicht!\nMit den drei Schiebereglern steuert ihr die einzelnen Farbkan√§le ‚Äì Rot, Gr√ºn, Blau. Der Wertebereich: 0 bis 255. Warum gerade diese Farben und diese Zahlen? Gute Frage. Die Antwort kommt weiter unten.\n\n\n\n\n\n\nAbbildung¬†1.4: Die Ansicht f√ºr die RGB LED im Brick Viewer, in der ihr alle Funktionen per Klick im Zugriff habt.\n\n\n\nFazit: Der Brick Viewer ist ideal zum Ausprobieren. Aber wenn ihr echte Projekte umsetzen wollt, m√ºsst ihr programmieren lernen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-control-led",
    "href": "colors.html#sec-colors-control-led",
    "title": "1¬† Farben",
    "section": "1.1 Erstes Programm: LED ansteuern",
    "text": "1.1 Erstes Programm: LED ansteuern\nWie verbinden wir uns √ºber ein Programm mit der LED und setzen ihre Farbe? Die Antwort darauf findet ihr im folgenden kurzen Codebeispiel.\n\n\n\n\nListing¬†1.1: Der Boilerplate-Code f√ºr die Verbindung mit den Ger√§ten am Beispiel der RGB LED.\n\n\n1from tinkerforge.ip_connection import IPConnection\n2from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\n3ipcon = IPConnection()\n4ipcon.connect(\"localhost\", 4223)\n5led = BrickletRGBLEDV2(\"ZEP\", ipcon)\n\n\n\n\n\n1\n\nHier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.\n\n2\n\nHier importieren wir ein weiteres Objekt, das wir zur Darstellung der LED als Python-Objekt ben√∂tigen.\n\n3\n\nDie Verbindung erfolgt √ºber eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.\n\n4\n\nMit connect stellen wir eine Verbindung zum angeschlossenen Master Brick her.\n\n5\n\nSchlie√ülich holen wir uns eine virtuelle Instanz des RGB LED Bricklets, indem wir die UID nennen und sagen, welche Verbindung (ipcon) genutzt werden soll.\n\n\n\n\n\n1.1.1 Programme\nZun√§chst kl√§ren wir den Begriff Programm. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausf√ºhrt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm sp√§ter daf√ºr zust√§ndig, mit der LED zu interagieren und sie in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns erm√∂glichen, dem Computer pr√§zise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut f√ºr Einsteiger eignet und gleichzeitig m√§chtig genug ist, um komplexe Aufgaben zu l√∂sen.\nWenn wir ein Programm ausf√ºhren, arbeitet der Computer die Anweisungen Schritt f√ºr Schritt von oben nach unten ab. Die Nummerierung der Zeilen verdeutlicht das sehr sch√∂n. Der Computer beginnt bei Zeile 1 und arbeitet die Befehle Zeile f√ºr Zeile bis nach unten ab.\nEs gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir sp√§ter kennen.\n\n\n1.1.2 Boilerplate Code\nDer Codeausschnitt in Listing¬†1.1 wird uns im Verlauf dieses Buches immer wieder begegnen. Wir ben√∂tigen ihn, um uns am Anfang des Programms mit den Ger√§ten zu verbinden, die wir f√ºr unsere Anwendung ben√∂tigen. In der Informatik nennen wir solchen Code, den wir h√§ufig in der gleichen Form ben√∂tigen und fast eins zu eins kopieren k√∂nnen, auch Boilerplate-Code. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.\n\n\n1.1.3 Bibliotheken\nBeginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr √§hnliche Befehle, die mit dem Schl√ºsselwort from beginnen. Nach dem Schl√ºsselwort from folgt der Name einer Bibliothek, aus der wir ein f√ºr unser Programm ben√∂tigtes Objekt importieren. Die Kombination der Schl√ºsselw√∂rter from ... import l√§sst sich also w√∂rtlich √ºbersetzen: ‚ÄúAus der Bibliothek X importiere das Objekt Y‚Äù.\nEine Bibliothek in einer Programmiersprache ist die B√ºndelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek k√∂nnt ihr euch vorstellen wie einen Werkzeugkasten: Sie enth√§lt fertige Werkzeuge (Funktionen und Klassen), damit ihr nicht alles von Grund auf selbst programmieren m√ºsst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Ger√§ten loslegen k√∂nnen. F√ºr jedes Ger√§t gibt es in der Tinkerforge-Bibliothek eine eigene Klasse, √ºber die wir auf die Funktionen jedes Ger√§ts zugreifen k√∂nnen.\n\n\n1.1.4 Klassen und Objekte\nMit from ... import importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit importieren ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge sp√§ter wirklich nutzen, steht auf einem anderen Blatt.\nIn dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ank√ºndigen. Die erste Klasse hei√üt IPConnection und die zweite BrickletRGBLEDV2. Der Begriff Klasse ist hier analog zum Begriff Kategorie zu verstehen. Wir k√∂nnen zu einer Klasse geh√∂rige Objekte erzeugen, und alle Objekte derselben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.\nStellt euch vor, ihr habt eine Klasse namens Auto. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa fahren(), bremsen() oder tanken(). Diese Dinge sollen f√ºr jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Wir k√∂nnen also sagen: ‚ÄúMein Auto ist ein Objekt der Klasse Auto.‚Äù Jedes Auto hat neben den Funktionen die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte f√ºr diese Eigenschaften haben.\nGenauso verh√§lt es sich mit den Klassen, die Tinkerforge f√ºr uns bereitgestellt hat. Die Klasse IPConnection beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen k√∂nnen, und die Klasse BrickletRGBLEDV2 beschreibt, wie wir mit der LED interagieren k√∂nnen. Wenn wir ein Objekt dieser Klasse erstellen, k√∂nnen wir alle Funktionen nutzen, die in der Klasse definiert sind. Eine LED muss nicht fahren oder bremsen wie ein Auto. Daf√ºr hat sie andere Funktionen, wie etwa set_rgb_value(), die uns erlaubt, die Farbe der LED zu √§ndern. Eine Eigenschaft jeder LED ist ihre UID, die eindeutig ist und uns hilft, sie im System zu identifizieren.\n\n\n1.1.5 Schl√ºsselw√∂rter\nSoeben haben wir mit from und import unsere ersten beiden Schl√ºsselw√∂rter in Python kennengelernt! Aber was bedeutet das genau? Ein Schl√ºsselwort, das wir im Englischen auch keyword oder reserved keyword nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch h√§ufig Namen vergeben m√ºssen, etwa f√ºr Variablen oder Funktionen. Diese Namen d√ºrfen nicht wie ein Schl√ºsselwort lauten, ansonsten funktioniert unser Programm nicht wie gew√ºnscht. Welche Schl√ºsselw√∂rter es in Python gibt, k√∂nnt ihr hier nachschauen.\nIm Codeausschnitt oben laden wir zuerst das Objekt f√ºr die Verbindung zum angeschlossenen Mikrocontroller, die √ºber eine IP-Verbindung hergestellt wird. Was das genau ist? Sp√§ter mehr dazu. Zus√§tzlich zur IPConnection laden wir anschlie√üend noch die ben√∂tigten Klassen f√ºr die Ger√§te, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur die LED, in sp√§teren Experimenten werden es auch mal mehrere Ger√§te sein.\n\n\n1.1.6 Objekte erzeugen\nIn Listing¬†1.1 in Zeile 4 erzeugen wir ein Objekt der Klasse IPConnection. Die fertige Instanz ‚Äì so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde ‚Äì speichern wir auf einer Variable mit dem Namen ipcon. Diesen Namen haben wir uns selbst ausgedacht, damit wir sp√§ter darauf zugreifen k√∂nnen. Wir h√§tten auch einen anderen Namen w√§hlen k√∂nnen. Eine Variable ist also ein Platzhalter f√ºr einen Wert, den wir sp√§ter im Programm verwenden wollen. In diesem Fall ist ipcon der Platzhalter f√ºr die Verbindung zu unserem Mikrocontroller. Was eine Variable technisch ist, lernen wir sp√§ter noch genauer kennen.\n\n\n1.1.7 Methoden\n√úber das Objekt ipcon k√∂nnen wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode connect(). Eine Methode ist eine Funktion, die zu einem Objekt geh√∂rt ‚Äì wie etwa fahren() oder bremsen() in unserem Auto-Beispiel.\nWir k√∂nnen Methoden aufrufen, um eine bestimmte Aktion auszuf√ºhren. In diesem case stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, √ºber den die Verbindung hergestellt werden soll. In unserem Fall ist das ‚Äúlocalhost‚Äù, was f√ºr die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standardm√§√üig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt . nach dem Objekt, gefolgt vom Namen der Methode und den Klammern (), in denen wir eventuell ben√∂tigte Parameter angeben.\nEine Methode ist letztlich eine Funktion, die zu einem Objekt geh√∂rt. Zu einem sp√§teren Zeitpunkt schreiben wir unsere eigenen Funktionen und lernen dann noch viel mehr dar√ºber.\n\n\n1.1.8 Ein Objekt f√ºr die LED\nIn Zeile 6 erzeugen wir schlie√ülich ein Objekt der Klasse BrickletRGBLEDV2. Dieses Objekt repr√§sentiert unsere LED und erm√∂glicht es uns, mit ihr zu interagieren. Wir nennen das Objekt led, was kurz und klar ist. Auch hier haben wir uns den Namen selbst ausgedacht, um sp√§ter darauf zugreifen zu k√∂nnen. Auch wenn wir grunds√§tzlich Variablennamen frei w√§hlen k√∂nnen, sollten sie immer so gew√§hlt werden, dass sie den Inhalt der Variable beschreiben. Das macht es sp√§ter einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten m√ºssen. Dazu geh√∂ren etwa, dass Variablennamen nicht mit einer Zahl beginnen d√ºrfen und keine Leerzeichen enthalten d√ºrfen. Eine ausf√ºhrliche Liste der Regeln findet ihr hier.\n\n\n1.1.9 Zusammenfassung unseres ersten Programms\nDamit haben wir unser erstes Programm von oben nach unten erl√§utert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:\n\n\n\n\n\n\n\nProgramme\nAbfolge von Anweisungen, die nacheinander ausgef√ºhrt werden.\n\n\nBoilerplate Code\nStandard-Code, den man immer wieder braucht.\n\n\nImportieren von Bibliotheken\nSammlung von fertigen Code-Elementen.\n\n\nSchl√ºsselw√∂rter\nReservierte Begriffe der Programmiersprache.\n\n\nKlassen und Objekte\nKategorien und deren konkrete Instanzen.\n\n\nMethoden und Funktionen\nFunktionen, die zu einem Objekt geh√∂ren.\n\n\nVariablen\nPlatzhalter f√ºr Werte.\n\n\n\n\n\n1.1.10 Und jetzt?\nWir haben nun eine digitale Repr√§sentation unserer LED in Python. Wir k√∂nnen die LED jetzt zum Leuchten bringen, indem wir eine Methode der Klasse BrickletRGBLEDV2, die set_rgb_value() hei√üt, verwenden. Diese Methode erwartet drei Parameter: Rot, Gr√ºn und Blau. Mit diesen Parametern k√∂nnen wir die Farbe der LED einstellen.\n\n1led.set_rgb_value(0, 255, 0)\n\n\n1\n\nSetzt die LED auf gr√ºn. R = 0, G = 255, B = 0. Logisch, oder?\n\n\n\n\nMoment mal ‚Ä¶ Wo steht hier eigentlich gr√ºn? Steht da gar nicht. Stattdessen drei Zahlen. Willkommen bei der RGB-Farbkodierung. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Gr√ºn, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Wei√ü. Nur Gr√ºn auf 255? Na klar: gr√ºn.\nAber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie √ºbersetzen wir die Welt in etwas, das ein Computer versteht?\nWarum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit drei Zahlen? Warum √ºberhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?\nVorher m√ºssen wir aber kurz zur√ºck in die Schule.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-light-and-colors",
    "href": "colors.html#sec-colors-light-and-colors",
    "title": "1¬† Farben",
    "section": "1.2 Licht und Farben",
    "text": "1.2 Licht und Farben\n\n1.2.1 Blick auf die Physik\nPhysik ist vielleicht schon eine Weile her. Erinnern wir uns dennoch kurz, was Licht ist und wie Farben damit zusammenh√§ngen. Licht ist elektromagnetische Strahlung. Das bedeutet, es handelt sich um gekoppelte Schwingungen elektrischer und magnetischer Felder, die sich mit Lichtgeschwindigkeit ausbreiten. Vereinfacht k√∂nnen wir uns Licht als Wellen vorstellen, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenl√§ngen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen √ºber Infrarotstrahlung bis hin zu R√∂ntgenstrahlen und Gammastrahlen reicht.\nBei Wellen unterscheiden wir zwischen der Frequenz (wie oft die Welle pro Sekunde schwingt) und der Wellenl√§nge (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenl√§nge sind umgekehrt proportional: Je h√∂her die Frequenz, desto k√ºrzer die Wellenl√§nge und umgekehrt.\nFrequenzen messen wir in Hertz (Hz), wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenl√§ngen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) f√ºr violettes Licht und etwa 700 nm f√ºr rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abst√§nde zwischen den Wellenl√§ngen des sichtbaren Lichts sind also extrem klein.\nWas bedeutet das nun f√ºr eine LED? Eine LED (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchflie√üt. Die Farbe des Lichts h√§ngt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenl√§ngen, was zu verschiedenen Farben f√ºhrt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenl√§nge von etwa 620‚Äì750 nm, w√§hrend eine gr√ºne LED Licht mit einer Wellenl√§nge von etwa 495‚Äì570 nm emittiert.\n\n\n\n\n\n\nAbbildung¬†1.5: Das elektromagnetische Spektrum, von dem das sichtbare Licht ein kleiner Teil ist. (Quelle: Wikipedia)\n\n\n\nDie RGB LED besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer gr√ºnen und einer blauen. Jede dieser LEDs kann unabh√§ngig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Stromst√§rke bedeutet mehr Intensit√§t der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Gr√ºn und Blau in unterschiedlichen Intensit√§ten k√∂nnen wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensit√§t leuchten lassen, erhalten wir Wei√ü. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LEDs sind dann alle aus.\nJetzt wissen wir, warum die Methode set_rgb_value() drei Parameter erwartet: Rot, Gr√ºn und Blau. Diese Parameter sind die Intensit√§ten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 k√∂nnen wir jede Farbe im sichtbaren Spektrum erzeugen.\nEin Farbwert im Computer besteht also aus drei Zahlen besteht, die jeweils zwischen 0 und 255 liegen. Das gilt f√ºr unsere LED, aber auch f√ºr Pixel in TVs, Smartphones, digitalen Fotos oder Monitoren. Wie kommt es aber zu der merkw√ºrdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grunds√§tzlich Werte speichert und wie dieser Speicher organisiert ist. Genaueres erfahren wir schon in Kapitel 2.\nKlingt alles theoretisch sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus und mischen zwei Farben mit voller Intensit√§t!\n\nled.set_rgb_value(255, 255, 0)\n\nWas macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!\n\n\n1.2.2 Additive Farbmischung\nIhr solltet alle eure LEDs in Gelb aufleuchten sehen. In der additiven Farbmischung mischen wir Rot und Gr√ºn und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Gr√ºn, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensit√§t leuchten lassen, erhalten wir eine neue Farbe, die stets heller ist als die Ursprungsfarben. Wir f√ºgen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensit√§t mischen, erhalten wir schlie√ülich Wei√ü.\n\nled.set_rgb_value(255, 255, 255)\n\nAm anderen Ende des Spektrums erzeugen drei Nullen die Farbe Schwarz:\n\nled.set_rgb_value(0, 0, 0)\n\n\n\n1.2.3 Subtraktive Farbmischung\nIhr k√∂nnt euch merken, dass wir im Kontext von Computern oft von additiver Farbmischung sprechen, weil Bildschirme Licht erzeugen. Durch das Mischen der drei Farbkan√§le entstehen neue Farben gem√§√ü der additiven Farbmischung, also stets heller als ihre Grundfarben. Daneben gibt es aber noch die subtraktive Farbmischung. Sie funktioniert anders, n√§mlich genau umgekehrt. Statt beim Mischen Licht hinzuzuf√ºgen, nehmen wir Licht weg.\nErinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbkasten die Mischung aus Rot und Gr√ºn ergeben? Sicher nicht Gelb ‚Äì eher Braun. Eine dunklere Farbe. Das liegt daran, dass wir es hier nicht mit additiver, sondern mit subtraktiver Farbmischung zu tun haben. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht absorbieren und reflektieren. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtspektrums werden nicht mehr reflektiert, sondern absorbiert und sind damit nicht mehr sichtbar. Das Ergebnis einer Mischung zweier Farben ergibt in der subtraktiven Farbmischung also stets eine dunklere Farbe ‚Äì genau umgekehrt zur additiven Farbmischung.\nWas passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, n√§mlich W√§rme. Deshalb wird eine schwarze Oberfl√§che auch besonders hei√ü, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspektrum und wandelt es in W√§rme um. Dagegen wirken wei√üe Oberfl√§chen fast wie Klimaanlagen. Es ist kein Zufall, dass wir in sonnigen Erdteilen viele wei√üe Fassaden sehen.\nWenn wir alle Farben mischen, ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zur√ºck. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen kombinieren, um neue Farben zu erhalten.\n\n\n\n\n\n\n\n\n\n\n\n(a) Additive Farbmischung\n\n\n\n\n\n\n\n\n\n\n\n(b) Subtraktive Farbmischung\n\n\n\n\n\n\n\nAbbildung¬†1.6: Additive und subtraktive Farbmischung.\n\n\n\nIn Abbildung¬†1.6 sehen wir die beiden Farbmischungsarten im Vergleich. In Abbildung¬†1.6 (b) sehen wir die drei Grundfarben, die wir bei der subtraktiven Variante ben√∂tigen, um daraus alle weiteren Farben zu erhalten. Das sind Cyan, Magenta und Gelb. Im Englischen ist die Abk√ºrzung CMY, wo das ‚ÄúY‚Äù f√ºr Yellow steht. In der additiven Farbmischung sind es, wie oben schon gesehen, Rot, Gr√ºn und Blau. Wenn ihr Abbildung¬†1.6 (a) betrachtet, dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der additiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?\nIn der additiven Farbmischung entsteht Gelb durch das Mischen von Rot und Gr√ºn, wobei Blau fehlt. Im Umkehrschluss bedeutet das: Gelbes Licht enth√§lt keine blaue Komponente, es reflektiert also kein Blau. In der subtraktiven Farbmischung (wie beim Farbkasten) wird Gelb erzeugt, indem Blau aus wei√üem Licht herausgefiltert wird ‚Äì Gelb reflektiert also kein Blau, sondern absorbiert es. Gelb kann also auch als Blaufilter gesehen werden. Das erkl√§rt, warum ein gelber Gegenstand unter blauem Licht dunkel erscheint: Er kann das blaue Licht nicht reflektieren.\nJetzt k√∂nnen wir auch erkl√§ren, warum Farbdrucker vier unterschiedliche Kartuschen ben√∂tigen (Abbildung¬†1.7). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb k√∂nnen wir jede beliebige Farbe mischen. Zus√§tzlich haben Drucker eine Kartusche f√ºr Schwarz, um erstens ein sattes Schwarz drucken zu k√∂nnen und zweitens die Farbkartuschen zu schonen. Denn schlie√ülich m√ºssen alle drei Farben gemischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen Schwarz enthalten (oder sogar ausschlie√ülich), ist eine schwarze Kartusche einfach effizienter. Die Farbe Schwarz wird bei Druckerkartuschen als Key bezeichnet und mit ‚ÄúK‚Äù abgek√ºrzt. Wir sprechen daher auch von CMYK.\n\n\n\n\n\n\nAbbildung¬†1.7: Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.\n\n\n\nFarben spielen eine so wichtige Rolle bei der Arbeit mit Computern. Deshalb lohnt es sich, ein wenig √ºber die Hintergr√ºnde von Farben und deren Mischung zu verstehen. Wir werden sp√§ter noch lernen, wie Bildschirme Farben darstellen. Sp√§testens dann wird uns das Thema der Farbmischung wieder begegnen.\nAb jetzt wollen wir weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, praxisnah verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED √ºber die Methode set_rgb_value() ver√§ndern k√∂nnen, wenn wir wissen, welcher RGB-Code unsere gew√ºnschte Farbe repr√§sentiert. Da wir jetzt mehr √ºber die Farbmischung wissen, k√∂nnen wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:\n\nled.set_rgb_value(255, 0, 255)\n\nGem√§√ü der Theorie der additiven Farbmischung (Abbildung¬†1.6 (a)) m√ºssten Rot und Blau Magenta ergeben. Probiert es aus!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-pulsating-led",
    "href": "colors.html#sec-colors-pulsating-led",
    "title": "1¬† Farben",
    "section": "1.3 Pulsierende LED",
    "text": "1.3 Pulsierende LED\nDas deklarierte Ziel unseres ersten Experiments ist es, einen Regenbogenfarbverlauf zu erzeugen. Dazu m√ºssen wir die Farbe der LED kontinuierlich √§ndern, sodass sie von Rot √ºber Gelb, Gr√ºn, Cyan, Blau und Violett wieder zur√ºck zu Rot wechselt.\nLasst uns aber m√∂glichst einfach anfangen und uns dem Regenbogen schrittweise ann√§hern. Zun√§chst w√§re es sch√∂n, wenn wir die LED einfach Rot pulsieren lassen k√∂nnten. Dazu m√ºssen wir n√§mlich nur den Rot-Kanal und nicht alle drei Kan√§le der LED ansteuern. Gleichzeitig lernen wir schon hier ein Problem kennen, das uns in der Programmierung h√§ufig begegnet und f√ºr das es eine elegante L√∂sung gibt.\n\n1.3.1 Abz√§hlbare Wiederholungen\nWas bedeutet es, die LED pulsieren zu lassen? Und was m√ºssen wir daf√ºr tun? Pulsieren bedeutet, dass die LED √ºber einen kurzen Zeitraum immer heller wird, kurz in der vollen Helligkeit verweilt und dann sofort wieder kontinuierlich dunkler wird. Sobald sie schwarz ist, f√§ngt der Zyklus von vorne an.\nDen Ausdruck immer heller werden k√∂nnen wir bezogen auf die LED so √ºbersetzen, dass wir den Anteil des Rot-Kanals schrittweise erh√∂hen. Wenn die LED zu Beginn aus ist, also alle Kan√§le auf 0 stehen, k√∂nnen wir den Rot-Kanal von 0 auf 255 erh√∂hen und so die LED immer heller in Rot aufleuchten lassen.\nWir beginnen also mit einer schwarzen LED:\n\nled.set_rgb_value(0, 0, 0)\n\nAnschlie√üend setzen wir den Wert f√ºr Rot auf 1:\n\nled.set_rgb_value(1, 0, 0)\n\nUnd erh√∂hen ihn schrittweise:\n\nled.set_rgb_value(2, 0, 0)\nled.set_rgb_value(3, 0, 0)\nled.set_rgb_value(4, 0, 0)\n# ...\n\nWenn wir nach diesem Muster fortfahren, h√§tten wir bis zum vollen Rot 255 Zeilen Code geschrieben, eine Zeile f√ºr jeden Erh√∂hungsschritt. Und anschlie√üend das Gleiche nochmal r√ºckw√§rts, damit wir wieder zu Schwarz kommen. Mit 510 Zeilen Code h√§tten wir dann einen Pulsierungszyklus durchlaufen. Wollen wir die LED √∂fter pulsieren lassen, vervielfacht sich unser Code entsprechend. Das kann nicht die L√∂sung f√ºr ein so einfaches Problem sein.\nUnd tats√§chlich gibt es in der Programmierung eine bessere M√∂glichkeit, um sich wiederholende Abl√§ufe abzubilden: die Schleife. In einem Fall, bei dem wir genau wissen, wie oft wir etwas wiederholen wollen, bietet sich eine Z√§hlerschleife an:\n\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n\nVoil√†! Unsere 510 Zeilen Code k√∂nnen wir mit einer Schleife auf zwei Zeilen reduzieren! Dazu m√ºssen wir im Kopf der Schleife (for ... in ...) festlegen, wie oft der einger√ºckte Codeblock nach dem Doppelpunkt ausgef√ºhrt werden soll. In Python funktioniert das √ºber die Angabe einer Folge, f√ºr die jedes Element einmal durchlaufen wird. Das aktuelle Element ist in der Schleife als r verf√ºgbar. Und r nimmt nacheinander jeden Wert der Folge an, die nach dem Schl√ºsselwort in folgt. Diese Folge erzeugt hier die Funktion range(256), die ‚Äì wie der Name preisgibt ‚Äì eine Zahlenfolge von 0 bis zum angegebenen Wert minus eins erzeugt. In unserem Fall also von 0 bis 255.\nUm das besser nachvollziehen zu k√∂nnen, geben wir den Wert f√ºr r einfach mal aus:\n\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n1    print(r)\n\n\n1\n\nMit print() geben wir einen Wert auf der Konsole aus.\n\n\n\n\nJetzt wird es deutlich: Mit jedem Durchlauf der Schleife wird ein neuer Wert f√ºr r gesetzt und ausgegeben. Und zwar jeweils um eins erh√∂ht. Die Funktion range(256) erzeugt genau gesagt eine sortierte Reihe mit den Zahlen von 0 bis 255. Das sieht in Python dann so aus:\n\nlist_of_numbers = range(256)\n1print(list(list_of_numbers))\n\n\n1\n\nMit der list()-Funktion wandeln wir die von range() erzeugte Folge in eine Liste um, die wir dann ausgeben k√∂nnen.\n\n\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]\n\n\nR√ºckw√§rts erreichen wir das gleiche Ergebnis mit einer weiteren Schleife, deren Folge wir umkehren, sodass sie von 255 bis 0 geht:\n\nfor r in range(255, -1, -1):\n    led.set_rgb_value(r, 0, 0)\n\nWarum hat range() auf einmal drei Argumente? Ganz einfach: Standardm√§√üig erstellt die Funktion eine Folge von 0 bis zur angegebenen Zahl minus eins. Wir k√∂nnen die Folge aber beeinflussen, indem wir einen Startwert und einen Schrittwert angeben. In unserem Fall oben beginnen wir bei 255 (erster Parameter) und gehen bis -1 (zweiter Parameter), wobei wir in jedem Schritt um -1 verringern (dritter Parameter). Warum z√§hlen wir bis -1, wo wir doch eigentlich die 0 als kleinste Zahl ben√∂tigen? Das liegt daran, dass die Folge von range() immer bis zum zweiten Parameter minus eins geht. Wenn wir also 0 als kleinste Zahl ben√∂tigen, m√ºssen wir bis -1 z√§hlen.\nFassen wir unsere Erkenntnis zusammen und lassen die LED pulsieren:\n\nimport time\n\n# Increase red step by step\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n    time.sleep(0.001)\n\n# Stay at full brightness for a bit\ntime.sleep(0.25)\n\n# Decrease red step by step\nfor r in range(255, -1, -1):\n    led.set_rgb_value(r, 0, 0)\n    time.sleep(0.001)\n\nSoweit bekannt? Fast ‚Äì eine kleine Neuerung habe ich gerade eingebaut, n√§mlich die Funktion time.sleep(). Diese Funktion pausiert das Programm f√ºr die angegebene Zeit in Sekunden. In unserem Fall pausieren wir f√ºr 0,001 Sekunden, also 1 Millisekunde. Dadurch wird die LED langsamer heller und dunkler, was den Puls-Effekt verst√§rkt. Ohne diese Pause w√ºrde die LED so schnell aufleuchten, dass es f√ºr das menschliche Auge nicht mehr wahrnehmbar w√§re. Tats√§chlich w√ºrden wir auch die Hardware √ºberfordern, weil die LED gar nicht so schnell die Farbe wechseln kann. Das Programm w√ºrde abst√ºrzen.\nAm H√∂hepunkt warten wir erneut ‚Äì dieses Mal eine Viertelsekunde ‚Äì, bevor wir die LED langsam ausgehen lassen und den Rotanteil schrittweise wieder auf Null setzen. Dann endet unser Programm, leider viel zu fr√ºh. Die LED soll doch eigentlich weiter pulsieren, bis ‚Ä¶ ja, bis wann √ºberhaupt?\n\n\n1.3.2 Bedingte Wiederholungen\nBeim L√∂sen von Problemen sto√üen wir h√§ufig auf Situationen, in denen wir bestimmte Schritte wiederholt ausf√ºhren m√∂chten, aber nur unter bestimmten Bedingungen. Hier kommen bedingte Wiederholungen ins Spiel, die es uns erm√∂glichen, Schleifen zu erstellen, die nur dann fortgesetzt werden, wenn eine bestimmte Bedingung noch erf√ºllt ist.\nDas k√∂nnen wir auf unsere pulsierende LED anwenden. Sie soll ihren Pulsierzyklus Dunkel‚ÄìHell‚ÄìDunkel wiederholen, solange der Benutzer nicht unterbricht. Das ist zumindest ein pragmatisches Abbruchkriterium f√ºr unseren Fall. Wir definieren also hier keine feste Anzahl Wiederholungen wie bei der for ... in-Schleife, sondern wir wollen festlegen, unter welcher Bedingung die Schleife fortgesetzt wird. Wir k√∂nnten also sagen: solange die Bedingung X erf√ºllt ist, wiederhole die aufgef√ºhrten Schritte. Und weil Programmiersprachen f√ºr Menschen gemacht sind, klingt es im echten Programm auch so √§hnlich:\n\nwhile 1==1:\n    print(\"This condition is always true\")\n    time.sleep(1)\n\nDas Schl√ºsselwort while f√ºhrt eine bedingte Schleife ein, gefolgt von der Bedingung, die die Schleife steuert. Die Bedingung wird vor jedem neuen Schleifendurchlauf gepr√ºft (auch vor dem ersten) und sollte sie falsch (false) sein, wird die Schleife beendet.\nWann wird die Schleife oben also beendet? Richtig ‚Äì niemals. Die Bedingung 1==1 ist immer wahr, die Schleife l√§uft somit endlos. Wir sprechen auch von einer Endlosschleife, die wir in der Programmierung unbedingt vermeiden wollen, es sei denn, sie ist explizit gewollt und nicht versehentlich entstanden. Das kurze Programm oben schreibt also in Abst√§nden von einer Sekunde den Text ‚ÄúThis condition is always true‚Äù auf die Konsole.\nEine Bedingung ist in Python und anderen Programmiersprachen ein wichtiges Konzept, das es uns erm√∂glicht, Entscheidungen zu treffen und den Programmfluss zu steuern. In unserem Fall k√∂nnte die Bedingung lauten: solange der Benutzer nicht stoppt, wiederhole den Pulsierzyklus. Eine Bedingung hat die Eigenschaft, dass sie jederzeit ausgewertet werden kann und entweder den Wert wahr (true) oder falsch (false) annimmt. Wie aber dr√ºcken wir das in Python aus?\n\nwhile True:\n    print(\"I will loop forever\")\n    time.sleep(1)\n\nDie einfachste M√∂glichkeit ist es, das Ergebnis der Evaluation direkt hinzuschreiben. Die obige Schleife pr√ºft in jedem Durchgang, ob der Wert True wahr ist - was er nat√ºrlich ist. Das ist also so √§hnlich wie bei der Schleife weiter oben, die die Bedingung 1==1 gepr√ºft hat. Die ist ebenfalls immer True oder wahr.\nWir lernen im Laufe des Buches noch viele echte Bedingungen kennen, deren Ergebnis nicht von Vornherein bekannt ist. F√ºr unsere pulsierende LED reicht es aber aus, wenn wir eine gewollte Endlosschleife verwenden. Denn auch eine Endlosschleife k√∂nnen wir jederzeit verlassen, indem wir das Programm mit der Tastenkombination Strg+C abbrechen.\nWenn wir jetzt unseren Pulsierzyklus von oben in die neue bedingte while-Schleife einf√ºgen, sind wir schon am Ziel. Der Pulsierzyklus wird wiederholt, solange das Programm nicht abgebrochen wird:\n\nwhile True:\n\n    # Increase red step by step\n    for r in range(256):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, -1, -1):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)\n\nDer Vollst√§ndigkeit halber das Ganze inklusive des Boilerplate-Codes f√ºr die Verbindung zu den Tinkerforge-Ger√§ten:\n\n\n\n\nListing¬†1.2: Das fertige Programm, das die LED rot pulsieren l√§sst.\n\n\nimport time\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn LED off initially\nled.set_rgb_value(0, 0, 0)\n\nwhile True:\n\n    # Increase red step by step\n    for r in range(256):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, -1, -1):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-hue-circle",
    "href": "colors.html#sec-colors-hue-circle",
    "title": "1¬† Farben",
    "section": "1.4 Farbkreise",
    "text": "1.4 Farbkreise\nDas RGB-Farbschema ist f√ºr Computer optimal, weil sich damit mit nur drei Zahlen jede beliebige Farbe kodieren l√§sst. Zahlen sind schlie√ülich die Sprache, mit der Computer am besten umgehen k√∂nnen. F√ºr uns Menschen ist dieses Schema jedoch weniger intuitiv. Oder k√∂nntet ihr auf Anhieb sagen, welche Farbe hinter der Kombination (67, 201, 182) steckt?\nUm Farben f√ºr uns leichter w√§hlbar zu machen, wurde der sogenannte Hue-Farbkreis entwickelt. Er ordnet die Farben auf einer Skala von 0 bis 360 Grad an ‚Äì √§hnlich wie die Winkel auf einem Kreis. Neben dem Farbton (Hue) lassen sich zus√§tzlich die S√§ttigung und die Helligkeit einstellen: Der Farbton bestimmt die eigentliche Farbe, die S√§ttigung, wie kr√§ftig oder blass sie wirkt, und die Helligkeit, wie hell oder dunkel sie erscheint.\n\n\n\n\n\n\nAbbildung¬†1.8: Die Farbauswahl in Google Slides funktioniert √ºber den Hue-Farbkreis.\n\n\n\nIn Abbildung¬†1.8 seht ihr, wie die Farbauswahl in Google Slides funktioniert. Mit dem Slider in der Mitte bestimmt ihr den Farbton. Habt ihr einen passenden Ton gefunden, k√∂nnt ihr im Rechteck dar√ºber durch Verschieben des kleinen Kreises die S√§ttigung und Helligkeit anpassen.\nBeobachtet ihr dabei die RGB-Werte, erkennt ihr die Systematik der Farbton-Skala: Ausgehend von reinem Rot wird Schritt f√ºr Schritt Gr√ºn hinzugef√ºgt ‚Äì so entstehen Orange und Gelb. Danach nimmt der Rotanteil ab, w√§hrend Blau hinzukommt. √úber Cyan gelangen wir zu reinem Blau. Schlie√ülich wird wieder Rot beigemischt, wodurch Violett bis Pink entstehen. Auf diese Weise bildet der Kreis den gesamten Regenbogen ab.\nDa die Skala am Ende wieder bei Rot ankommt, l√§sst sich der Farbverlauf nahtlos wiederholen ‚Äì ohne harte √úberg√§nge. Genau deshalb wird der Hue-Verlauf meist als Kreis dargestellt.\n\n\n\n\n\n\nAbbildung¬†1.9: Der Hue-Farbkreis mit HSV-Werten.\n\n\n\nAbbildung¬†1.9 zeigt den Hue-Farbkreis im HSV-Modell. HSV steht f√ºr Hue, Saturation, Value (Farbton, S√§ttigung, Helligkeit). Der Wert Value gibt die Helligkeit auf einer Skala von 0 bis 100‚ÄØ% an. Im Bild ist die Helligkeit konstant bei 100‚ÄØ%, w√§hrend die S√§ttigung von innen nach au√üen zunimmt. In der Mitte sehen wir deshalb Wei√ü, w√§hrend am √§u√üeren Rand die Farben ihre volle Intensit√§t haben.\nWenn wir ein Programm schreiben, das die gesamte Hue-Farbskala durchl√§uft und die LED jeweils in der passenden Farbe aufleuchten l√§sst, erhalten wir unser Regenbogenprogramm. Da die LED RGB-Werte ben√∂tigt, m√ºssen wir den Verlauf des Hue-Farbkreises in RGB umsetzen. Ein Blick auf die Animation in Abbildung¬†1.8 hilft: Der Farbverlauf l√§sst sich in sechs Phasen unterteilen, wie Abbildung¬†1.10 zeigt:\n\nRot = 255, Blau = 0, Gr√ºn steigt linear\nRot sinkt linear, Gr√ºn = 255, Blau = 0\nRot = 0, Gr√ºn = 255, Blau steigt linear\nRot = 0, Gr√ºn sinkt linear, Blau = 255\nRot steigt linear, Gr√ºn = 0, Blau = 255\nRot = 255, Gr√ºn = 0, Blau sinkt linear\n\nDann beginnt der Zyklus von vorn.\n\n\n\n\n\n\nAbbildung¬†1.10: Der Hue-Farbverlauf mit den Ver√§nderungen der RGB-Werte (Quelle: Ronja‚Äôs Tutorials).",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-rainbow-led",
    "href": "colors.html#sec-colors-rainbow-led",
    "title": "1¬† Farben",
    "section": "1.5 Regenbogen-LED",
    "text": "1.5 Regenbogen-LED\nMit dem Wissen k√∂nnen wir uns an das erkl√§rte Ziel unseres Experiments machen: die LED nacheinander in allen Farben des Regenbogens aufleuchten zu lassen. Beginnen wir mit der ersten Phase und schreiben daf√ºr ein Python-Programm:\n\nfor green in range(256):\n    led.set_rgb_value(255, green, 0)\n    time.sleep(0.01)\n\nWeil wir genau wissen, wie oft wir die Schleife durchlaufen wollen, verwenden wir eine for-Schleife. Innerhalb der Schleife erh√∂hen wir die Variable green jeweils um 1, was effektiv den Gr√ºnanteil unseres RGB-Wertes erh√∂ht. Mit jedem Durchlauf f√ºgen wir somit mehr Gr√ºn hinzu, w√§hrend Rot und Blau konstant bleiben. Phase 1 ist damit abgeschlossen ‚Äì machen wir weiter mit Phase 2:\n\nfor red in range(255, -1, -1):\n    led.set_rgb_value(red, 255, 0)\n    time.sleep(0.01)\n\nWie wir mit einer for-Schleife r√ºckw√§rts z√§hlen, haben wir schon weiter oben kennengelernt. In Phase 2 verringern wir schrittweise den Rotanteil, w√§hrend die anderen beiden Farben konstant bleiben. Damit kommen wir zu Phase 3:\n\nfor blue in range(256):\n    led.set_rgb_value(0, 255, blue)\n    time.sleep(0.01)\n\nIch glaube, ihr habt das Prinzip verstanden. Indem wir die sechs Phasen jeweils in einer eigenen Schleife abarbeiten, erhalten wir das vollst√§ndige Regenbogenprogramm:\n\n# phase 1\nfor green in range(256):\n    led.set_rgb_value(255, green, 0)\n    time.sleep(0.01)\n\n# phase 2\nfor red in range(255, -1, -1):\n    led.set_rgb_value(red, 255, 0)\n    time.sleep(0.01)\n\n# phase 3\nfor blue in range(256):\n    led.set_rgb_value(0, 255, blue)\n    time.sleep(0.01)\n\n# phase 4\nfor green in range(255, -1, -1):\n    led.set_rgb_value(0, green, 255)\n    time.sleep(0.01)\n\n# phase 5\nfor red in range(256):\n    led.set_rgb_value(red, 0, 255)\n    time.sleep(0.01)\n\n# phase 6\nfor blue in range(255, -1, -1):\n    led.set_rgb_value(255, 0, blue)\n    time.sleep(0.01)\n\nWie sch√∂n üåà Eine Sache fehlt aber noch.\n\n1.5.1 Runde f√ºr Runde\nDer Regenbogen soll am Ende wieder von vorne beginnen. Wie schon beim Pulsieren der Farben k√∂nnen wir auch hier eine while-Schleife verwenden und die Phasen kontinuierlich abspielen ‚Äì solange, bis der Benutzer die Escape-Taste dr√ºckt:\n\nwhile True:\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(0.01)\n\n    # phase 2\n    for red in range(255, -1, -1):\n        led.set_rgb_value(red, 255, 0)\n        time.sleep(0.01)\n\n    # phase 3\n    for blue in range(256):\n        led.set_rgb_value(0, 255, blue)\n        time.sleep(0.01)\n\n    # phase 4\n    for green in range(255, -1, -1):\n        led.set_rgb_value(0, green, 255)\n        time.sleep(0.01)\n\n    # phase 5\n    for red in range(256):\n        led.set_rgb_value(red, 0, 255)\n        time.sleep(0.01)\n\n    # phase 6\n    for blue in range(255, -1, -1):\n        led.set_rgb_value(255, 0, blue)\n        time.sleep(0.01)\n\nWir haben es fast geschafft! Eine Kleinigkeit wollen wir an unserem Programm noch verbessern.\n\n\n1.5.2 Geschwindigkeit steuern\nVielleicht habt ihr gemerkt, dass die Geschwindigkeit, mit der unsere LED den gesamten Regenbogen einmal durchl√§uft, nicht sehr hoch ist. Ich w√ºrde das gerne beschleunigen. Die Zeit steuern wir √ºber die time.sleep()-Funktion, sodass wir einfach den Wert in jedem Funktionsaufruf verringern k√∂nnten. Das w√§re aber nicht sehr effizient, weil wir ihn an sechs Stellen anpassen m√ºssen. Wenn wir danach merken, dass es zu schnell ist, m√ºssten wir den Wert erneut √ºberall editieren. Das geht einfacher!\nDer Trick liegt darin, den Wert f√ºr die Wartedauer als Variable zu definieren und nur an einer Stelle zu √§ndern.\n\npause_duration = 0.01\nwhile not keyboard.is_pressed('esc'):\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # etc.\n\nSchon besser! Wir gehen aber noch einen Schritt weiter. Statt dieses kleinteiligen Werts f√ºr eine Pause zwischen zwei kleinen Farbver√§nderungen m√∂chte ich die Gesamtdauer f√ºr den Durchlauf eines Regenbogens angeben. Der Wert pause_duration soll dann auf dieser Basis errechnet werden. Dazu m√ºssen wir nur die Anzahl der Pausen insgesamt kennen; in jeder der sechs Phasen sind es 256. Macht also:\n\\[\n6 \\times 256 = 1536\n\\]\nIm Programm setzen wir die Pausendauer also auf die Gesamtdauer in Sekunden geteilt durch 1536:\n\nrainbow_duration = 5\npause_duration = rainbow_duration / 1536\n\nwhile not keyboard.is_pressed('esc'):\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # etc.\n\nUnd schon k√∂nnen wir unseren Regenbogen beliebig zeitlich steuern. Damit sind wir am Ende des Kapitels angekommen. Wir schlie√üen es mit dem vollst√§ndigen Code f√ºr unseren Regenbogenverlauf in Listing¬†1.3 ab. Vergesst nicht, den Wert f√ºr die UID eurer LED anzupassen, damit es auch bei euch funktioniert:\n\n\n\n\nListing¬†1.3: Das fertige Regenbogenprogramm.\n\n\nimport time\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn LED off initially\nled.set_rgb_value(0, 0, 0)\n\nrainbow_duration = 5\npause_duration = rainbow_duration / 1536\n\nwhile True:\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # phase 2\n    for red in range(255, -1, -1):\n        led.set_rgb_value(red, 255, 0)\n        time.sleep(pause_duration)\n\n    # phase 3\n    for blue in range(256):\n        led.set_rgb_value(0, 255, blue)\n        time.sleep(pause_duration)\n\n    # phase 4\n    for green in range(255, -1, -1):\n        led.set_rgb_value(0, green, 255)\n        time.sleep(pause_duration)\n\n    # phase 5\n    for red in range(256):\n        led.set_rgb_value(red, 0, 255)\n        time.sleep(pause_duration)\n\n    # phase 6\n    for blue in range(255, -1, -1):\n        led.set_rgb_value(255, 0, blue)\n        time.sleep(pause_duration)\n\n# Turn LED off\nled.set_rgb_value(0, 0, 0)\n\n\n\n\nSeid ihr bereit f√ºr das n√§chste Experiment?\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "numbers.html",
    "href": "numbers.html",
    "title": "2¬† Zahlen",
    "section": "",
    "text": "Zusammenfassung\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#zusammenfassung",
    "href": "numbers.html#zusammenfassung",
    "title": "2¬† Zahlen",
    "section": "",
    "text": "Wir lernen Kontrollstrukturen kennen, mit denen wir unser Programm steuern k√∂nnen.\nWir verstehen das Bin√§rsystem und wissen, wie der Computer Zahlen speichert.\nWir f√ºhren das Byte als zentrale Informationseinheit im Computer ein.\nWir wissen, wie wir mithilfe von Funktionen besseren Code schreiben.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#experimentaufbau",
    "href": "numbers.html#experimentaufbau",
    "title": "2¬† Zahlen",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\nDas erste Experiment in Kapitel 1 war ein guter Einstieg! In diesem Kapitel legen wir noch eine Schippe drauf: Unsere Hardware bekommt ein neues Bauteil ‚Äì einen Drehknopf (Rotary Encoder Bricklet 2.0). Das montiert ihr einfach neben der LED, wie in Abbildung¬†2.1 gezeigt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Draufsicht.\n\n\n\n\n\n\n\n\n\n\n\n(c) Nahaufnahme des Rotary Encoders.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n(e) Untenansicht.\n\n\n\n\n\n\n\nAbbildung¬†2.1: Einfaches Setup mit einem Mikrocontroller, LED und einem Drehknopf.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-first-steps",
    "href": "numbers.html#sec-numbers-first-steps",
    "title": "2¬† Zahlen",
    "section": "2.1 Erste Schritte mit dem Drehknopf",
    "text": "2.1 Erste Schritte mit dem Drehknopf\nWie bei der LED werfen wir zuerst einen Blick auf den neuen Drehknopf im Brick Viewer. Schlie√üt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Setup-Tab sollte nun neben der LED auch der Rotary Encoder auftauchen. Denkt daran: Dort findet ihr auch die UID eurer Ger√§te ‚Äì die braucht ihr gleich f√ºr euer Programm.\n\n\n\n\n\n\nAbbildung¬†2.2: Der Brick Viewer nach dem Connect.\n\n\n\nWechselt nun in den Tab f√ºr den Drehknopf, wo ihr ihn direkt testen k√∂nnt: Ihr seht den aktuellen Z√§hlwert. Der kann positiv oder negativ sein ‚Äì je nachdem, wie oft und in welche Richtung ihr gedreht habt. Daneben zeigt ein Diagramm die zeitliche Entwicklung.\nDoch der Knopf kann mehr als nur z√§hlen: Ihr k√∂nnt ihn auch dr√ºcken. Achtet mal auf den kleinen Kreis im Brick Viewer. Wird er gedr√ºckt, leuchtet er rot. Noch l√∂st das Dr√ºcken keine Aktion aus, aber wir √ºberlegen sp√§ter, welche Funktion wir damit verbinden wollen.\nUnd zuletzt: der Button Reset Count. Damit setzt ihr den Z√§hler zur√ºck ‚Äì eine praktische Funktion, die wir sp√§ter ebenfalls ins Programm einbauen k√∂nnen.\n\n\n\n\n\n\n\n\nDas Diagramm zeigt den aktuellen Wert an.\n\n\n\n\n\n\n\n\n\n\n(a) Der Button wird rot, wenn er gedr√ºckt ist.\n\n\n\n\n\n\n\nAbbildung¬†2.3: Die Funktionen des Rotary Encoders im Brick Viewer.\n\n\n\nFassen wir zusammen, was unser Drehknopf (Rotary Encoder) draufhat:\n\nEr z√§hlt ‚Äì vorw√§rts und r√ºckw√§rts\nEr merkt, wenn ihr ihn dr√ºckt\nEr kann seinen Z√§hler zur√ºcksetzen\n\nZeit also, das Ganze in Python auszuprobieren und zu sehen, welche coolen Anwendungen wir damit bauen k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#z√§hler-auslesen",
    "href": "numbers.html#z√§hler-auslesen",
    "title": "2¬† Zahlen",
    "section": "2.2 Z√§hler auslesen",
    "text": "2.2 Z√§hler auslesen\nDer Drehknopf funktioniert √§hnlich wie der Lautst√§rkeregler einer Stereoanlage (siehe Abbildung¬†2.4): Dreht ihr nach rechts, wird es lauter ‚Äì nach links, leiser.\n\n\n\n\n\n\nAbbildung¬†2.4: Die gute alte Stereoanlage mit Drehknopf! Wer kennt sie nicht mehr? (Quelle: Wikimedia)\n\n\n\nIm Hintergrund ver√§ndert sich bei jeder Drehung der Wert, den der Knopf sendet ‚Äì mal h√∂her, mal niedriger, je nach Ausgangszustand. Im Brick Viewer habt ihr das schon gesehen. Probieren wir es jetzt in einem Programm aus: Der folgende Code verbindet sich mit dem Drehknopf, liest den aktuellen Wert und gibt ihn in der Konsole aus. Denkt daran, eure eigene UID einzutragen:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\n1knob = BrickletRotaryEncoderV2('WZd', ipcon)\n2count = knob.get_count(reset=False)\nprint(count)\n\n\n1\n\nWir erstellen eine virtuelle Repr√§sentation des Drehknopfs in unserem Programm, um seine Funktionen verwenden zu k√∂nnen.\n\n2\n\n√úber die virtuelle Repr√§sentation des Drehknopfs k√∂nnen wir mittels get_count() den aktuellen Wert abfragen. Der Parameter reset bestimmt, ob der Z√§hler nach dem Auslesen zur√ºckgesetzt werden soll oder nicht.\n\n\n\n\nDie Ausgabe sollte mit dem Wert √ºbereinstimmen, den ihr auch im Brick Viewer seht ‚Äì kein Wunder, beide nutzen dieselbe Programmierschnittstelle. Damit habt ihr die erste Funktion des Drehknopfs erfolgreich aus Python getestet.\nDreht ihr den Knopf und startet das Programm erneut, erscheint nat√ºrlich ein anderer Wert. Klar! Aber jedes Mal neu starten? Das geht besser. Die L√∂sung kennt ihr schon aus Kapitel 1: eine Schleife, die das Programm so lange wiederholt, bis wir es beenden:\n\nwhile True:\n    count = knob.get_count(reset=False)\n    print(count)\n\nZur Erinnerung: while True erzeugt eine Endlosschleife. Normalerweise wollen wir so etwas vermeiden ‚Äì au√üer, wir brauchen es genau daf√ºr. Endlosschleifen sind praktisch, wenn wir kontinuierlich Daten lesen oder auf Ereignisse warten. Und keine Sorge: Mit Strg+C k√∂nnt ihr das Programm jederzeit beenden.\nWenn ihr das Programm ausf√ºhrt, werdet ihr direkt ein Problem erkennen. Die Schleife rennt f√∂rmlich und gibt nacheinander immer wieder denselben Wert aus. Nur wenn wir am Knopf drehen, √§ndert sich der Wert ‚Äì wird aber von der Schleife x-mal auf die Konsole geschrieben. Wie k√∂nnten wir das verbessern?",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-control-structures",
    "href": "numbers.html#sec-numbers-control-structures",
    "title": "2¬† Zahlen",
    "section": "2.3 Kontrollstrukturen",
    "text": "2.3 Kontrollstrukturen\nWie w√§re es hiermit?\n\nlast_count = None\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n        print(last_count)\n\nGehen wir durch, was hier passiert: Zuerst weisen wir der Variable last_count vor dem ersten Schleifendurchlauf den Wert None zu. Anschlie√üend wird in jedem Durchlauf der aktuelle Z√§hlerstand ausgelesen und in der Variable new_count gespeichert. Danach pr√ºfen wir, ob sich der neue Wert im Vergleich zum alten unterscheidet. Da last_count im ersten Durchlauf None ist, wird die Bedingung in Zeile 5 beim Start immer True sein. Somit geben wir den Wert zu Beginn auf jeden Fall aus ‚Äì genau so, wie es f√ºr die Anwendung sinnvoll ist.\nIn den folgenden Schleifendurchl√§ufen wird nur dann etwas ausgegeben, wenn sich der Wert ver√§ndert hat, ihr also tats√§chlich am Drehknopf gedreht habt. Ansonsten bleibt die Ausgabe unver√§ndert.\nDie Pr√ºfung, ob der aktuelle Wert (gespeichert in new_count) sich vom alten Wert unterscheidet, erfolgt in Zeile 5. Hier lernen wir auch ein neues Konzept der Programmierung kennen: die Kontrollstruktur if, gefolgt von einer Bedingung.\nNeu ist hier die Kontrollstruktur if. Sie pr√ºft eine Bedingung, die ‚Äì wie ihr schon aus Kapitel 1 kennt ‚Äì nur True oder False sein kann. Ist sie wahr (True), l√§uft der einger√ºckte Code darunter. Ist sie falsch (False), passiert nichts.\n√úbertragen auf unser Programm hei√üt das: print(last_count) l√§uft nur dann, wenn sich der Wert tats√§chlich ver√§ndert hat. In diesem Fall merken wir uns den neuen Wert und aktualisieren last_count. Beim n√§chsten Schleifendurchlauf pr√ºfen wir wieder, ob sich etwas getan hat. Meistens ist das nicht so ‚Äì und genau deshalb sehen wir nur dann eine Ausgabe, wenn wir wirklich am Knopf drehen. Ziemlich effizient, oder?",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#led-dimmer-1.0",
    "href": "numbers.html#led-dimmer-1.0",
    "title": "2¬† Zahlen",
    "section": "2.4 LED-Dimmer 1.0",
    "text": "2.4 LED-Dimmer 1.0\nWenden wir das Gelernte an und bauen einen praktischen LED-Dimmer. Daf√ºr holen wir unsere LED aus Kapitel 1 mit dazu und kombinieren sie mit dem Drehknopf.\nDie Idee ist simpel: Der Z√§hler des Knopfs steuert die Helligkeit der LED. Dreht ihr nach rechts, wird sie heller, nach links, dunkler. Wie bei der Stereoanlage in Abbildung¬†2.4.\nBevor wir uns an die eigentliche Anwendungslogik machen, brauchen wir Zugriff auf beide Ger√§te ‚Äì LED und Drehknopf. Dazu erweitern wir den bekannten Boilerplate-Code und speichern die Ger√§te in eigenen Variablen:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nknob = BrickletRotaryEncoderV2('WZd', ipcon) \nled = BrickletRGBLEDV2('ZG1', ipcon)\n\nDieser Teil muss immer am Anfang unseres Programms stehen, damit alles funktioniert. In den kommenden Beispielen setzen wir ihn als gegeben voraus und wiederholen ihn nicht jedes Mal.\nAls Startpunkt nehmen wir den Code von oben, der den Z√§hlerwert auf der Konsole ausgibt. Schlie√ülich brauchen wir genau diese Information ‚Äì wann sich der Wert √§ndert und wie er aktuell steht ‚Äì auch, um die LED zu steuern.\nDamit wir die LED von aus bis volle Helligkeit dimmen k√∂nnen, legen wir uns zuerst auf eine Farbe fest. Ich bin zwar kein Fan von wei√üem LED-Licht, aber f√ºr dieses Kapitel ist es am einfachsten: voll aufgedreht leuchtet die LED wei√ü, ausgedreht ist sie schwarz ‚Äì klar! Sp√§ter k√ºmmern wir uns darum, wie wir das Licht w√§rmer machen k√∂nnen.\nErinnern wir uns also: Was bedeuten die Zust√§nde An und Aus im RGB-Farbraum?\n\n# White\nled.set_rgb_value(255, 255, 255)\n\n# Black (off)\nled.set_rgb_value(0, 0, 0)\n\nDamit haben wir die beiden Extremzust√§nde festgelegt. Doch was passiert dazwischen, wenn die LED gedimmt ist? Ganz einfach: Wir lassen die drei RGB-Werte gemeinsam von 1 bis 254 hoch- oder runterlaufen. H√∂here Werte ergeben ein helleres Wei√ü, niedrigere ein dunkleres.\nSetzen wir diese Erkenntnisse in Programmcode um und weisen den Z√§hlerwert den RGB-Werten der LED zu. Spoiler-Alert: Das ist etwas naiv, aber lasst uns mal schauen, was passiert und wo m√∂glicherweise Probleme auftreten:\n\nknob.reset()\nlast_count = 0\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n        print(last_count)\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(last_count, last_count, last_count)\n\nLasst es mal laufen und dreht voll auf oder runter! Beobachtet dabei den Wert f√ºr last_count. Was passiert, wenn er kleiner als Null wird? Oder wenn er gr√∂√üer als 255 wird? Bumm! Das Programm st√ºrzt ab!\nWarum? Auf der Kommandzeile bekommen wir eine lange Fehlermeldung mit der folgenden Aussage ganz am Ende:\n#| code-line-numbers: false\nstruct.error: ubyte format requires 0 &lt;= number &lt;= 255\nWenn man die Fehlermeldung googelt oder ChatGPT befragt, bekommt man Hilfe. Offensichtlich wird f√ºr einen RGB-Wert, den wir der Funktion set_rgb_value() √ºbergeben, ein bestimmter Datentyp erwartet, der ubyte hei√üt. Das steht f√ºr ‚Äúunsigned byte‚Äù und bedeutet, dass der Wert zwischen 0 und 255 liegen muss.\nMoment üßê ‚Äì was hat jetzt das Byte mit 0 bis 255 zu tun? Bisher dachten wir doch, das w√§re wegen des RGB-Codes? Stimmt auch, aber der RGB-Code liegt nicht zuf√§llig im Wertebereich von 0 bis 255.\nUm das zu verstehen, m√ºssen wir das Bin√§rsystem kennen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#zahlensysteme",
    "href": "numbers.html#zahlensysteme",
    "title": "2¬† Zahlen",
    "section": "2.5 Zahlensysteme",
    "text": "2.5 Zahlensysteme\nEigentlich ist es schnell erkl√§rt. Das Bin√§rsystem ist wie das Dezimalsystem, mit dem wir allt√§glich unterwegs sind ‚Äì nur nutzt es statt der Basis 10 die Basis 2. Einfach, oder? Wenn nicht, lest weiter ‚Äì das hier soll schlie√ülich ein Einf√ºhrungsbuch sein.\n\n2.5.1 Unser Dezimalsystem\nWir wenden das Dezimalsystem t√§glich intuitiv an. Es fragt sich wahrscheinlich niemand von euch, was die Systematik dahinter ist, oder? Und doch habt ihr es alle einmal in der Schule gelernt, und wir m√ºssen es an dieser Stelle etwas auffrischen. Solltet ihr mit Stellenwertsystemen noch 100 % vertraut sein, k√∂nnt ihr diesen Abschnitt getrost √ºberspringen.\nNehmen wir eine Zahl wie die 123 als Beispiel. Wir haben sofort ein Gef√ºhl f√ºr die Zahl, wir wissen etwa, wie gro√ü sie ist. Und wenn wir es etwas genauer erkl√§ren m√ºssen, k√∂nnen die meisten von euch sicher erl√§utern, wof√ºr ‚Äì also f√ºr welchen Wert ‚Äì jede Ziffer steht. Wir beginnen mit der kleinsten Wertigkeit, also der Ziffer ganz rechts: der 3. Sie steht f√ºr die Einserstelle, und davon haben wir 3. Die n√§chste Stelle steht f√ºr die Zehner, und weil dort eine 2 steht, sind es zwanzig. Also \\(3+20=23\\). Schlie√üen wir auch die dritte und letzte Ziffer in unsere Erl√§uterung ein: Die 1 steht f√ºr die Hunderterstelle, also \\(1*100=100\\). Damit haben wir \\(100+20+3=123\\). Ganz einfach und intuitiv.\n\n\n\n\n\n\n\n\n\n\n\n(a) Im Dezimalsystem hat jede Stelle einen anderen Wert.\n\n\n\n\n\n\n\n\n\n\n\n(b) Durch Ausmultiplizieren errechnen wir den Wert der Zahl.\n\n\n\n\n\n\n\nAbbildung¬†2.5: Das Dezimalsystem ist ein Stellenwertsystem.\n\n\n\nDas Ganze funktioniert nicht nur mit dreistelligen Zahlen, sondern prinzipiell mit beliebig langen Zahlen. Wir wissen, dass die n√§chste Ziffer, die wir links im Beispiel in Abbildung¬†2.6 sehen, f√ºr die Tausenderstelle steht. Die n√§chste Stelle w√ºrde f√ºr die Zehntausenderstelle stehen ‚Äì und so weiter. Warum f√§llt es uns so leicht?\nErstens, weil wir damit jeden Tag umgehen. Das Dezimalsystem ist das System, das wir am h√§ufigsten verwenden, und wir haben es von klein auf gelernt. Es ist intuitiv und einfach zu verstehen. Zweitens aber auch, weil wir die Systematik kennen: Jede Stelle ist 10-mal so viel wert wie die vorherige.\n\n\n\n\n\n\nAbbildung¬†2.6: Jede Stelle steht f√ºr eine h√∂here Potenz der Basis 10.\n\n\n\nWurde uns das Dezimalsystem von Gott gegeben? Vielleicht ‚Äì wenn man an die Sch√∂pfung glaubt1 und daran, dass Gott uns so geschaffen hat, wie wir sind, dann hat er implizit daf√ºr gesorgt, dass wir dezimal denkende Wesen werden. Warum? Eine Theorie besagt, dass die menschliche Anatomie, insbesondere die Anzahl der Finger, einen Einfluss auf unser Zahlensystem hatte. Z√§hlt einfach mal anhand eurer Finger durch.\n\n\n2.5.2 Das Oktalsystem\nNun gibt es auch Wesen mit weniger als zehn Fingern (und auch mit mehr?). Nehmt mal einen Cartoon-Charakter wie Mickey Mouse als Beispiel. In Abbildung¬†2.7 seht ihr, wie hier wahrscheinlich gez√§hlt wird. H√§tte ein Volk von Mickey-M√§usen sich auch f√ºr das Dezimalsystem entschieden?\n\n\n\n\n\n\nAbbildung¬†2.7: Cartoon-Charaktere haben nur acht Finger. Quelle: Erstellt mit ChatGPT nach Petzold (2022)\n\n\n\nVermutlich nicht!\n\n\n\n\n\n\nAbbildung¬†2.8: Das Oktalsystem funktioniert wie das Dezimalsystem. Nur die Basis ist 8 statt 10.\n\n\n\n\n\n2.5.3 Das Bin√§rsystem\nTreiben wir es noch ein wenig weiter auf die Spitze und nehmen ein paar Finger weg ‚Äì sagen wir bis auf zwei. Dann w√§ren wir vielleicht bei einem Delfin mit zwei Flossen, wie ihr ihn in Abbildung¬†2.9 seht. Delfine haben sich vermutlich auf ein System geeinigt, das auch f√ºr unsere heutigen Computer die Grundlage darstellt: das Bin√§rsystem.\n\n\n\n\n\n\nAbbildung¬†2.9: Delfine w√ºrden anders z√§hlen. Eher wie Computer.\n\n\n\nDas Wort ‚Äúbin√§r‚Äù stammt aus dem Lateinischen und bedeutet ‚Äúpaarweise‚Äù oder ‚Äúzu zweit‚Äù. Von diesem Wort stammt auch der Name des Stellenwertsystems mit der Basis 2 ‚Äì und das nicht ohne Grund. Im Bin√§rsystem gibt es f√ºr jede Stelle genau zwei M√∂glichkeiten: 0 oder 1. Ein anderer Begriff ist √ºbrigens Dualsystem, was genau das Gleiche meint. Auch das Wort ‚Äúdual‚Äù kommt von den R√∂mern und hei√üt so viel wie ‚Äúzwei enthaltend‚Äù.\n\n\n\n\n\n\nAbbildung¬†2.10: Eine Bin√§rziffer ist vergleichbar mit einem Lichtschalter, der an oder aus sein kann.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nAbbildung¬†2.11: Das Bin√§rsystem funktioniert wie alle anderen Stellenwertsysteme auch.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#bits-bytes",
    "href": "numbers.html#bits-bytes",
    "title": "2¬† Zahlen",
    "section": "2.6 Bits & Bytes",
    "text": "2.6 Bits & Bytes\n\n2.6.1 Zwei Zust√§nde\nWarum haben wir uns Zahlensysteme angeschaut, und was hat das mit Computern zu tun? Ganz einfach: Computer denken bin√§r. Das bedeutet, sie kennen nur zwei Zust√§nde: an oder aus, 0 oder 1.\nWir kommen sp√§ter noch einmal ausf√ºhrlich darauf zur√ºck, aber so viel schon vorweg: Eine Bin√§rziffer nennen wir im Englischen ‚Äúbinary digit‚Äù, kurz ‚Äúbit‚Äù. Jetzt klingelt es, oder?\nEin Bit ist eine Informationseinheit. Nicht irgendeine, sondern die kleinste, die es gibt. Die Erkl√§rung, warum das so ist, folgt sp√§ter. Wir wollen uns an dieser Stelle die Frage stellen, was wir mit einem Bit alles anstellen k√∂nnen.\nEin Bit ist alleine ziemlich einsam und eingeschr√§nkt. Wenn sich ein Computer mit einem Bit lediglich merken kann, ob eine Lampe an oder aus ist, dann sind das genau zwei M√∂glichkeiten. Nicht besonders viel. Wir kamen aber von den Farben √ºber Zahlensysteme zu den Bits ‚Äì und unsere urspr√ºngliche Frage war, wie ein Computer mit seinen Mitteln ‚Äì also Nullen und Einsen (oder eben Bits) ‚Äì so viele unterschiedliche Farben abbilden und speichern kann. Zwei w√ºrden gerade einmal f√ºr Schwarz/Wei√ü ausreichen.\nIhr ahnt es vielleicht schon: Wir gesellen zum ersten ein zweites Bit hinzu. Und schon k√∂nnen wir vier unterschiedliche Zust√§nde abbilden: 00, 01, 10 und 11. Damit k√∂nnten wir zum Beispiel die Farben Schwarz, Blau, Gr√ºn und Cyan darstellen. Etwas willk√ºrlich (warum gerade diese Farben), aber denkbar.\nWas passiert, wenn wir ein drittes Bit hinzunehmen? Sind es nun sechs Zust√§nde? Nein, es sind acht: 000, 001, 010, 011, 100, 101, 110 und 111. Damit k√∂nnten wir die Farben Schwarz, Blau, Gr√ºn, Cyan, Rot, Magenta, Gelb und Wei√ü darstellen (oder jede andere Kombination, die wir uns w√ºnschen).\nMit jedem zus√§tzlichen Bit k√∂nnen wir also nicht plus zwei mehr Zust√§nde abbilden, sondern wir verdoppeln unsere M√∂glichkeiten. Also m√ºssen wir mal zwei ‚Äì und nicht plus zwei ‚Äì rechnen. Das ist eine gute Nachricht, denn die Anzahl der Farben, die wir mit jedem zus√§tzlichen Bit darstellen k√∂nnen, verdoppelt sich jedes Mal.\nDas halten wir fest, aber schauen wir zur√ºck auf unsere RGB-Farben und die Fehlermeldung, die wir zuletzt bekommen haben. Der Wert f√ºr eine Farbe aus dem RGB-Farbcode muss zwischen 0 und 255 liegen. Wir haben somit inklusive der Null 256 M√∂glichkeiten f√ºr jede der drei RGB-Grundfarben. Wie viele Bits ben√∂tigen wir daf√ºr? Rechnen wir es aus:\n\\[\n\\begin{aligned}\n2^0 &= 1 \\\\\n2^1 &= 2 \\\\\n2^2 &= 4 \\\\\n2^3 &= 8 \\\\\n2^4 &= 16 \\\\\n2^5 &= 32 \\\\\n2^6 &= 64 \\\\\n2^7 &= 128 \\\\\n2^8 &= 256 \\\\\n\\end{aligned}\n\\]\nStopp! \\(2^8 = 256\\), das gen√ºgt uns v√∂llig. Mit 8 Bits k√∂nnen wir somit 256 Zust√§nde abbilden ‚Äì genau passend f√ºr 256 Rot-, Gr√ºn- oder Blauanteile.\n\n\n2.6.2 Acht Bits macht ein Byte\nUnd das ist kein Zufall: 8 Bits sind f√ºr Computer eine besondere Gr√∂√üe. Wir nennen eine Gruppe von 8 Bits ein Byte. Und jetzt d√ºrfte es erneut klingeln.\n\n\n\n\n\n\nAbbildung¬†2.12: Ein Byte k√∂nnt ihr euch vorstellen wie acht Gl√ºhbirnen nebeneinander.\n\n\n\nIn Abbildung¬†2.12 ist ein Byte als Reihe von acht Gl√ºhbirnen dargestellt. Ihr k√∂nnt euch vorstellen, dass Bits mit dem Wert 1 leuchten und Bits mit dem Wert 0 aus sind. Um den Wert zu ermitteln, den das Byte gerade darstellt, k√∂nnt ihr jeder Gl√ºhbirne von rechts nach links die entsprechenden Wertigkeiten der Stellen aus dem Bin√§rsystem zuweisen und die Werte addieren. Stellen, an denen die Gl√ºhbirne leuchtet, werden addiert, die anderen werden ausgelassen (Abbildung¬†2.13). Das Byte im gezeigten Beispiel steht somit f√ºr:\n\\[\n32 + 8 + 1 = 41\n\\]\nWof√ºr steht das Byte, wenn alle Lampen leuchten? Oder anders gefragt: Was ist die gr√∂√üte Zahl, die wir mit einem Byte darstellen k√∂nnen?\n\\[\n128+64+32+16+8+4+2+1 = 255\n\\]\nDie Antwort √ºberrascht uns nicht, denn schlie√ülich haben wir es ja schon herausgefunden: Ein Byte erlaubt uns, Werte zwischen 0 (alle Gl√ºhbirnen aus) und 255 (alle Gl√ºhbirnen an) darzustellen. Insgesamt also 256 M√∂glichkeiten. Somit k√∂nnen wir mit 8 Gl√ºhbirnen die Intensit√§t einer der drei Grundfarben im RGB-Code darstellen.\n\n\n\n\n\n\nAbbildung¬†2.13: Jede Gl√ºhbirne steht f√ºr eine Stelle aus dem Bin√§rsystem.\n\n\n\nDas erkl√§rt auch die Fehlermeldung von oben: Ein Byte kann Werte zwischen 0 und 255 darstellen. Wir haben im Experiment den Drehknopf voll nach oben oder nach unten gedreht, wodurch der Wert entweder gr√∂√üer als 255 oder kleiner als 0 wurde. Und damit ist es kein g√ºltiger Wert im Sinne eines Bytes mehr.\n\n\n2.6.3 Kilo, Mega, Giga\nEin Byte besteht aus 8 Bits. Wenn wir also von Bytes sprechen, reden wir oft auch von Kilobytes, Megabytes, Gigabytes et cetera. Diese Begriffe sind wichtig, um die Gr√∂√üe von Daten zu beschreiben. In Tabelle¬†2.1 seht ihr eine √úbersicht √ºber die verschiedenen Gr√∂√üenordnungen.\n\n\n\nTabelle¬†2.1: Verschiedene Mengeneinheiten f√ºr Bytes und deren ungef√§hre Entsprechung.\n\n\n\n\n\n\n\n\n\n\n\nPotenz (Bytes)\nAusgeschrieben\nBezeichnung (Abk√ºrzung)\nEntspricht ca.\n\n\n\n\n\\(10^3\\)\nTausend\nKilobyte (KB)\nkleine Textdatei\n\n\n\\(10^6\\)\nMillion\nMegabyte (MB)\nDigitales Foto\n\n\n\\(10^9\\)\nMilliarde\nGigabyte (GB)\nFilm (DVD 4,7 GB)\n\n\n\\(10^{12}\\)\nBillion\nTerabyte (TB)\nG√§ngige Festplattenkapazit√§t\n\n\n\\(10^{15}\\)\nBilliarde\nPetabyte (PB)\nSpeichervolumen Rechenzentrum\n\n\n\\(10^{18}\\)\nTrillion\nExabyte (EB)\nInternetverkehr pro Tag\n\n\n\\(10^{21}\\)\nTrilliarde\nZettabyte (ZB)\nDatenbestand weltweit (&gt;100 ZB)\n\n\n\\(10^{24}\\)\nQuadrillion\nYottabyte (YB)\nkeine Entsprechung\n\n\n\n\n\n\nJetzt, da ihr wisst, was mit einem Byte gemeint ist, k√∂nnt ihr eine ungef√§hre Vorstellung f√ºr die Gr√∂√üenordnungen von Datenmengen entwickeln. Die ersten drei Zeilen aus Tabelle¬†2.1 k√∂nnt ihr selbst einmal nachvollziehen. Schaut euch dazu mal eine Textdatei an, notiert deren Gr√∂√üe und rechnet aus, wie viele Gl√ºhbirnen f√ºr die Speicherung gebraucht werden. Denkt daran: Ein Byte entspricht acht Gl√ºhbirnen.\nWir kommen in den sp√§teren Kapiteln immer wieder auf die Bits und Bytes zur√ºck, weil wir in Computern letztlich √ºberall mit diesen Einheiten arbeiten. Es ist somit gut, wenn ihr schon an dieser Stelle ein grundlegendes Verst√§ndnis f√ºr diese Konzepte entwickelt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-led-dimmer-part-2",
    "href": "numbers.html#sec-led-dimmer-part-2",
    "title": "2¬† Zahlen",
    "section": "2.7 Ein LED-Dimmer 2.0",
    "text": "2.7 Ein LED-Dimmer 2.0\nZur√ºck zu unserem eigentlichen Vorhaben. Wir waren gerade dabei, einen Dimmer f√ºr unsere LED zu basteln, als uns die Zahlensysteme dazwischengekommen sind. Daf√ºr haben wir jetzt ein besseres Verst√§ndnis daf√ºr, wie ein Computer Farben sieht ‚Äì n√§mlich als lange Sequenz aus Nullen und Einsen. Und zwar 24 davon, weil jede Grundfarbe ein Byte an Speicher verwendet.\n\n2.7.1 min() und max()\nWas m√ºssen wir also in unserem Programm ver√§ndern, jetzt, da wir wissen, was zuvor das Problem war? Genau! Wir m√ºssen sicherstellen, dass die Werte, die wir an die LED senden, im g√ºltigen Bereich f√ºr ein Byte liegen ‚Äì und zwar zwischen 0 und 255.\n\nknob.reset()\nlast_count = 0\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n\n        # Clamp last_count to valid byte range\n1        last_count = max(0, min(255, last_count))\n\n        print(last_count)\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(last_count, last_count, last_count)\n\n\n1\n\nDie Funktionen min() und max() sorgen daf√ºr, dass der Wert von last_count immer zwischen 0 und 255 bleibt. Wenn last_count kleiner als 0 ist, wird er auf 0 gesetzt. Wenn er gr√∂√üer als 255 ist, wird er auf 255 gesetzt.\n\n\n\n\nDie neue Logik in Zeile 9 hilft uns dabei. Nachdem wir den neuen Wert des Z√§hlers in der Variable last_count gespeichert haben (Zeile 6), wenden wir eine geschickte Kombination der beiden Funktionen max() und min() an, um sicherzustellen, dass der Wert im g√ºltigen Bereich bleibt. Wie funktioniert das genau? Dazu gehen wir die Zeile Schritt f√ºr Schritt durch.\nZun√§chst einmal der Ausdruck min(255, last_count). Die Funktion min() gibt einfach den kleineren der beiden Werte zur√ºck, die ihr √ºbergeben werden. Wenn last_count also gr√∂√üer als 255 ist, wird 255 zur√ºckgegeben. Andernfalls wird last_count zur√ºckgegeben. Das Ergebnis dieser Auswertung ist gleichzeitig der zweite Wert, den wir der Funktion max() √ºbergeben.\nDie Funktion max() macht genau das Gegenteil. Sie gibt den gr√∂√üeren der beiden ihr √ºbergebenen Werte zur√ºck. Zur Auswahl stehen ihr der Wert 0 und das Ergebnis der min()-Funktion. Das bedeutet, dass max() sicherstellt, dass der endg√ºltige Wert von last_count niemals kleiner als 0 ist.\nUnd voil√†! Nach Zeile 9 kann der Wert von last_count nur noch zwischen 0 und 255 liegen. Problem gel√∂st!\nProbiert es am besten direkt aus und dreht mal voll auf! Es sollte nun kein Fehler mehr auftreten.\n\n\n2.7.2 Helligkeit entkoppeln\nVielleicht habt ihr es auch bemerkt, aber so richtig toll funktioniert unser Dimmer immer noch nicht. Zwar erscheint keine Fehlermeldung mehr, wenn wir endlos aufdrehen. Jedoch wird die LED auch nicht gedimmt, wenn wir wieder in die andere Richtung drehen. Der Grund daf√ºr ist einfach: Die Helligkeit der LED h√§ngt in unserem Programm direkt vom Z√§hlerstand des Drehknopfes ab. Wenn der √ºber 255 kommt, wird die Helligkeit zwar auf 255 gedeckelt, der Z√§hler wird aber im Hintergrund trotzdem weiter hochgez√§hlt. Wenn wir die LED wieder dimmen, also einen Helligkeitswert von weniger als 255 erreichen m√∂chten, dann m√ºssen wir zun√§chst mit dem Drehknopf wieder bis unter die 255 kommen.\nViel sch√∂ner w√§re es, wenn wir zwar endlos √ºberdrehen k√∂nnten, aber mit der ersten Drehung in die andere Richtung die Helligkeit der LED sofort verringern. Ein einfacher Weg w√§re, f√ºr den Z√§hlerstand des Drehknopfes analog zu last_count nur Werte zwischen 0 und 255 zu erlauben. Dazu k√∂nnten wir den Z√§hler ‚Äì genau wie last_count ‚Äì manuell auf 0 oder 255 setzen, je nachdem, ob wir gr√∂√üer als 255 oder kleiner als 0 waren. Leider bietet der Drehknopf √ºber seine Programmierschnittstelle keine solche Funktion an. Wir k√∂nnen den Wert zwar auslesen, aber nicht programmatisch ver√§ndern.\nWir m√ºssen also einen Workaround entwickeln. Eine M√∂glichkeit w√§re, die Helligkeit unabh√§ngig vom Z√§hlerstand zu verwalten und daf√ºr eine eigene Variable brightness einzuf√ºhren. Wir k√∂nnten den Wert von brightness dann erh√∂hen oder verringern, wenn wir eine Drehung in die eine oder andere Richtung erkannt haben.\nUm zu erkennen, ob und in welche Richtung der Drehknopf gedreht wurde, k√∂nnen wir die Differenz zwischen dem aktuellen und dem letzten Z√§hlerstand betrachten. Sie gibt uns direkt Aufschluss: Ist die Differenz positiv, wurde der Knopf nach oben gedreht, ist sie negativ, wurde er nach unten gedreht.\n\nknob.reset()\nlast_count = 0\n\n1brightness = 0\nled.set_rgb_value(brightness, brightness, brightness) \n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n2        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n3        brightness += diff\n        brightness = max(0, min(255, brightness))\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(brightness, brightness, brightness)\n\n4        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n1\n\nDie neue Variable brightness zu Beginn mit 0 initialisieren. Die LED soll aus sein.\n\n2\n\nHier ermitteln wir die Differenz zwischen dem aktuellen und dem letzten Z√§hlerstand und speichern sie in der Variable diff.\n\n3\n\nWir passen die Helligkeit an, indem wir brightness um diff erh√∂hen oder verringern. Dabei stellen wir sicher, dass der Wert zwischen 0 und 255 bleibt.\n\n4\n\nZur √úberpr√ºfung geben wir beide Variablen aus. Wenn wir den Wertebereich 0‚Äì255 verlassen, gehen die Werte der beiden Variablen auseinander.\n\n\n\n\n\n\n2.7.3 Konstanten\nDas sieht schon sehr gut aus! Unser Dimmer ist fast fertig, die grundlegende Funktionalit√§t l√§uft robust. Eine Kleinigkeit st√∂rt mich noch: Der Dimmer reagiert nur sehr langsam, und wir m√ºssen scheinbar endlos drehen, um die LED auf die volle Helligkeit zu bekommen. K√∂nnen wir das beschleunigen?\nDas ist nat√ºrlich eine rhetorische Frage ‚Äì in der Programmierung k√∂nnen wir so gut wie alles umsetzen. Und in diesem Fall ist es sogar recht einfach. Damit die LED schneller hell oder dunkel wird, wenn wir am Drehknopf drehen, k√∂nnen wir die Anpassung der Helligkeit einfach verst√§rken. Momentan wird die Variable brightness um die Differenz des Z√§hlerstands erh√∂ht oder verringert. Wir k√∂nnten stattdessen einen festen, h√∂heren Schrittwert definieren, um die Helligkeit schneller zu √§ndern.\nDazu definieren wir eine neue Variable, die eine Besonderheit hat. Wir geben ihr den Namen STEP, der nur aus Gro√übuchstaben besteht (Zeile 3). Gem√§√ü der Regeln f√ºr die Bennung von Variablen in Python werden Namen in GROSSBUCHSTABEN √ºblicherweise f√ºr Konstanten verwendet ‚Äì und tats√§chlich ist STEP genau genommen auch keine Variable, sondern eine Konstante.\nEine Konstante unterscheidet sich dadurch, dass ihr Wert einmal festgelegt wird und sich danach nicht mehr √§ndert. In unserem Fall wollen wir, dass STEP immer den Wert 10 hat. Konstanten definieren wir typischerweise zu Beginn eines Python-Programms, damit man einen schnellen √úberblick √ºber alle definierten Konstanten und ihre Werte bekommen kann.\nEs ist wichtig zu verstehen, dass der fixe Wert einer Konstante sich nur auf die Ausf√ºhrung des Programms bezieht. Zwischen mehreren Ausf√ºhrungen desselben Programms kann der Wert einer Konstante ge√§ndert werden. Zum Beispiel k√∂nnten wir als Hersteller des LED-Dimmers f√ºr eine neue Version entscheiden, dass dieser sich noch schneller dimmen lassen soll, und wir erh√∂hen den Wert f√ºr STEP auf 20. Oder der Benutzer k√∂nnte diesen Wert √ºber die Einstellungen der hypothetischen Dimmer-App anpassen.\nWenn wir ‚Äì wie in Zeile 15 gezeigt ‚Äì die Differenz des Z√§hlers mit der Schrittgr√∂√üe multiplizieren, k√∂nnen wir die Anpassung der Helligkeit verst√§rken.\n\n\n\n\nListing¬†2.1: Der fertige LED-Dimmer (ohne Boilerplate-Code)\n\n\nknob.reset()\nbrightness = 0\n1STEP = 10\nled.set_rgb_value(brightness, brightness, brightness) \n\nlast_count = 0\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n2        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(brightness, brightness, brightness)\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n\n\n\n1\n\nHier definieren wir eine Konstante STEP und weisen ihr den Wert 10 zu.\n\n2\n\nDie Helligkeit wird nun um diff * STEP angepasst, was bedeutet, dass jede Drehung des Knopfes einen gr√∂√üeren Einfluss auf die Helligkeit hat.\n\n\n\n\nMit dem LED-Dimmer haben wir die zentrale Funktion des Drehknopfes zur Gen√ºge kennengelernt. Das Ger√§t hat aber noch eine andere Funktion.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#druckknopf-auslesen",
    "href": "numbers.html#druckknopf-auslesen",
    "title": "2¬† Zahlen",
    "section": "2.8 Druckknopf auslesen",
    "text": "2.8 Druckknopf auslesen\nNeben dem Z√§hler besitzt der Drehknopf (der Name sagt es schon) noch eine Funktion, n√§mlich die eines einfachen Druckknopfes. Wir haben es weiter oben in Abschnitt 2.1 mit dem Brick Viewer schon ausprobiert: Der Drehknopf l√§sst sich dr√ºcken und erzeugt eine haptische R√ºckmeldung, ein leichtes Knacken. Im Brick Viewer wurde der kleine Kreis auf der rechten Seite dann rot eingef√§rbt.\nSelbstverst√§ndlich k√∂nnen wir den Zustand des Buttons auch aus einem Programm heraus abfragen. Dazu bietet uns der Drehknopf eine Methode is_pressed() an:\n\nwhile True:\n    if knob.is_pressed():\n        print(\"Button pressed\")\n    else:\n        print(\"Button not pressed\")\n\nDie Funktion liefert True zur√ºck, wenn der Button gerade gedr√ºckt ist, und ansonsten False. Das k√∂nnen wir wunderbar nutzen und dar√ºber eine Bedingung formulieren, um entweder ‚ÄúButton pressed‚Äù oder ‚ÄúButton not pressed‚Äù auf der Konsole auszugeben. Ihr erinnert euch bestimmt an das if-Statement aus Abschnitt 2.3. Das ist genau das, was wir jetzt brauchen!\n\n\n\n\nListing¬†2.2: Ein erster Test des Drehknopf-Buttons.\n\n\n1button_pressed_before = False\nwhile True:\n    button_pressed_after = knob.is_pressed()\n\n2    if button_pressed_before == True and button_pressed_after == False:\n3        print(\"Button was pressed and released\")\n    \n4    button_pressed_before = button_pressed_after\n\n\n\n\n\n1\n\nWir initialisieren eine Variable button_pressed_before, die den vorherigen Zustand des Buttons speichert. Am Anfang gehen wir mal davon aus, dass er nicht gedr√ºckt ist.\n\n2\n\nMit dem if-Statement √ºberpr√ºfen wir, ob der Button logelassen wurde. Dazu muss der vorherige Zustand True und der aktuelle Zustand False sein.\n\n3\n\nWenn der Button soeben losgelassen wurde, geben wir eine entsprechende Information auf der Konsole aus.\n\n4\n\nAm Ende der Schleife aktualisieren wir den vorherigen Zustand button_pressed_before, damit er den aktuellen Zustand f√ºr die n√§chste Iteration speichert.\n\n\n\n\nDas reicht f√ºrs Erste ‚Äì der Button kann tats√§chlich nicht mehr als das. Reicht aber auch: Damit k√∂nnen wir unserem Dimmer schon einen zus√§tzlichen Mehrwert verleihen. Schlie√ülich kann unsere LED nicht nur wei√ü leuchten.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#led-dimmer-3.0",
    "href": "numbers.html#led-dimmer-3.0",
    "title": "2¬† Zahlen",
    "section": "2.9 LED-Dimmer 3.0",
    "text": "2.9 LED-Dimmer 3.0\nW√§re es nicht praktisch, wenn wir das Licht der LED nicht nur dimmen, sondern auch den Farbton ver√§ndern k√∂nnten? Wei√ües Licht ist am Abend bekanntlich nicht empfehlenswert, und gr√ºnes Licht soll beruhigend wirken.\nLasst uns unseren Dimmer so erweitern, dass per Knopfdruck der Farbton gewechselt werden kann. F√ºrs Erste wollen wir die Farben Wei√ü, Gelb und Gr√ºn anbieten. Das l√§sst sich sp√§ter beliebig erweitern.\n\n2.9.1 Farbe per Variable steuern\nDer Ausgangspunkt f√ºr unser dimmbares Stimmungslicht ist der Dimmer aus Listing¬†2.1. Von hier aus f√ºgen wir Schritt f√ºr Schritt die Logik f√ºr den Farbwechsel per Button ein. Lasst uns aber zun√§chst ganz ohne Button versuchen, die Farbe der LED zu √§ndern.\nBisher haben wir es uns einfach gemacht und die LED in Wei√ü leuchten lassen. Dazu mussten wir nur jeden der drei RGB-Farbkan√§le auf den gleichen Wert setzen. Wenn wir neben Wei√ü auch Gelb und Gr√ºn anbieten wollen, m√ºssen wir die Farbkan√§le unterschiedlich ansteuern. F√ºr Gelb setzen wir den roten und den gr√ºnen Kanal auf den gleichen Wert, w√§hrend der blaue Kanal auf 0 bleibt. F√ºr Gr√ºn setzen wir den gr√ºnen Kanal auf den gleichen Wert und die anderen beiden auf 0. Um so eine Logik umzusetzen, haben wir das passende Instrument bereits in unserem Werkzeugkasten: Kontrollstrukturen.\nNehmen wir mal an, wir h√§tten eine Variable color, auf der die aktuelle Farbe gespeichert ist, in der die LED leuchten soll. Sie k√∂nnte also die Werte ‚Äúwhite‚Äù, ‚Äúyellow‚Äù oder ‚Äúgreen‚Äù annehmen. Dann k√∂nnten wir mit if-Statements die notwendige Logik umsetzen:\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nErinnert euch, dass der Code nach einem if nur dann ausgef√ºhrt wird, wenn die vorangegangene Bedingung erf√ºllt ist. Da die Variable color zu einem Zeitpunkt nur einen der drei Werte annehmen kann, muss genau eine der drei Bedingungen erf√ºllt sein und alle anderen entsprechend nicht.\nWenn wir jetzt zu Beginn unseres Programms color auf einen der drei Werte setzen, k√∂nnen wir die Logik schnell mal testen:\n\ncolor = \"white\"\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nAlles sollte so sein wie zuvor, die LED leuchtet wei√ü.\n\ncolor = \"yellow\"\n\nJetzt sollte beim Start des Programms die LED gelb leuchten. Dasselbe probiert mal mit ‚Äúgreen‚Äù aus, das d√ºrfte auch funktionieren.\n\n\n2.9.2 Farbe per Knopfdruck √§ndern\nDie aktuelle Farbe in einer Variable zu speichern ist eine gute Idee gewesen. Darauf k√∂nnen wir aufbauen und den Button f√ºr den Wechsel der Farbe nutzen. Aber wie?\nZun√§chst erinnern wir uns an die Logik aus Listing¬†2.2, in dem wir den Button bereits aus einem Programm heraus getestet haben. Dort haben wir eine Logik gebastelt, die erkennt, wenn der Button gedr√ºckt und wieder losgelassen wird. Wenn das der Fall war, wurde der Wert ‚ÄúButton gedr√ºckt‚Äù auf der Konsole ausgegeben. K√∂nnten wir diese Logik nicht verwenden, um statt etwas auszugeben einfach die Farbe zu wechseln?\nNat√ºrlich k√∂nnen wir das. Passen wir den Code entsprechend an:\n\nbutton_pressed_before = False\nwhile True:\n    button_pressed_after = knob.is_pressed()\n\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n    button_pressed_before = button_pressed_after\n\nWieder ein Haufen voller ifs - aber es sollte funktionieren. Gehen wir es einmal durch: Wenn der Button losgelassen wurde (Zeile 5) gelangen wir zur Pr√ºfung der if-Statements. Im ersten Fall wird gepr√ºft, ob die LED gerade Wei√ü leuchtet (color == \"white\"). Ist das der Fall, dann wechseln wir jetzt auf Gelb. Im zweiten Schritt sehen wir ein elif, das sehr √§hnlich zu einem if ist, mit der Einschr√§nkung, dass es nur √ºberhaupt gepr√ºft wird, wenn das vorherige if nicht schon wahr war. Das macht in diesem Fall einen gro√üen Unterschied (im Vergleich zu weiter oben, als wir einfache if-Statements verwendet haben, um die Farbe der LED mit set_rgb_color zu setzen). √úberlegt mal, was passieren w√ºrde, wenn wir hier folgenden Code einsetzen w√ºrden:\n\nif color == \"white\":\n    color = \"yellow\"\nif color == \"yellow\":\n    color = \"green\"\nif color == \"green\":\n    color = \"white\"\n\nGeht das mal im Kopf durch. Wenn color aktuell den Wert white hat, dann wird durch das erste if der Wert auf yellow gesetzt. Anschlie√üend wird das zweite if gepr√ºft, das jetzt wahr ist, und der Wert wird auf green gesetzt. Das dritte if wird dann also ebenfalls wahr sein, und der Wert wird wieder auf white gesetzt. Im Endeffekt haben wir also nichts gewonnen, die LED bliebe wei√ü. Hier ist die Verwendung von elif entscheidend. Denn ein elif wird nur gepr√ºft, wenn das vorherige if oder elif nicht wahr war. Nach der ersten Anpassung w√§re hier also Schluss und die Farbe ist wie gew√ºnscht Gelb.\nF√ºgen wir alles zusammen - die neue Logik zum setzen der Farben basierend auf der Varible colorund die Logik zum √Ñndern der Variable, sowie die Logik des Dimmers aus Listing¬†2.1:\n\n\n\n\nListing¬†2.3: Farbwechsel und Helligkeitsanpassung in einem Programm.\n\n\nbutton_pressed_before = False\n\n# 1. Main loop to keep program running\nwhile True:\n    new_count = knob.get_count(reset=False)\n    button_pressed_after = knob.is_pressed()\n\n    # 2. Logic for color change on button release\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n        # Update LED to reflect new color\n        if color == \"white\":\n            led.set_rgb_value(brightness, brightness, brightness)\n        if color == \"yellow\":\n            led.set_rgb_value(brightness, brightness, 0)\n        if color == \"green\":\n            led.set_rgb_value(0, brightness, 0)\n\n    button_pressed_before = button_pressed_after\n\n    # 3. Logic for brightness adjustment\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        # Update LED to reflect new color\n        if color == \"white\":\n            led.set_rgb_value(brightness, brightness, brightness)\n        if color == \"yellow\":\n            led.set_rgb_value(brightness, brightness, 0)\n        if color == \"green\":\n            led.set_rgb_value(0, brightness, 0)\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n\n\nSchaut euch den Code in Ruhe an und pr√ºft, ob ihr ihn Zeile f√ºr Zeile nachvollziehen k√∂nnt. An dieser Stelle hat unser Programm schon eine betr√§chtliche Gr√∂√üe angenommen, und so langsam wird es un√ºbersichtlich. Versuchen wir also, Struktur hineinzubringen. Im Wesentlichen besteht das Programm aus drei Teilen, jeden habe ich mit einem vorangestellten Kommentar markiert:\n\nHauptschleife, um das Programm am Laufen zu halten\nLogik f√ºr Farbwechsel bei Tastenfreigabe\nLogik zur Helligkeitsanpassung\n\nIn der Hauptschleife wird am Anfange immer wieder der aktuelle Z√§hlerstand und der Zustand des Buttons abgefragt und auf jeweils einer Variable gespeichert. Diese Werte ben√∂tigen wir, um zu entscheiden, ob wir die Farbe √§ndern oder die Helligkeit anpassen m√ºssen.\nUm einen potenziellen Farbwechsel k√ºmmert sich der zweite Block, der mit dem if button_pressed_before == True ... beginnt. Die Bedingung pr√ºft, ob der Button gerade aus dem gedr√ºckten Zustand in den nicht gedr√ºckten Zustand wechselt, der Benutzer ihn also gerade losgelassen hat. In diesem Moment soll die Farbe gewechselt werden. Die Logik daf√ºr haben wir gerade entwickelt.\nUm die Helligkeitsanpassung k√ºmmert sich dann der dritte und letzte gr√∂√üere Block. Er beginnt mit if new_count != last_count, was pr√ºft, ob der Drehknop bet√§tigt wurde. Wenn ja, dann wird die Helligkeit entsprechend der Differenz angepasst. Diese Logik haben wir in Abschnitt 2.7 zusammen entwickelt.\nWer von euch jetzt ganz genau hinsieht, der erkennt, dass die Bl√∂cke 2 und 3 zum Teil identischen Code ausf√ºhren. In der Programmierung ist das eine rote Flagge üö©! Lasst uns dar√ºber sprechen, warum!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#funktionen",
    "href": "numbers.html#funktionen",
    "title": "2¬† Zahlen",
    "section": "2.10 Funktionen",
    "text": "2.10 Funktionen\nIn der Programmierung ist es wichtig, Wiederholungen zu vermeiden. Wir sprechen auch vom DRY-Prinzip, was f√ºr Don‚Äôt Repeat Yourself steht. Wenn wir feststellen, dass wir denselben Code an mehreren Stellen verwenden, sollten wir dar√ºber nachdenken, etwas zu ver√§ndern. Warum?\nNehmen wir in unserem Beispiel an, wir f√ºhren eine vierte Farbe ein, sagen wir Blau. Dann m√ºssten wir den Code in den Bl√∂cken 2 und 3 anpassen, um die neue Farbe zu ber√ºcksichtigen. Das bedeutet, dass wir den gleichen Code an mehreren Stellen √§ndern m√ºssten, was fehleranf√§llig und m√ºhsam ist. Zwei mag noch nicht nach einem Problem klingen, aber selbst hier zeigt sich das Problem der Wiederholung. Wird eine Stelle vergessen, ist der Code inkonsistent und funktioniert nicht mehr wie gew√ºnscht.\nDie L√∂sung liegt darin, h√§ufig verwendeten Code in Funktionen auszulagern. Funktionen sind ein m√§chtiges Werkzeug in der Programmierung. Sie erm√∂glichen es uns, Codebl√∂cke zu definieren, die wir immer wieder verwenden k√∂nnen, ohne sie jedes Mal neu schreiben zu m√ºssen. Funktionen helfen uns dabei, unseren Code sauberer, √ºbersichtlicher und wartbarer zu gestalten.\nIm Listing¬†2.3 wird dieser Teil an zwei Stellen wiederholt:\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nZeit, diesen Code nur einmal zu schreiben! Machen wir daraus eine Funktion. Wie das geht? Im Prinzip m√ºssen wir vier Dinge kl√§ren:\n\nWas soll die Funktion tun?\nWie sieht das Ergebnis aus?\nWas ben√∂tigt die Funktion, um ihre Aufgabe zu erledigen?\nWie heisst die Funktion?\n\n\n\n\n\n\n\nAbbildung¬†2.14: Funktionen folgen einem Eingabe-Verarbeitung-Ausgabe (EVA) Schema.\n\n\n\n\ndef set_led_color(color, brightness):\n    if color == \"white\":\n        led.set_rgb_value(brightness, brightness, brightness)\n    if color == \"yellow\":\n        led.set_rgb_value(brightness, brightness, 0)\n    if color == \"green\":\n        led.set_rgb_value(0, brightness, 0)\n\nIn Listing¬†2.4 seht ihr den fertigen Code f√ºr den Dimmer mit Farbwechsel per Knopfdruck.\n\n\n\n\nListing¬†2.4: Der fertige Dimmer mit Farbwechsel per Knopfdruck.\n\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nknob = BrickletRotaryEncoderV2('WZd', ipcon) \nled = BrickletRGBLEDV2('ZG1', ipcon)\n\nknob.reset()\nbrightness = 0\nSTEP = 10\nled.set_rgb_value(brightness, brightness, brightness) \nlast_count = 0\n\ncolor = \"white\"\nbutton_pressed_before = False\n\ndef set_led_color(color, brightness):\n    if color == \"white\":\n        led.set_rgb_value(brightness, brightness, brightness)\n    if color == \"yellow\":\n        led.set_rgb_value(brightness, brightness, 0)\n    if color == \"green\":\n        led.set_rgb_value(0, brightness, 0)\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n    button_pressed_after = knob.is_pressed()\n\n    # If button changes from pressed to not pressed\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n        print(f\"Color changed to: {color}\")\n        set_led_color(color, brightness)   \n\n    button_pressed_before = button_pressed_after\n\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n        set_led_color(color, brightness)\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#footnotes",
    "href": "numbers.html#footnotes",
    "title": "2¬† Zahlen",
    "section": "",
    "text": "H√§nde hoch, wer daran noch glaubt!‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "3¬† Texte",
    "section": "",
    "text": "Setup\nF√ºr dieses Kapitel ben√∂tigen wir die LED (RGB LED Bricklet 2.0) und den Infrarot-Entfernungsmesser Distance IR 4-30cm Bricklet 2.0. Beide Ger√§te schlie√üen wir an den Mikrocontroller (Master Brick 3.2) and und fixieren alle drei auf einer Montageplatte. Wie in der Abbildung gezeigt, soll der Entfernungsmesser dabei nach oben zeigen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#setup",
    "href": "text.html#setup",
    "title": "3¬† Texte",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#texte-ganz-ohne-tastatur",
    "href": "text.html#texte-ganz-ohne-tastatur",
    "title": "3¬† Texte",
    "section": "3.1 Texte ‚Äì ganz ohne Tastatur?",
    "text": "3.1 Texte ‚Äì ganz ohne Tastatur?\nJa, ich gebe zu: Eine Tastatur ist schon richtig praktisch. Schnell tippen wir damit Buchstaben, Zahlen, Satz- und Sonderzeichen (wie neue Zeilen und Leerzeichen) ein. Aber stell dir mal vor: Wie k√∂nnte ich eigentlich dieses Buch schreiben, wenn ich keine Tastatur h√§tte?\nTats√§chlich gibt es spannende Alternativen! Hast du schon mal versucht, Texte zu diktieren? Google Docs oder Microsoft Word bieten mittlerweile ziemlich gute M√∂glichkeiten daf√ºr. Anfangs f√ºhlt sich das ungewohnt an, aber ich kenne Menschen, die darauf schw√∂ren und damit sogar produktiver sind.\nHeute wollen wir aber bewusst einmal einen Schritt zur√ºckgehen und das Tippen absichtlich erschweren. Klingt komisch? Macht aber Sinn! Denn wenn wir das Eingeben von Texten schwieriger gestalten, lernen wir einerseits, unsere Tastaturen wieder richtig zu sch√§tzen. Andererseits verstehen wir dann besser, wie Texte im Hintergrund verarbeitet und gespeichert werden.\nWie w√§re es also mit einer Tastatur, die auf Handgesten basiert? Klingt verr√ºckt? Perfekt ‚Äì genau das machen wir!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "href": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "title": "3¬† Texte",
    "section": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten",
    "text": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten\nStarten wir ganz simpel. Wir bauen zuerst eine Art ‚ÄúKnopf‚Äù oder Button, der auf Handgesten reagiert. Daf√ºr verwenden wir einen der Infrarot-Abstandssensoren ‚Äì oder wie er bei Tinkerforge hei√üt: Distance IR 4-30cm Bricklet 2.0. Wie der Name schon sagt, misst der Sensor Entfernungen von 4 bis maximal 30 cm.\nUm den Sensor in unserem Programm zu nutzen, k√∂nnen wir ganz entspannt den Grundcode (Boilerplate-Code) aus den vorherigen Kapiteln √ºbernehmen. Nur zwei kleine Anpassungen brauchen wir noch speziell f√ºr unseren Sensor:\n\nfrom tinkerforge.ip_connection import IPConnection\n1from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n2ir_sensor = BrickletDistanceIRV2(\"\", ip_con)\n\n\n1\n\nHier importieren wir die Klasse f√ºr den IR-Sensor.\n\n2\n\nHier erzeugen wir eine konkrete Instanz und verbinden uns mit dem angeschlossenen Sensor. Vergiss nicht, deine UID hier einzutragen!\n\n\n\n\nWas kann der Sensor? Eigentlich hat er nur eine Funktion:\n\n1distance = ir_sensor.get_distance()\n2print(f\"Objekt ist {distance/100} cm entfernt\")\n\n\n1\n\nDie Funktion get_distance() fragt den aktuell gemessenen Wert ab.\n\n2\n\nDer Sensor liefert den Wert in Zentimeter * 100 zur√ºck.\n\n\n\n\nAber wie l√§sst sich mit den Entfernungswert ein Button umsetzen? Dazu vergegenw√§rtigen wir uns, was ein herk√∂mmlicher Button eigentlich ist und wie er funktioniert. Ein Button, wie wir ihn auf einer Tastatur finden, kennt zwei Zust√§nde: Gedr√ºckt und nicht gedr√ºckt. An oder aus. Wenn wir eine Taste dr√ºcken, so schlie√üen wir dar√ºber einen Stromkreis, der in einem winzigen Mikroprozessor m√ºndet. Dieser Prozessor erkennt durch laufendes Scannen s√§mtlicher Verbindungen zu den Tasten (die als Matrix angeordnet sind), durch welche Kreise Strom flie√üt und kann so auf die gedr√ºckte Taste schlie√üen. Der Mikroprozessor ermittelt dann anhand der Koordinate in der Matrix einen so gennanten Scan Code, der f√ºr jede Taste anders lautet. Dieser Code wird als bin√§re Folge von Nullen und Einsen √ºber das USB-Kabel an den Computer geschickt und dort von dem aktiven Programm - etwa einer Textverarbeitungssoftware - in ein Codesystem umgewandelt, das Zeichen abbilden kann. So wie etwa das ASCII-Codesystem, das wir weiter unten kennenlernen.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "images.html",
    "href": "images.html",
    "title": "4¬† Bilder",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\n\nEinf√ºhrung in die Idee einer Pixelmatrix aus Farbwerten als Bild\nVerwendung des LCD-Displays zur Veranschaulichung, auch wenn nur schwarz/wei√ü\nVerwendung von Zeichen auf dem LCD, um Pixel-Bitmaps f√ºr Schriftarten hervorzuheben\nStudierende nutzen Bitmap-Sheet, um ein eigenes Logo zu entwerfen und auf dem LCD anzuzeigen\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "codes.html",
    "href": "codes.html",
    "title": "5¬† Codes",
    "section": "",
    "text": "Experiment\n\n\n\nMorse-Code √ºber Piezo Speaker\n\nEinf√ºhrung des Piezo Speaker\nCodesysteme\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Codes</span>"
    ]
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#setup",
    "href": "conversion.html#setup",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Experiment\n\n\n\nMit 4 Kippschaltern und 4 Widerst√§nden bauen wir einen Digital-To-Analog-Converter (DAC). Dazu kommt ein Breadboard und diveser √úberbr√ºckungskabel zum Einsatz. Au√üerdem brauchen wir den Analog In 3.0 von Tinkerforge.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-in-den-computer-hinein",
    "href": "conversion.html#der-weg-in-den-computer-hinein",
    "title": "6¬† Umwandlung",
    "section": "6.1 Der Weg in den Computer hinein",
    "text": "6.1 Der Weg in den Computer hinein",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-aus-dem-computer-heraus",
    "href": "conversion.html#der-weg-aus-dem-computer-heraus",
    "title": "6¬† Umwandlung",
    "section": "6.2 Der Weg aus dem Computer heraus",
    "text": "6.2 Der Weg aus dem Computer heraus\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "information.html",
    "href": "information.html",
    "title": "7¬† Information",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "information.html#setup",
    "href": "information.html#setup",
    "title": "7¬† Information",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "sensors.html",
    "href": "sensors.html",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#setup",
    "href": "sensors.html#setup",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\nAnalog vs.¬†digital\nBaue einen Wasserstandssensor mit einem Widerstand und dem Analog-In-Bricklet.\nOder: Feuchtigkeitssensor in eine Pflanze stecken\nOder: Ber√ºhrungssensor\nOder: Pulssensor (Farbsensor)\nIntegriere die RGB-LED irgendwie\nFarbsensor",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#aufgaben",
    "href": "sensors.html#aufgaben",
    "title": "8¬† Sensoren",
    "section": "Aufgaben",
    "text": "Aufgaben\n\nProgrammiere einen Batteriedoktor mithilfe des Analog In Sensors\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "signals.html",
    "href": "signals.html",
    "title": "9¬† Signale",
    "section": "",
    "text": "Setup\nHast du dich schon einmal gefragt, wie dein Fitness-Tracker deinen Puls messen kann, obwohl du nur einen Finger auflegst? Diese Frage f√ºhrt uns direkt zu einem spannenden Konzept: Signalen. Alles, was wir mit Sensoren messen, sind zun√§chst einmal beliebige Gr√∂√üen. Doch nicht alles, was wir messen, ist f√ºr uns relevant. Wir suchen nach Mustern in diesen Daten ‚Äî eben genau diesen Mustern, die wir als Signale bezeichnen. Alles andere, was uns von diesen Signalen ablenkt, nennen wir Rauschen. Unser Ziel: Wir m√∂chten herausfinden, wie wir Signale effektiv vom Rauschen unterscheiden k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#setup",
    "href": "signals.html#setup",
    "title": "9¬† Signale",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\nMithilfe des Farbsensors bauen wir einen Pulsmesser.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "href": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "title": "9¬† Signale",
    "section": "9.1 Pulsmesser: Dein Finger als Signalquelle",
    "text": "9.1 Pulsmesser: Dein Finger als Signalquelle\nErinnerst du dich noch an den Farbsensor aus Kapitel 8? Er misst nicht nur die Intensit√§t des RGB-Spektrums, sondern auch die allgemeine Lichtintensit√§t, auch Illuminance genannt. Hier kommt die spannende Tatsache ins Spiel: Genau dieses Prinzip steckt hinter den Pulsmessern in Fitnesstrackern. Ja, genau der Sensor, der Licht misst, verr√§t dir, wie schnell dein Herz schl√§gt!\nAber wie genau funktioniert das? Stell dir vor, du legst deinen Zeigefinger direkt auf den Sensor und schaltest die integrierte wei√üe LED an. Das Licht der LED trifft auf deinen Finger und wird reflektiert. Dein Finger sieht f√ºr dich immer gleich aus, aber tats√§chlich sorgt dein Herzschlag daf√ºr, dass dein Finger mal minimal heller und mal dunkler erscheint. Das liegt daran, dass Blut in rhythmischen Sch√ºben durch die Gef√§√üe gepumpt wird. Diese winzigen Ver√§nderungen, die du mit blo√üem Auge nicht sehen kannst, werden vom sensiblen Farbsensor deutlich wahrgenommen.\nSchauen wir uns das einmal genauer an: Wenn du dir die gemessene Lichtintensit√§t √ºber den Zeitverlauf im Brick Viewer ansiehst, kannst du deinen Pulsschlag tats√§chlich erkennen‚Äîer wird sichtbar als kleine, regelm√§√üige Ausschl√§ge oder Peaks. Faszinierend, oder? So kannst du beobachten, wie aus etwas so scheinbar Einfachem wie Licht ein Signal entsteht, das dir Informationen √ºber deinen K√∂rper liefert.\n\n\n\n\n\n\nAbbildung¬†9.1: Dein Puls im Brick Viewer",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#vom-diagramm-zur-zahl",
    "href": "signals.html#vom-diagramm-zur-zahl",
    "title": "9¬† Signale",
    "section": "9.2 Vom Diagramm zur Zahl",
    "text": "9.2 Vom Diagramm zur Zahl\nAuch wenn du das Signal im Liniendiagramm in Abbildung¬†9.1 bereits deutlich sehen kannst, bleibt eine spannende Herausforderung bestehen: Wie schreibst du ein Programm, das aus diesen Daten deinen Puls als konkrete Zahl, zum Beispiel ‚Äú60 Schl√§ge pro Minute‚Äù, berechnet? Genau daf√ºr sind wir ja hier ‚Äì um herauszufinden, wie man solche kniffligen Aufgaben l√∂st. Lass uns gemeinsam starten!\nZun√§chst m√ºssen wir den Farbsensor in unserem Python-Programm auslesen. Den notwendigen Code daf√ºr haben wir im vorherigen Kapitel 8 bereits kennengelernt.\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\n\n\n1\n\nAchtung: Vergiss nicht, hier deine eigene UID einzusetzen. Diese findest du im Brick Viewer.\n\n\n\n\nJetzt haben wir Zugriff auf die Funktionen des Sensors und k√∂nnen etwa die Lichtintensit√§t messen:\n\n1color_sensor.set_light(True)\n2color_sensor.set_configuration(1, 1)\nilluminance = color_sensor.get_illuminance()\n\n\n1\n\nSchaltet die integrierte LED des Sensors an.\n\n2\n\nStellt die Werte f√ºr Gain und Integration Time auf 4x und 24ms. Diese Einstellung scheinen gut zu funktionieren, um den Puls zu messen.\n\n\n\n\nDer zur√ºckgegebene Wert h√§ngt von zwei Einstellungen ab: Gain (Verst√§rkung) und Integration Time (Messzeit). Je l√§nger die Messzeit, desto genauer die Werte ‚Äì allerdings k√∂nnen dann weniger Messungen pro Sekunde durchgef√ºhrt werden. Laut Dokumentation k√∂nnen wir aus dem gemessenen Wert die Lichtintensit√§t in Lux wie folgt berechnen:\n\n1illuminance_lux = illuminance * 700 / 4 / 24\n\n\n1\n\nDer Wert 4 beschreibt ein 4-fache Verst√§rkung (Gain) und die 24 steht f√ºr 24ms Integration Time\n\n\n\n\nUm deinen Puls zu berechnen, m√ºssen wir jetzt mehrere Werte in kurzen Abst√§nden messen. Warum? Weil wir die regelm√§√üigen Tief- und Hochpunkte erkennen wollen. Ein Tiefpunkt entsteht, wenn dein Finger am dunkelsten ist ‚Äì hier ist also gerade besonders viel Blut im Finger. Die Hochpunkte markieren dagegen den Moment, in dem das Blut gr√∂√ütenteils wieder zur√ºckgeflossen ist. Jeder Herzschlag erzeugt genau einen Tief- und einen Hochpunkt. Finden wir diese Punkte, k√∂nnen wir einfach die Zeitabst√§nde messen und daraus die Pulsfrequenz berechnen.\nBeginnen wir damit, unsere Messungen in einer Schleife durchzuf√ºhren. Das ist eine praktische Methode, kontinuierlich Daten zu erfassen:\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n    print(f\"Lichtintensit√§t in Lux: {illuminance_lux}\")\n\nLass uns das Programm einmal ausprobieren. Es sieht aktuell so aus:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\ncolor_sensor.set_light(True)\ncolor_sensor.set_configuration(1, 1)\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n2    print(f\"Lichtintensit√§t in Lux: {illuminance_lux:.2f}  \", end=\"\\r\")\n\n\n1\n\nDenke daran, die UID durch die deines Sensors zu ersetzen.\n\n2\n\nDer Parameter end=\"\\r\" sorgt daf√ºr, dass nicht jede Ausgabe in eine neue Zeile geschrieben wird. Stattdessen wird immer an den Anfang der selben Zeile gesprungen. Das \\r ist das Symbol f√ºr Carriage Return.\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "protocols.html",
    "href": "protocols.html",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "protocols.html#setup",
    "href": "protocols.html#setup",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "encryption.html",
    "href": "encryption.html",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "encryption.html#setup",
    "href": "encryption.html#setup",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "algorithms.html",
    "href": "algorithms.html",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "algorithms.html#setup",
    "href": "algorithms.html#setup",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "compression.html",
    "href": "compression.html",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "compression.html#setup",
    "href": "compression.html#setup",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "computer.html",
    "href": "computer.html",
    "title": "14¬† Computer",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#logik-und-arithmetik",
    "href": "computer.html#logik-und-arithmetik",
    "title": "14¬† Computer",
    "section": "14.1 Logik und Arithmetik",
    "text": "14.1 Logik und Arithmetik\n\nLogikgatter\n8-Bit-Additionsmaschine\nSubtraktion, Division, Multiplikation",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#die-von-neumann-architektur",
    "href": "computer.html#die-von-neumann-architektur",
    "title": "14¬† Computer",
    "section": "14.2 Die von-Neumann-Architektur",
    "text": "14.2 Die von-Neumann-Architektur",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "href": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "title": "14¬† Computer",
    "section": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers",
    "text": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers\n\nx = 10\nprint(f\"Adresse im Speicher der Variable 'x': {hex(id(x))}\")\nx= 20\nprint(f\"Neue Adresse im Speicher der Variable 'x': {hex(id(x))}\")\n\nAdresse im Speicher der Variable 'x': 0x7ffb12597448\nNeue Adresse im Speicher der Variable 'x': 0x7ffb12597588\n\n\n\nnames = [\"Max\", \"Kim\", \"Hildegard\"]\nprint(f\"Adresse im Speicher der Variable 'names': {hex(id(names))}\")\nnames.append(\"Heinrich\")\nprint(f\"Die Adresse im Speicher der Variable 'names' bleibt identisch: {hex(id(names))}\")\n\nAdresse im Speicher der Variable 'names': 0x205eea4ee40\nDie Adresse im Speicher der Variable 'names' bleibt identisch: 0x205eea4ee40\n\n\n\n\n\n\n\n\nLeseempfehlung\n\n\n\nUm tiefer in die Themen dieses Kapitels einzusteigen, empfehle ich euch Petzold (2022) zu lesen . Es lohnt sich, das Buch von Vorne nach Hinten zu verschlingen.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "problems.html",
    "href": "problems.html",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "problems.html#setup",
    "href": "problems.html#setup",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Adami, Christoph. 2016. ‚ÄúWhat Is Information?‚Äù\nPhilosophical Transactions of the Royal Society A: Mathematical,\nPhysical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, and Dennis Brylow. 2020. Computer Science: An\nOverview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer\nHardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, and John Horton Conway. 2004. How to Solve It: A New\nAspect of Mathematical Method. Expanded Princeton Science Library\ned. Princeton Science Library. Princeton [N.J.]: Princeton University\nPress.\n\n\nScott, John C. 2009. But How Do It Know?: The Basic Principles of\nComputers for Everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]