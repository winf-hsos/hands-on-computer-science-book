[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Computer Science",
    "section": "",
    "text": "Vorwort\nGl√ºckwunsch ‚Äì du bist angekommen! Wie auch immer dein Weg hierher aussah, du hast es geschafft, dieses Buch zu √∂ffnen. Vielleicht bist du Student oder Studentin an der Hochschule Osnabr√ºck und wurdest (zu deinem Gl√ºck) gezwungen, oder du bist ganz bewusst hier gelandet und freust dich darauf, etwas Neues zu lernen ‚Äì genau wie ich.\nDieses Buch entstand urspr√ºnglich, um meinen Veranstaltungen an der Hochschule Osnabr√ºck eine verst√§ndliche und praxisnahe Grundlage zu geben. Es dient als Hauptlekt√ºre f√ºr meine Vorlesungen, aber auch als Nachschlagewerk f√ºr alle, die vielleicht mal eine Sitzung verpasst haben oder Themen eigenst√§ndig vertiefen wollen. Besonders willkommen sind dabei Quereinsteiger, Wiederholer oder einfach neugierige Menschen, die bisher noch gar keinen Kontakt mit der Hochschule Osnabr√ºck hatten.\nHier bekommst du keine trockene Theorie pr√§sentiert, sondern eine spannende, praxisnahe Einf√ºhrung in die Grundlagen moderner Computer und unserer digitalen Welt. Das Fach, das sich dahinter verbirgt, hei√üt auf Deutsch Informatik, international auch bekannt als Computer Science. Der Titel Hands-On Computer Science verr√§t bereits: Hier wird es praktisch ‚Äì und zwar von Anfang an.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#was-macht-dieses-buch-besonders",
    "href": "index.html#was-macht-dieses-buch-besonders",
    "title": "Hands-On Computer Science",
    "section": "Was macht dieses Buch besonders?",
    "text": "Was macht dieses Buch besonders?\nLehrb√ºcher zur Informatik gibt es reichlich. Viele davon sind gro√üartig, aber kaum eines passt perfekt zu dem, was ich mit meinen Studierenden vorhabe. Woran liegt das?\nViele klassische Informatikb√ºcher versuchen, das gesamte Fachgebiet m√∂glichst umfassend abzubilden. Das ist sinnvoll f√ºr angehende Informatiker, aber meine Zielgruppe bist du: Studierende in Studieng√§ngen wie Management nachhaltiger Ern√§hrungssysteme, Lebensmittelproduktion oder kAgrarsystemtechnologien ‚Äì oder vielleicht bist du nicht mal Student oder Studentin, sondern einfach interessiert daran, endlich Zugang zur digitalen Welt zu finden.\nKurz gesagt: Dieses Buch ist f√ºr jeden gedacht, der Lust hat, in die digitale Welt einzutauchen, ohne sich gleich mit komplizierten Details zu √ºberfordern. Daf√ºr brauchst du kein allumfassendes Nachschlagewerk, sondern einen klaren roten Faden, der dich Schritt f√ºr Schritt an die grundlegenden Konzepte heranf√ºhrt.\nViele B√ºcher versprechen Praxisn√§he, doch oft endet diese in n√ºchternen √úbungsaufgaben am Kapitelende. Genau hier setzt Hands-On Computer Science an und macht zwei Dinge anders:\n\nDu lernst informatische Konzepte direkt anhand spannender Projekte mit Hardware wie Microcontrollern, Sensoren, Buttons, LEDs und Displays kennen.\nDu arbeitest kontinuierlich am LiFi-Projekt, das dich durch alle Kapitel begleitet und dabei immer weiter w√§chst.\nTheorie und Praxis sind nicht getrennt, sondern eng miteinander verbunden ‚Äì Programmieren und informatische Grundlagen lernst du gleichzeitig.\n\nSchon ab Kapitel 1 beginnst du zu programmieren und zwar nicht abstrakt, sondern konkret mit Bauteilen wie Buttons. Im Laufe des Buches lernst du Schritt f√ºr Schritt neue Hardware-Komponenten kennen, die immer direkt mit relevanten informatischen Konzepten verkn√ºpft sind. So schlie√üt du am Ende nicht nur das LiFi-Projekt erfolgreich ab, sondern verf√ºgst fast nebenbei √ºber ein solides Fundament in der Informatik. Wenn alles gut l√§uft, merkst du kaum, wie schnell du gelernt hast.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#tipps-f√ºr-die-lekt√ºre",
    "href": "index.html#tipps-f√ºr-die-lekt√ºre",
    "title": "Hands-On Computer Science",
    "section": "Tipps f√ºr die Lekt√ºre",
    "text": "Tipps f√ºr die Lekt√ºre\nWeil es in diesem Buch viel ums Programmieren geht, findest du nat√ºrlich viele Codebl√∂cke. Als Einstiegssprache verwenden wir Python. Warum ausgerechnet Python? Das erf√§hrst du sp√§ter genauer.\nCodebl√∂cke sind deutlich sichtbar vom √ºbrigen Text abgehoben, meist grau hinterlegt und in einer Schreibmaschinenschrift dargestellt, etwa Courier New oder Consolas. Hier ein kleines Beispiel:\n1led.set_rgb_value(0, 0, 0)\n2led.set_rgb_value(255, 255, 255)\n\nprint(\"Diese Zeile hat keine Annotation\")\n\n3# Lasse die LED blau aufleuchten\nled.set_rgb_value(0, 0, 255)\n\n1\n\nSchaltet die LED aus, weil der RGB-Code (0,0,0) schwarz erzeugt.\n\n2\n\nSchaltet die LED auf wei√ües Licht, weil drei Mal die 255 die Farbe Wei√ü ergibt.\n\n3\n\nAuch Kommentare sind f√ºr kurze Erl√§uterungen n√ºtzlich.\n\n\nKommentare sind mit einer kleinen Zahl versehen. Wenn du die Online-Version nutzt und mit der Maus √ºber diese Zahl f√§hrst, erscheint ein Tooltip, der die Codezeile erkl√§rt. Das funktioniert nur online, nicht in PDF oder Druckversion.\nNoch ein kleiner Tipp: Wenn du mit der Maus √ºber den Codeblock f√§hrst, siehst du rechts oben ein Clipboard-Symbol. Ein Klick darauf kopiert den Code direkt in deine Zwischenablage, und du kannst ihn problemlos in dein ge√∂ffnetes Visual Studio Code oder eine andere IDE einf√ºgen und ausprobieren.\nAlle Codebeispiele findest du au√üerdem im GitHub-Repository, das zu diesem Buch geh√∂rt.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "experiments.html",
    "href": "experiments.html",
    "title": "Experimente",
    "section": "",
    "text": "Hands-On Programmieren lernen\nHast du dich schon einmal gefragt, wie man Informationen √ºber Licht √ºbertragen kann? Oder wie man mit Licht den Puls messen kann? Oder wie man mit zwei einfachen Kabeln einen Wasserstandssensor baut? Das alles klingt vielleicht weit hergeholt, ist aber tats√§chlich machbar ‚Äì und wie genau, das wollen wir in diesem Buch herausfinden! Dabei werden wir nicht nur die digitale Welt der Computer und Programmierung kennenlernen, sondern auch mit spannenden Ger√§ten in der analogen Welt arbeiten. In jedem Kapitel arbeiten wir mit anderen Ger√§ten, die dir unterschiedliche Facetten der digitalen Welt n√§herbringen und gleichzeitig erm√∂glichen, das Programmieren spielerisch zu erlernen.\nHier ein √úberblick √ºber die Ger√§te, mit denen wir gemeinsam experimentieren werden. Zusammengefasst kosten alle Komponenten 249 ‚Ç¨. Aber keine Sorge: Wenn du das Buch im Rahmen meines Moduls ‚ÄûDigitalisierung und Programmierung‚Äú an der Hochschule Osnabr√ºck liest, erh√§ltst du f√ºr das gesamte Semester ein komplettes Hardware-Kit.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#hands-on-programmieren-lernen",
    "href": "experiments.html#hands-on-programmieren-lernen",
    "title": "Experimente",
    "section": "",
    "text": "Abbildung¬†1: Tinkerforge Workbench mit vielen Ger√§ten\n\n\n\n\n\n\n\nWas?\nBauteil\nAnzahl\nPreis pro St√ºck\n\n\n\n\nBunte LED\nRGB LED Bricklet 2.0\n1\n8 ‚Ç¨\n\n\nButton mit integrierter, bunter LED\nRGB LED Button Bricklet\n1\n15 ‚Ç¨\n\n\nLicht- und Farbsensor\nColor Bricklet 2.0\n1\n17 ‚Ç¨\n\n\nLCD Touchdisplay\nLCD 128x64 Bricklet\n1\n33 ‚Ç¨\n\n\nPiezo Lautsprecher\nPiezo Speaker Bricklet 2.0\n1\n19 ‚Ç¨\n\n\nInfrarot-Entfernungsmesser\nDistance IR 4-30cm Bricklet 2.0\n1\n20 ‚Ç¨\n\n\nAnaloger Spannungssensor\nAnalog In Bricklet 3.0\n1\n14 ‚Ç¨\n\n\nSchalldruckpegelsenor\nSound Pressure Level Bricklet\n1\n35 ‚Ç¨\n\n\nMikrocontroller\nMaster Brick 3.2\n2\n35 ‚Ç¨\n\n\nAnschlusskabel 15 cm\nBricklet Kabel 15cm (7p-7p)\n8\n1 ‚Ç¨\n\n\nUSB-A- auf USB-C Kabel\nUSB-A auf USB-C Kabel 100 cm\n1\n6 ‚Ç¨\n\n\nMontageplatte\nMontageplatte 22x22 (12x12cm)\n2\n7 ‚Ç¨\n\n\nSchrauben, Abstandshalter und Muttern\nBefestigungskit 12mm\n4\n2 ‚Ç¨",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#spannende-experimente",
    "href": "experiments.html#spannende-experimente",
    "title": "Experimente",
    "section": "Spannende Experimente",
    "text": "Spannende Experimente\nKapitel f√ºr Kapitel werden wir an unterschiedlichen Experimenten arbeiten. Dabei lernst du nicht nur, wie man Hardware-Komponenten miteinander verbindet, sondern vor allem auch, wie man Computer ‚Äì diese universellen Probleml√∂sungsmaschinen ‚Äì f√ºr eigene Ideen und L√∂sungen programmieren kann. Hier ist der √úberblick, was dich in diesem Buch erwartet:\n\n\n\n\n\n\n\nKapitel\nExperiment(e)\n\n\n\n\n1¬† An oder Aus\nWir schreiben unser erstes Spiel: Wer dr√ºckt den Button am schnellsten?\n\n\n2¬† Farben\nWir bleiben in der Spielwelt und schreiben ein kleines Farb-Memory mit der LED.\n\n\n3¬† Texte\nWir lernen, wie man Texte umst√§ndlich und ohne Tastatur eingeben kann ‚Äì √ºber Handgesten.\n\n\n4¬† Bilder\nWir verbinden Tabellenkalkulation mit Bildern und Touchdisplays ü§Ø\n\n\n5¬† Codes\nWir lernen Morse-Code und wie wir diesen √ºber einen Lautsprecher ausgeben k√∂nnen.\n\n\n6¬† Umwandlung\nWir verwenden einfache Kippschalter, um analoge Werte in digitale Werte umzuwandeln.\n\n\n7¬† Information\n\n\n\n8¬† Sensoren\nWir bauen einen Wasserstandssensor mit einem analogen Spannungssensor.\n\n\n9¬† Signale\nWir basteln einen Pulsmesser aus einem Farbsensor üíì\n\n\n10¬† Protokolle\nWir √ºbertragen Nachrichten √ºber Lichtsignale üî¶\n\n\n11¬† Verschl√ºsselung\nWir verstecken geheime Botschaften in harmlosen Nachrichten üïµÔ∏è‚Äç‚ôÄÔ∏è\n\n\n12¬† Algorithmen\n\n\n\n13¬† Kompression\nWir entwickeln ein Verfahren, um Information zu komprimieren.\n\n\n14¬† Computer\nWir entwickeln eine Rechenmaschine, die zwei Bytes addieren kann, mit nur einem einem Bauteil.\n\n\n15¬† Probleme",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "href": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "title": "Experimente",
    "section": "Frust ist dein Freund ‚Äì zumindest ein bisschen",
    "text": "Frust ist dein Freund ‚Äì zumindest ein bisschen\nEins m√∂chte ich gleich vorwegnehmen: Beim Programmierenlernen ist eine gewisse Portion Frust unvermeidbar. Klingt unangenehm? Ist es auch! Aber es ist zugleich Teil eines enorm wertvollen Lernprozesses. Jeder Fehler, den du machst, ist eine Gelegenheit, um zu verstehen, wie Computer wirklich funktionieren ‚Äì n√§mlich absolut pr√§zise und ohne jede Toleranz f√ºr Fehler.\nComputer sind gnadenlose Lehrer. Sie zeigen dir sofort und unerbittlich, wenn etwas nicht stimmt ‚Äì sei es ein vergessener Punkt, ein falscher Buchstabe oder ein simpler Zahlendreher. Das kann frustrieren, aber genau dieses direkte und sofortige Feedback hilft dir auch, schnell und effektiv zu lernen. Sobald du verstehst, wie du aus Fehlermeldungen sinnvolle Schl√ºsse ziehst und deine Programme entsprechend korrigierst, wirst du belohnt ‚Äì mit Erfolgserlebnissen und einer steilen Lernkurve.\n\n\n\n\n\n\nAbbildung¬†2: Ein frustrierter Frosch\n\n\n\nAlso, wenn mal etwas nicht klappt: Nimm es nicht pers√∂nlich, sondern sieh es als Herausforderung. Atme tief durch, mach dir klar, dass Fehler unvermeidbar und sogar wichtig sind, und probier es noch einmal. Ich verspreche dir: Es lohnt sich!\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "on-or-off.html",
    "href": "on-or-off.html",
    "title": "1¬† An oder Aus",
    "section": "",
    "text": "Setup\nF√ºr unser Experiment in diesem Kapitel ben√∂tigen wir den Button mit der integrierten LED (RGB LED Button 2.0), den wir an den Mikrocontroller (Master Brick 3.2) anschlie√üen. Beides fixieren wir auf Abstandshaltern auf einer Montageplatte, wie in Abbildung¬†1.1 gezeigt. Damit es schneller geht, verwenden wir lediglich zwei Fixierungen pro Ger√§t, was eine ausreichende Stabilit√§t gew√§hrleistet. Vergiss nicht die wei√üen Unterlegscheiben aus Kunsstoff, um die Platinen zu schonen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>An oder Aus</span>"
    ]
  },
  {
    "objectID": "on-or-off.html#setup",
    "href": "on-or-off.html#setup",
    "title": "1¬† An oder Aus",
    "section": "",
    "text": "Abbildung¬†1.1: Einfaches Setup mit Mikrocontroller und Button mit integrierter LED.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>An oder Aus</span>"
    ]
  },
  {
    "objectID": "on-or-off.html#testfahrt-mit-dem-brick-viewer",
    "href": "on-or-off.html#testfahrt-mit-dem-brick-viewer",
    "title": "1¬† An oder Aus",
    "section": "1.1 Testfahrt mit dem Brick Viewer",
    "text": "1.1 Testfahrt mit dem Brick Viewer\nEin Button ist ein denkbar einfaches Ger√§t: Es kennt nur zwei Zust√§nde, entweder ist der Button gedr√ºckt oder nicht. Wenn du den Master Brick √ºber das USB-Kabel an deinen Computer angeschlossen hast, kannst du die Funktion des Buttons einfach √ºber den Brick Viewer kennenlernen. √ñffne dazu den Brick Viewer und klicke auf den Connect-Button.\n\n\n\n\n\n\nAbbildung¬†1.2: √úber den Connect-Button verbindet sich der Brick Viewer mit dem angeschlossenen Master Brick.\n\n\n\nNachdem du verbunden bist, sollte der angeschlossene Master Brick mit seinen Komponenten, die Bricklets genannt werden, im Brick Viewer sichtbar sein. In Abbildung¬†1.3 siehst du, wie das in meinem Fall aussieht. F√ºr jedes Ger√§t wird ein eigener Tab angezeigt, in dem wir die Details zu diesem Ger√§t sehen und die jeweiligen Funktionen ausprobieren k√∂nnen. Gleichzeitig bekommen wir in der Mitte des Brick Viewers eine √ºbersichtliche Liste mit allen gefundenen Ger√§ten angezeigt. Durch die hierarchische Darstellung erkennst du, welches Bricklet an welchem Mikrocontroller (Master Brick) h√§ngt. Wie wir sp√§ter im Buch noch sehen werden k√∂nnen auch mehrer Master Bricks miteinander verbunden werden und somit die m√∂glichen angeschlossenen Bricklets um vier erweitert werden.\n\n\n\n\n\n\nAbbildung¬†1.3: Der Brick Viewer nachdem ihr mit dem Master Brick verbunden seid.\n\n\n\nWechseln wir in den Tab f√ºr den Button, in dem wir s√§mtliche Funktionen des Bricklets einsehen und ausprobieren k√∂nnen. Wie du siehst k√∂nnen wir f√ºr den Button die Farbe einstellen sowie den aktuellen Status des Buttons einsehen. Aktuell ist er ‚Äúreleased‚Äù, wie der Wert neben ‚ÄúButton State‚Äù verr√§t. Probiert es mal aus und dr√ºckt den Button; der Status sollte sich √§ndern.\nInteressant anzumerken ist schon jetzt, dass wir die Farbe der LED sehr fein justieren k√∂nnen. √úber die oberen drei Schieberegler lassen sich die Farbintensit√§ten der drei Farben Rot, Gr√ºn und Blau in einem Wertebereich zwischen 0 und 255 festlegen. Warum genau dieser Wertebereich? Das schauen wir uns in Kapitel Kapitel 2 genauer an.\n\n\n\n\n\n\nAbbildung¬†1.4: Die Ansicht f√ºr den RGB LED Button im Brick Viewer, in der alle Funktionen per Klick im Zugriff sind.\n\n\n\nDer Brick Viewer bietet uns jederzeit die M√∂glichkeit, mit den an den Master Brick angeschlossenen Ger√§te √ºber eine benutzerfreundliche grafische Oberfl√§che zu interagieren. So k√∂nnen wir schnell ein Verst√§ndnis f√ºr die unterschiedlichen Ger√§te bekommen. Um aber L√∂sungen mit den Bauteilen zu entwickeln, die automatisch funktionieren oder √ºber eine individuelle grafische Oberfl√§che gesteuert werden sollen, ben√∂tigen wir die M√∂glichkeit, die Bauteile aus einem Programm heraus anzusprechen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>An oder Aus</span>"
    ]
  },
  {
    "objectID": "on-or-off.html#unser-erstes-programm",
    "href": "on-or-off.html#unser-erstes-programm",
    "title": "1¬† An oder Aus",
    "section": "1.2 Unser erstes Programm",
    "text": "1.2 Unser erstes Programm\nDas 5-zeilige Programm unten stellt eine Verbindung zu unserem Button her. Es handelt sich um unser erstes Programm und es steht stellvertretend f√ºr viele der Programme, die noch folgen. Denn der Programmcode f√ºr die Verbindung mit unseren angeschlossenen Ger√§ten sieht immer sehr √§hnlich aus. Schauen wir ihn uns Zeile f√ºr Zeile an.\n\n\n\n\nListing¬†1.1: Der Boilerplate Code f√ºr die Verbindung mit den Ger√§ten am Beispiel des Buttons.\n\n\n1from tinkerforge.ip_connection import IPConnection\n2from tinkerforge.bricklet_rgb_led_button import BrickletRGBLEDButton\n\n3ipcon = IPConnection()\n4ipcon.connect(\"localhost\", 4223)\n5btn = BrickletRGBLEDButton(\"Ds3\", ipcon)\n\n\n\n\n\n1\n\nHier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.\n\n2\n\nHier importieren wir ein weietres Objekt, das wir zur Darstellung des Buttons als Python-Objekt ben√∂tigen.\n\n3\n\nDie Verbindung erfolgt √ºber eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.\n\n4\n\nMit connect stellen wir eine Verbindung zum angeschlossenen Master Brick her.\n\n5\n\nSchlie√ülich holen wir uns eine virtuelle Instanz des RGB LED Button Bricklets, indem wir die UID nennen und sagen, welche Verbindung (ipcon) genutzt werden soll.\n\n\n\n\n\n1.2.1 Boilerplate Code\nDer Codeauschnitt in Listing¬†1.1 wird uns im Verlauf dieses Buches immer wieder begegnen. Wir ben√∂tigen ihn, um uns am Anfang des Programms mit den Ger√§ten zu verbinden. In der Informatik nennen wir solchen Code, den wir h√§ufig in der gleichen Form ben√∂tigen und fast eins zu eins kopieren k√∂nnen, auch Boilerplate Code. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.\n\n\n1.2.2 Bibliotheken\nBeginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr √§hnliche Befehle, die mit dem Schl√ºsselwort from beginnen. Nach dem Schl√ºsselwort from folgt der Name einer Bibliothek, aus der wir ein f√ºr unser Programm ben√∂tigtes Objekte importieren. Die Kombination der Schl√ºsselw√∂rter from ...import l√§sst sich also w√∂rtlich √ºbersetzen: ‚ÄúAus der Bibliothek X importiere das Objekt Y‚Äù.\nEine Bibliothek in einer Programmiersprache ist die B√ºndelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Das machen wir, damit andere diese Dinge in ihren Programmen nutzen k√∂nnen und das Rad nicht selbst oder neu erfinden m√ºssen. Da Tinkerforge Interesse daran hat, dass ihre Bauteile von m√∂glichst vielen Menschen ohne gro√üe H√ºrden verwendet werden k√∂nnen, stellen sie neben vielen anderen Programmiersprachen auch eine Python-Version ihrer Bibliothek zur Verf√ºgung.\n\n\n1.2.3 Schl√ºsselw√∂rter\nSoeben haben wir unsere ersten beiden Schl√ºsselw√∂rter in Python kennengelernt! Aber was bedeutet das genau? Ein Schl√ºsselwort, das wir im Englischen auch keyword oder reserved keyword nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch h√§ufig Namen vergeben m√ºssen, etwa f√ºr Variablen oder Funktionen. Diese Namen d√ºrfen nicht wie ein Schl√ºsselwort lauten, ansonsten funktioniert unser Programm nicht wie gew√ºnscht. Welche Schl√ºsselw√∂rter es in Python gibt, k√∂nnt ihr hier nachschauen.\nIm Codeausschnitt oben laden wir zuerst das Objekt f√ºr die Verbindung zum angeschlossenen Mikrocontroller, die √ºber eine IP-Verbindung hergestellt wird. Was das genau ist? Sp√§ter mehr dazu. Zus√§tzlich zur IPConnection laden wir anschlie√üend noch die ben√∂tigen Klassen f√ºr die Ger√§te, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur der Button mit integrierter LED.\n\n\n1.2.4 Klassen und Objekte\nMit from ... import importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit importieren ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge sp√§ter wirklich nutzen steht auf einem anderen Blatt.\nIn dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ank√ºndigen. Die erste Klasse heisst IPConnection und die zweite BrickletRGBLEDButton. Der Begriff Klasse ist hier verstehen analog zum Begriff Kategorie. Wir k√∂nnen zu einer Klasse geh√∂rige Objekte erzeugen, und alle Objekte der selben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.\nStellt euch vor, ihr habt eine Klasse namens Auto. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa fahren(), bremsen() oder tanken(). Diese Dinge sollen f√ºr jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Du kannst also sagen: ‚ÄúMein Auto ist ein Objekt der Klasse Auto.‚Äù Jedes Auto hat die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte f√ºr diese Eigenschaftan haben.\nGenauso verh√§lt es sich mit den Klassen, die Tinkerforge f√ºr uns bereitgestellt hat. Die Klasse IPConnection beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen k√∂nnen, und die Klasse BrickletRGBLEDButton beschreibt, wie wir mit dem Button interagieren k√∂nnen. Wenn wir ein Objekt dieser Klasse erstellen, k√∂nnen wir die Funktionen nutzen, die in der Klasse definiert sind. Ein Button muss nicht fahren oder bremsen wie ein Auto. Daf√ºr hat er andere Funktionen, wie etwa get_button_state() oder set_color(), die uns erlauben, den Status des Buttons abzufragen oder die Farbe der integrierten LED zu √§ndern. Eine Eigenschaft jedes Buttons ist seine UID, die eindeutig ist und uns hilft, ihn im System zu identifizieren.\n\n\n1.2.5 Objekte erzeugen\nIn Listing¬†1.1 in Zeile 4 erzeugen wir ein Objekt der Klasse IPConnection. Die fertige Instanz - so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde - speichern wir auf einer Variable mit dem Namen ipcon. Diesen Namen haben wir uns selbst ausgedacht, damit wir sp√§ter darauf zugreifen k√∂nnen. Eine Variable ist also ein Platzhalter f√ºr einen Wert, den wir sp√§ter im Programm verwenden wollen. In diesem Fall ist ipcon der Platzhalter f√ºr die Verbindung zu unserem Mikrocontroller. Was eine Variable genau ist, lernen wir sp√§ter noch genauer kennen.\n\n\n1.2.6 Methoden und Funktionen\n√úber das Objekt ipcon k√∂nnen wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode connect(). Eine Methode ist eine Funktion, die zu einem Objekt geh√∂rt. Wie etwa fahren() oder bremsen() in unserem Auto-Beispiel.\nWir k√∂nnen Methoden aufrufen, um eine bestimmte Aktion auszuf√ºhren. In diesem Fall stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, √ºber den die Verbindung hergestellt werden soll. In unserem Fall ist das ‚Äúlocalhost‚Äù, was f√ºr die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standarm√§√üig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt . nach dem Objekt, gefolgt vom Namen der Methode und den Klammern (), in denen wir eventuell ben√∂tigte Parameter angeben.\n\n\n1.2.7 Ein Objekt f√ºr den Button\nIn Zeile 6 erzeugen wir schlie√ülich ein Objekt der Klasse BrickletRGBLEDButton. Dieses Objekt repr√§sentiert unseren Button und erm√∂glicht es uns, mit ihm zu interagieren. Wir nennen das Objekt btn, was f√ºr Button steht. Auch hier haben wir uns den Namen selbst ausgedacht, um sp√§ter darauf zugreifen zu k√∂nnen. Auch wenn wir grunds√§tzlich Variablennamen frei w√§hlen k√∂nnen, sollten sie immer so gew√§hlt werden, dass sie den Inhalt der Variable beschreiben. Das macht es sp√§ter einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten m√ºssen. Dazu geh√∂ren etwa, dass Variablennamen nicht mit einer Zahl beginnen d√ºrfen und keine Leerzeichen enthalten d√ºrfen. Eine ausf√ºhrliche Liste der Regeln findest du hier.\nDamit haben wir unser erstes Programm von oben nach unten erl√§utert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:\n\n\n\n\n\n\n\nImportieren von Bibliotheken\nWir nutzen Funktionen und Klassen aus einer Bibliothek, um das Rad nicht neu erfinden zu m√ºssen.\n\n\nBoilerplate Code\nCode, der immer fast gleich aussieht und den wir h√§ufig kopieren k√∂nnen.\n\n\nSchl√ºsselw√∂rter\nBegriffe, die in der Programmiersprache eine feste Bedeutung haben und nicht anderweitig verwendet werden d√ºrfen.\n\n\nKlassen und Objekte\nWir erstellen Objekte aus Klassen, die uns bestimmte Funktionen und Eigenschaften bieten.\n\n\nMethoden und Funktionen\nWir rufen Methoden auf, um Aktionen auszuf√ºhren, die zu einem Objekt geh√∂ren.\n\n\nVariablen\nWir speichern Werte in Variablen, um sp√§ter darauf zugreifen zu k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>An oder Aus</span>"
    ]
  },
  {
    "objectID": "on-or-off.html#an-und-aus",
    "href": "on-or-off.html#an-und-aus",
    "title": "1¬† An oder Aus",
    "section": "1.3 An und Aus",
    "text": "1.3 An und Aus\nJetzt, das wir mit dem Button verbunden sind, k√∂nnen wir √ºber das Objekt btn auf die Funktionen des Buttons zugreifen. So k√∂nnen wir beispielsweise die Farbe der LED auf Gr√ºn √§ndern:\n\n1btn.set_color(0, 255, 0)\n\n\n1\n\nHier setzen wir die Farbe der LED auf gr√ºn, indem wir die RGB-Werte f√ºr Rot, Gr√ºn und Blau angeben. In diesem Fall ist Rot auf 0, Gr√ºn auf 255 und Blau auf 0 gesetzt.\n\n\n\n\n\nüéÆ Mini Reaction Game\nTheme: ‚ÄúAre you faster than a computer?‚Äù\nSetup:\n\nFlash an LED randomly after a delay, and students must press the correct button as fast as possible.\nWrong button or slow response ‚Üí ‚Äúfail‚Äù message.\nDisplay or rank response times.\n\nTeachable moment: Real-time input processing, event handling, and how computers handle asynchronous input.\nüß† Bonus Concept: Binary Memory Challenge\nTheme: ‚ÄúSimon Says: Binary Edition‚Äù\nSetup:\n\nSystem shows a sequence of binary numbers via LED flashes (e.g., 01 ‚Üí left off, right on).\nStudents must repeat the sequence by pressing the buttons.\nEach round adds another number.\n\nTeachable moment: Binary perception, memory, encoding sequences, and reinforcing input logic.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>An oder Aus</span>"
    ]
  },
  {
    "objectID": "colors.html",
    "href": "colors.html",
    "title": "2¬† Farben",
    "section": "",
    "text": "Setup\nF√ºr dieses Kapitel ben√∂tigen wir zus√§tzlich zum Button mit integrierter LED (RGB LED Button 2.0) noch die separate LED (RGB LED Bricklet 2.0), die wir ebenfalls an den Mikrocontroller (Master Brick 3.2) anschlie√üen. Alle Ger√§te fixieren wir auf einer Montageplatte, wie in der Abbildung gezeigt.\nDenke daran, wie Ampeln Farben verwenden, um wichtige Informationen zu vermitteln ‚Äì Rot bedeutet Stopp, Gr√ºn bedeutet Los, und Gelb bedeutet Vorsicht. Genauso werden auf deinem Computer oder Smartphone √ºberall Farben eingesetzt: Schaltfl√§chen werden blau, wenn du mit der Maus dar√ºber f√§hrst, Benachrichtigungen erscheinen vielleicht in Rot, und Apps nutzen verschiedene Farben, um dir die Navigation zu erleichtern. All diese Farben werden mit Systemen wie RGB erzeugt und gesteuert.\nFarben sind auch in Bildern und Videos unverzichtbar. Jedes Foto, das du auf deinem Bildschirm siehst, besteht aus winzigen Punkten, den sogenannten Pixeln, und die Farbe jedes Pixels wird mit dem RGB-System festgelegt. Wenn du ein Video anschaust, zeigt dein Ger√§t schnell hintereinander eine Folge von Bildern, die jeweils aus Millionen farbiger Pixel bestehen, um eine Bewegung vorzut√§uschen. Durch das Mischen unterschiedlicher Mengen von Rot, Gr√ºn und Blau f√ºr jedes Pixel k√∂nnen Computer realistische Fotos, lebendige Animationen und naturgetreue Videos darstellen.\nDas RGB-System steht f√ºr Rot, Gr√ºn und Blau ‚Äì die Grundfarben des Lichts. Durch das Kombinieren dieser drei Farben in unterschiedlichen Intensit√§ten k√∂nnen wir ein breites Farbspektrum erzeugen. Dieses System wird auf Computerbildschirmen, in digitaler Kunst und beim Programmieren verwendet, um Farben zu definieren und zu steuern.\nZum Beispiel erm√∂glicht uns das RGB-System beim Programmieren, die Farbe einer LED oder einer Grafik festzulegen, indem wir angeben, wie viel Rot, Gr√ºn und Blau gemischt werden sollen. Jede Farbkomponente ‚Äì Rot, Gr√ºn und Blau ‚Äì erh√§lt einen Wert von 0 (keine Intensit√§t) bis 255 (volle Intensit√§t). Durch die Auswahl verschiedener Werte f√ºr jede Komponente k√∂nnen wir jede beliebige Farbe erzeugen.\nProgrammierkonzepte:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#setup",
    "href": "colors.html#setup",
    "title": "2¬† Farben",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\nProgrammieren der LED, die in verschiedenen Farben aufleuchten soll. Jeder Farbe ist eine Taste auf der Tastatur zugeordnet, die der Spieler so schnell wie m√∂glich dr√ºcken muss, nachdem die LED in der jeweiligen Farbe aufleuchtet.\nDas Programm kann zun√§chst linear ablaufen - also zun√§chst nur eine Runde, dann zwei kopiert hintereinander, bis zur Einf√ºhrung einer Schleife.\n\n\n1from tinkerforge.ip_connection import IPConnection\n2from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\n3ipcon = IPConnection()\n4ipcon.connect(\"localhost\", 4223)\n5btn = BrickletRGBLEDV2(\"abC\", ipcon)\n\n1\n\nImportieren des Objekts zum Herstellen einer Verbindung mit dem Master Brick.\n\n2\n\nImportieren des Objekts zur Darstellung der RGB LED als Python-Objekt.\n\n3\n\nEine neue Instanz einer IP-Verbindung erstellen.\n\n4\n\nEine Verbindung zu angeschlossenen Master Brick herstellen.\n\n5\n\nEine virtuelle Instanz des RGB LED Bricklets in unserem Programm erzeugen.\n\n\n\n\n\n\n\nEinf√ºhrung RGB-LED\nEinf√ºhrung: Sie kann auf jede beliebige Farbe eingestellt werden\nEinf√ºhrung des RGB-Systems als DAS Codesystem zur Darstellung von Farben im Computer (ohne zu sehr auf Bin√§rzahlen einzugehen)\n\n\n\nFunktionsparameter (set_rgb_value(r, g, b))\n\nled.set_rgb_value(255, 255, 255)\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "3¬† Texte",
    "section": "",
    "text": "Setup\nF√ºr dieses Kapitel ben√∂tigen wir die LED (RGB LED Bricklet 2.0) und den Infrarot-Entfernungsmesser Distance IR 4-30cm Bricklet 2.0. Beide Ger√§te schlie√üen wir an den Mikrocontroller (Master Brick 3.2) and und fixieren alle drei auf einer Montageplatte. Wie in der Abbildung gezeigt, soll der Entfernungsmesser dabei nach oben zeigen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#setup",
    "href": "text.html#setup",
    "title": "3¬† Texte",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#texte-ganz-ohne-tastatur",
    "href": "text.html#texte-ganz-ohne-tastatur",
    "title": "3¬† Texte",
    "section": "3.1 Texte ‚Äì ganz ohne Tastatur?",
    "text": "3.1 Texte ‚Äì ganz ohne Tastatur?\nJa, ich gebe zu: Eine Tastatur ist schon richtig praktisch. Schnell tippen wir damit Buchstaben, Zahlen, Satz- und Sonderzeichen (wie neue Zeilen und Leerzeichen) ein. Aber stell dir mal vor: Wie k√∂nnte ich eigentlich dieses Buch schreiben, wenn ich keine Tastatur h√§tte?\nTats√§chlich gibt es spannende Alternativen! Hast du schon mal versucht, Texte zu diktieren? Google Docs oder Microsoft Word bieten mittlerweile ziemlich gute M√∂glichkeiten daf√ºr. Anfangs f√ºhlt sich das ungewohnt an, aber ich kenne Menschen, die darauf schw√∂ren und damit sogar produktiver sind.\nHeute wollen wir aber bewusst einmal einen Schritt zur√ºckgehen und das Tippen absichtlich erschweren. Klingt komisch? Macht aber Sinn! Denn wenn wir das Eingeben von Texten schwieriger gestalten, lernen wir einerseits, unsere Tastaturen wieder richtig zu sch√§tzen. Andererseits verstehen wir dann besser, wie Texte im Hintergrund verarbeitet und gespeichert werden.\nWie w√§re es also mit einer Tastatur, die auf Handgesten basiert? Klingt verr√ºckt? Perfekt ‚Äì genau das machen wir!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "href": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "title": "3¬† Texte",
    "section": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten",
    "text": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten\nStarten wir ganz simpel. Wir bauen zuerst eine Art ‚ÄúKnopf‚Äù oder Button, der auf Handgesten reagiert. Daf√ºr verwenden wir einen der Infrarot-Abstandssensoren ‚Äì oder wie er bei Tinkerforge hei√üt: Distance IR 4-30cm Bricklet 2.0. Wie der Name schon sagt, misst der Sensor Entfernungen von 4 bis maximal 30 cm.\nUm den Sensor in unserem Programm zu nutzen, k√∂nnen wir ganz entspannt den Grundcode (Boilerplate-Code) aus den vorherigen Kapiteln √ºbernehmen. Nur zwei kleine Anpassungen brauchen wir noch speziell f√ºr unseren Sensor:\n\nfrom tinkerforge.ip_connection import IPConnection\n1from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n2ir_sensor = BrickletDistanceIRV2(\"\", ip_con)\n\n\n1\n\nHier importieren wir die Klasse f√ºr den IR-Sensor.\n\n2\n\nHier erzeugen wir eine konkrete Instanz und verbinden uns mit dem angeschlossenen Sensor. Vergiss nicht, deine UID hier einzutragen!\n\n\n\n\nWas kann der Sensor? Eigentlich hat er nur eine Funktion:\n\n1distance = ir_sensor.get_distance()\n2print(f\"Objekt ist {distance/100} cm entfernt\")\n\n\n1\n\nDie Funktion get_distance() fragt den aktuell gemessenen Wert ab.\n\n2\n\nDer Sensor liefert den Wert in Zentimeter * 100 zur√ºck.\n\n\n\n\nAber wie l√§sst sich mit den Entfernungswert ein Button umsetzen? Dazu vergegenw√§rtigen wir uns, was ein herk√∂mmlicher Button eigentlich ist und wie er funktioniert. Ein Button, wie wir ihn auf einer Tastatur finden, kennt zwei Zust√§nde: Gedr√ºckt und nicht gedr√ºckt. An oder aus. Wenn wir eine Taste dr√ºcken, so schlie√üen wir dar√ºber einen Stromkreis, der in einem winzigen Mikroprozessor m√ºndet. Dieser Prozessor erkennt durch laufendes Scannen s√§mtlicher Verbindungen zu den Tasten (die als Matrix angeordnet sind), durch welche Kreise Strom flie√üt und kann so auf die gedr√ºckte Taste schlie√üen. Der Mikroprozessor ermittelt dann anhand der Koordinate in der Matrix einen so gennanten Scan Code, der f√ºr jede Taste anders lautet. Dieser Code wird als bin√§re Folge von Nullen und Einsen √ºber das USB-Kabel an den Computer geschickt und dort von dem aktiven Programm - etwa einer Textverarbeitungssoftware - in ein Codesystem umgewandelt, das Zeichen abbilden kann. So wie etwa das ASCII-Codesystem, das wir weiter unten kennenlernen.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "images.html",
    "href": "images.html",
    "title": "4¬† Bilder",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\n\nEinf√ºhrung in die Idee einer Pixelmatrix aus Farbwerten als Bild\nVerwendung des LCD-Displays zur Veranschaulichung, auch wenn nur schwarz/wei√ü\nVerwendung von Zeichen auf dem LCD, um Pixel-Bitmaps f√ºr Schriftarten hervorzuheben\nStudierende nutzen Bitmap-Sheet, um ein eigenes Logo zu entwerfen und auf dem LCD anzuzeigen\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "codes.html",
    "href": "codes.html",
    "title": "5¬† Codes",
    "section": "",
    "text": "Experiment\n\n\n\nMorse-Code √ºber Piezo Speaker\n\nEinf√ºhrung des Piezo Speaker\nCodesysteme\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Codes</span>"
    ]
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#setup",
    "href": "conversion.html#setup",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Experiment\n\n\n\nMit 4 Kippschaltern und 4 Widerst√§nden bauen wir einen Digital-To-Analog-Converter (DAC). Dazu kommt ein Breadboard und diveser √úberbr√ºckungskabel zum Einsatz. Au√üerdem brauchen wir den Analog In 3.0 von Tinkerforge.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-in-den-computer-hinein",
    "href": "conversion.html#der-weg-in-den-computer-hinein",
    "title": "6¬† Umwandlung",
    "section": "6.1 Der Weg in den Computer hinein",
    "text": "6.1 Der Weg in den Computer hinein",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-aus-dem-computer-heraus",
    "href": "conversion.html#der-weg-aus-dem-computer-heraus",
    "title": "6¬† Umwandlung",
    "section": "6.2 Der Weg aus dem Computer heraus",
    "text": "6.2 Der Weg aus dem Computer heraus\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "information.html",
    "href": "information.html",
    "title": "7¬† Information",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "information.html#setup",
    "href": "information.html#setup",
    "title": "7¬† Information",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "sensors.html",
    "href": "sensors.html",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#setup",
    "href": "sensors.html#setup",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\nAnalog vs.¬†digital\nBaue einen Wasserstandssensor mit einem Widerstand und dem Analog-In-Bricklet.\nOder: Feuchtigkeitssensor in eine Pflanze stecken\nOder: Ber√ºhrungssensor\nOder: Pulssensor (Farbsensor)\nIntegriere die RGB-LED irgendwie\nFarbsensor",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#aufgaben",
    "href": "sensors.html#aufgaben",
    "title": "8¬† Sensoren",
    "section": "Aufgaben",
    "text": "Aufgaben\n\nProgrammiere einen Batteriedoktor mithilfe des Analog In Sensors\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "signals.html",
    "href": "signals.html",
    "title": "9¬† Signale",
    "section": "",
    "text": "Setup\nHast du dich schon einmal gefragt, wie dein Fitness-Tracker deinen Puls messen kann, obwohl du nur einen Finger auflegst? Diese Frage f√ºhrt uns direkt zu einem spannenden Konzept: Signalen. Alles, was wir mit Sensoren messen, sind zun√§chst einmal beliebige Gr√∂√üen. Doch nicht alles, was wir messen, ist f√ºr uns relevant. Wir suchen nach Mustern in diesen Daten ‚Äî eben genau diesen Mustern, die wir als Signale bezeichnen. Alles andere, was uns von diesen Signalen ablenkt, nennen wir Rauschen. Unser Ziel: Wir m√∂chten herausfinden, wie wir Signale effektiv vom Rauschen unterscheiden k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#setup",
    "href": "signals.html#setup",
    "title": "9¬† Signale",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\nMithilfe des Farbsensors bauen wir einen Pulsmesser.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "href": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "title": "9¬† Signale",
    "section": "9.1 Pulsmesser: Dein Finger als Signalquelle",
    "text": "9.1 Pulsmesser: Dein Finger als Signalquelle\nErinnerst du dich noch an den Farbsensor aus Kapitel 8? Er misst nicht nur die Intensit√§t des RGB-Spektrums, sondern auch die allgemeine Lichtintensit√§t, auch Illuminance genannt. Hier kommt die spannende Tatsache ins Spiel: Genau dieses Prinzip steckt hinter den Pulsmessern in Fitnesstrackern. Ja, genau der Sensor, der Licht misst, verr√§t dir, wie schnell dein Herz schl√§gt!\nAber wie genau funktioniert das? Stell dir vor, du legst deinen Zeigefinger direkt auf den Sensor und schaltest die integrierte wei√üe LED an. Das Licht der LED trifft auf deinen Finger und wird reflektiert. Dein Finger sieht f√ºr dich immer gleich aus, aber tats√§chlich sorgt dein Herzschlag daf√ºr, dass dein Finger mal minimal heller und mal dunkler erscheint. Das liegt daran, dass Blut in rhythmischen Sch√ºben durch die Gef√§√üe gepumpt wird. Diese winzigen Ver√§nderungen, die du mit blo√üem Auge nicht sehen kannst, werden vom sensiblen Farbsensor deutlich wahrgenommen.\nSchauen wir uns das einmal genauer an: Wenn du dir die gemessene Lichtintensit√§t √ºber den Zeitverlauf im Brick Viewer ansiehst, kannst du deinen Pulsschlag tats√§chlich erkennen‚Äîer wird sichtbar als kleine, regelm√§√üige Ausschl√§ge oder Peaks. Faszinierend, oder? So kannst du beobachten, wie aus etwas so scheinbar Einfachem wie Licht ein Signal entsteht, das dir Informationen √ºber deinen K√∂rper liefert.\n\n\n\n\n\n\nAbbildung¬†9.1: Dein Puls im Brick Viewer",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#vom-diagramm-zur-zahl",
    "href": "signals.html#vom-diagramm-zur-zahl",
    "title": "9¬† Signale",
    "section": "9.2 Vom Diagramm zur Zahl",
    "text": "9.2 Vom Diagramm zur Zahl\nAuch wenn du das Signal im Liniendiagramm in Abbildung¬†9.1 bereits deutlich sehen kannst, bleibt eine spannende Herausforderung bestehen: Wie schreibst du ein Programm, das aus diesen Daten deinen Puls als konkrete Zahl, zum Beispiel ‚Äú60 Schl√§ge pro Minute‚Äù, berechnet? Genau daf√ºr sind wir ja hier ‚Äì um herauszufinden, wie man solche kniffligen Aufgaben l√∂st. Lass uns gemeinsam starten!\nZun√§chst m√ºssen wir den Farbsensor in unserem Python-Programm auslesen. Den notwendigen Code daf√ºr haben wir im vorherigen Kapitel 8 bereits kennengelernt.\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\n\n\n1\n\nAchtung: Vergiss nicht, hier deine eigene UID einzusetzen. Diese findest du im Brick Viewer.\n\n\n\n\nJetzt haben wir Zugriff auf die Funktionen des Sensors und k√∂nnen etwa die Lichtintensit√§t messen:\n\n1color_sensor.set_light(True)\n2color_sensor.set_configuration(1, 1)\nilluminance = color_sensor.get_illuminance()\n\n\n1\n\nSchaltet die integrierte LED des Sensors an.\n\n2\n\nStellt die Werte f√ºr Gain und Integration Time auf 4x und 24ms. Diese Einstellung scheinen gut zu funktionieren, um den Puls zu messen.\n\n\n\n\nDer zur√ºckgegebene Wert h√§ngt von zwei Einstellungen ab: Gain (Verst√§rkung) und Integration Time (Messzeit). Je l√§nger die Messzeit, desto genauer die Werte ‚Äì allerdings k√∂nnen dann weniger Messungen pro Sekunde durchgef√ºhrt werden. Laut Dokumentation k√∂nnen wir aus dem gemessenen Wert die Lichtintensit√§t in Lux wie folgt berechnen:\n\n1illuminance_lux = illuminance * 700 / 4 / 24\n\n\n1\n\nDer Wert 4 beschreibt ein 4-fache Verst√§rkung (Gain) und die 24 steht f√ºr 24ms Integration Time\n\n\n\n\nUm deinen Puls zu berechnen, m√ºssen wir jetzt mehrere Werte in kurzen Abst√§nden messen. Warum? Weil wir die regelm√§√üigen Tief- und Hochpunkte erkennen wollen. Ein Tiefpunkt entsteht, wenn dein Finger am dunkelsten ist ‚Äì hier ist also gerade besonders viel Blut im Finger. Die Hochpunkte markieren dagegen den Moment, in dem das Blut gr√∂√ütenteils wieder zur√ºckgeflossen ist. Jeder Herzschlag erzeugt genau einen Tief- und einen Hochpunkt. Finden wir diese Punkte, k√∂nnen wir einfach die Zeitabst√§nde messen und daraus die Pulsfrequenz berechnen.\nBeginnen wir damit, unsere Messungen in einer Schleife durchzuf√ºhren. Das ist eine praktische Methode, kontinuierlich Daten zu erfassen:\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n    print(f\"Lichtintensit√§t in Lux: {illuminance_lux}\")\n\nLass uns das Programm einmal ausprobieren. Es sieht aktuell so aus:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\ncolor_sensor.set_light(True)\ncolor_sensor.set_configuration(1, 1)\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n2    print(f\"Lichtintensit√§t in Lux: {illuminance_lux:.2f}  \", end=\"\\r\")\n\n\n1\n\nDenke daran, die UID durch die deines Sensors zu ersetzen.\n\n2\n\nDer Parameter end=\"\\r\" sorgt daf√ºr, dass nicht jede Ausgabe in eine neue Zeile geschrieben wird. Stattdessen wird immer an den Anfang der selben Zeile gesprungen. Das \\r ist das Symbol f√ºr Carriage Return.\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "protocols.html",
    "href": "protocols.html",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "protocols.html#setup",
    "href": "protocols.html#setup",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "encryption.html",
    "href": "encryption.html",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "encryption.html#setup",
    "href": "encryption.html#setup",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "algorithms.html",
    "href": "algorithms.html",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "algorithms.html#setup",
    "href": "algorithms.html#setup",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "compression.html",
    "href": "compression.html",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "compression.html#setup",
    "href": "compression.html#setup",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "computer.html",
    "href": "computer.html",
    "title": "14¬† Computer",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#logik-und-arithmetik",
    "href": "computer.html#logik-und-arithmetik",
    "title": "14¬† Computer",
    "section": "14.1 Logik und Arithmetik",
    "text": "14.1 Logik und Arithmetik\n\nLogikgatter\n8-Bit-Additionsmaschine\nSubtraktion, Division, Multiplikation",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#die-von-neumann-architektur",
    "href": "computer.html#die-von-neumann-architektur",
    "title": "14¬† Computer",
    "section": "14.2 Die von-Neumann-Architektur",
    "text": "14.2 Die von-Neumann-Architektur",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "href": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "title": "14¬† Computer",
    "section": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers",
    "text": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers\n\nx = 10\nprint(f\"Adresse im Speicher der Variable 'x': {hex(id(x))}\")\nx= 20\nprint(f\"Neue Adresse im Speicher der Variable 'x': {hex(id(x))}\")\n\nAdresse im Speicher der Variable 'x': 0x7ffa9f067448\nNeue Adresse im Speicher der Variable 'x': 0x7ffa9f067588\n\n\n\nnames = [\"Max\", \"Kim\", \"Hildegard\"]\nprint(f\"Adresse im Speicher der Variable 'names': {hex(id(names))}\")\nnames.append(\"Heinrich\")\nprint(f\"Die Adresse im Speicher der Variable 'names' bleibt identisch: {hex(id(names))}\")\n\nAdresse im Speicher der Variable 'names': 0x170cc5505c0\nDie Adresse im Speicher der Variable 'names' bleibt identisch: 0x170cc5505c0\n\n\n\n\n\n\n\n\nLeseempfehlung\n\n\n\nUm tiefer in die Themen dieses Kapitels einzusteigen, empfehle ich euch Petzold (2022) zu lesen . Es lohnt sich, das Buch von Vorne nach Hinten zu verschlingen.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "problems.html",
    "href": "problems.html",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "problems.html#setup",
    "href": "problems.html#setup",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Adami, Christoph. 2016. ‚ÄúWhat Is Information?‚Äù\nPhilosophical Transactions of the Royal Society A: Mathematical,\nPhysical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, and Dennis Brylow. 2020. Computer Science: An\nOverview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer\nHardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, and John Horton Conway. 2004. How to Solve It: A New\nAspect of Mathematical Method. Expanded Princeton Science Library\ned. Princeton Science Library. Princeton [N.J.]: Princeton University\nPress.\n\n\nScott, John C. 2009. But How Do It Know?: The Basic Principles of\nComputers for Everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]