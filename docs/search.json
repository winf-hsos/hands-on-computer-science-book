[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Computer Science",
    "section": "",
    "text": "Vorwort\nGlückwunsch, ihr seid angekommen! Egal, wie euer Weg hierher aussah: Ihr habt dieses Buch geöffnet. Vielleicht studiert ihr an der Hochschule Osnabrück und wurdet (zu eurem Glück) dazu verpflichtet, oder ihr seid ganz bewusst hier gelandet und freut euch darauf, etwas Neues zu lernen – genau wie ich.\nDieses Buch entstand ursprünglich, um meinen Veranstaltungen an der Hochschule Osnabrück eine verständliche und praxisnahe Grundlage zu geben. Es dient als Hauptlektüre für meine Vorlesungen und als Nachschlagewerk für alle, die eine Sitzung verpasst haben oder Themen eigenständig vertiefen möchten. Besonders willkommen sind Quereinsteiger, Wiederholer und neugierige Menschen, die bisher noch gar keinen Kontakt mit der Hochschule Osnabrück hatten.\nHier bekommt ihr keine trockene Theorie, sondern eine praxisnahe Einführung in die Grundlagen moderner Computer und unserer digitalen Welt. Das Fach dahinter heißt auf Deutsch Informatik, international Computer Science. Der Titel Hands-On Computer Science verrät bereits, worum es geht: Es wird praktisch, und zwar von Anfang an.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#was-macht-dieses-buch-besonders",
    "href": "index.html#was-macht-dieses-buch-besonders",
    "title": "Hands-On Computer Science",
    "section": "Was macht dieses Buch besonders?",
    "text": "Was macht dieses Buch besonders?\nLehrbücher zur Informatik gibt es reichlich. Viele sind großartig, aber kaum eines passt genau zu dem, was ich mit meinen Studierenden vorhabe. Woran liegt das?\nViele klassische Informatikbücher versuchen, das gesamte Fach möglichst umfassend abzubilden. Das ist sinnvoll für angehende Informatikerinnen und Informatiker, aber meine Zielgruppe seid ihr: Studierende in Studiengängen wie Management nachhaltiger Ernährungssysteme, Lebensmittelproduktion oder Agrarsystemtechnologien – oder ihr seid gar nicht an der Hochschule, sondern wollt euch einfach einen besseren Zugang zur digitalen Welt erarbeiten.\nKurz gesagt: Dieses Buch ist für alle gedacht, die in die digitale Welt eintauchen wollen, ohne sich mit komplizierten Details zu überfordern. Dafür braucht ihr kein allumfassendes Nachschlagewerk, sondern einen klaren roten Faden, der euch Schritt für Schritt an die grundlegenden Konzepte heranführt.\nViele Bücher versprechen Praxisnähe, doch oft endet sie in nüchternen Übungsaufgaben am Kapitelende. Genau hier setzt Hands-On Computer Science an und macht drei Dinge anders:\n\nIhr lernt informatische Konzepte anhand spannender Experimente mit Microcontrollern, Sensoren, Buttons, LEDs und Displays.\nWir führen wichtige Konzepte früh ein, gehen aber erst nach und nach ins Detail und wiederholen sie regelmäßig.\nTheorie und Praxis sind nicht getrennt, sondern eng miteinander verbunden – Programmieren und informatische Grundlagen lernt ihr gleichzeitig.\n\nSchon ab Kapitel 1 beginnt ihr zu programmieren, und zwar nicht abstrakt, sondern konkret mit Hardware-Bauteilen wie einer LED. Im Laufe des Buches lernt ihr Schritt für Schritt neue Hardwarekomponenten kennen, die direkt mit relevanten informatischen Konzepten verknüpft sind. So schließt ihr nicht nur eine Reihe Experimente erfolgreich ab, sondern baut fast nebenbei ein solides Fundament in Informatik und Programmierung auf. Wenn alles gut läuft, merkt ihr kaum, wie schnell ihr gelernt habt.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#tipps-für-die-lektüre",
    "href": "index.html#tipps-für-die-lektüre",
    "title": "Hands-On Computer Science",
    "section": "Tipps für die Lektüre",
    "text": "Tipps für die Lektüre\nWeil es in diesem Buch viel ums Programmieren geht, findet ihr viele Codeblöcke und Code-Snippets. Als Einstiegssprache verwenden wir Python. Warum ausgerechnet Python? Das erfahrt ihr später.\nCodeblöcke sind deutlich vom übrigen Text abgehoben, grau hinterlegt und in einer Schreibmaschinenschrift dargestellt, etwa Courier New oder Consolas. Hier ein kleines Beispiel:\n\n1led.set_rgb_value(0, 0, 0)\n2led.set_rgb_value(255, 255, 255)\n\nprint(\"Diese Zeile hat keine Annotation\")\n\n3# Lasse die LED blau aufleuchten\nled.set_rgb_value(0, 0, 255)\n\n\n1\n\nSchaltet die LED aus, weil der RGB-Code (0, 0, 0) die Farbe Schwarz ergibt.\n\n2\n\nSchaltet die LED auf weißes Licht, weil dreimal 255 die Farbe Weiß ergibt.\n\n3\n\nAuch Kommentare sind für kurze Erläuterungen nützlich.\n\n\n\n\nDie Annotationen sind mit einer kleinen Zahl versehen. Wenn ihr das Buch online lest und mit der Maus über diese Zahl fahrt, erscheint ein Tooltip, der die jeweilige Codezeile erklärt. Das funktioniert nur online, nicht in der PDF- oder Druckversion. Dort sind die Erläuterungen unter dem Codeblock aufgeführt.\nWeil wir in jedem Kapitel ein Programm Schritt für Schritt entwickeln und es dadurch immer länger wird, lasse ich gelegentlich Stellen im Code weg, um den Fokus auf neu hinzugekommene Zeilen zu legen. Diese Auslassungen markiere ich in den Codeblöcken mit drei Punkten (...). Keine Sorge: Den gesamten Code findet ihr stets am Ende eines Abschnitts. Außerdem liegt jedes Programm im zu diesem Buch gehörigen GitHub-Repository unter:\nhttps://github.com/winf-hsos/hands-on-computer-science-code\nNoch ein Tipp: Wenn ihr mit der Maus über einen Codeblock fahrt, erscheint rechts oben ein Clipboard-Symbol. Ein Klick darauf kopiert den Code direkt in eure Zwischenablage, und ihr könnt ihn anschließend in euer geöffnetes Visual Studio Code oder eine andere IDE einfügen und ausprobieren. In der Online-Version lassen sich manche Codeblöcke einklappen, damit ihr weniger scrollen müsst.\nAlles klar? Dann schauen wir uns an, was uns in diesem Buch erwartet!\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "experiments.html",
    "href": "experiments.html",
    "title": "Experimente",
    "section": "",
    "text": "Hands-On Programmieren lernen\nHast du dich schon einmal gefragt, wie man Informationen über Licht übertragen kann? Oder wie man mit Licht den Puls messen kann? Oder wie man mit zwei einfachen Kabeln einen Wasserstandssensor baut? Das alles klingt vielleicht weit hergeholt, ist aber tatsächlich machbar – und wie genau, das wollen wir in diesem Buch herausfinden! Dabei werden wir nicht nur die digitale Welt der Computer und Programmierung kennenlernen, sondern auch mit spannenden Geräten in der analogen Welt arbeiten. In jedem Kapitel arbeiten wir mit anderen Geräten, die dir unterschiedliche Facetten der digitalen Welt näherbringen und gleichzeitig ermöglichen, das Programmieren spielerisch zu erlernen.\nHier ein Überblick über die Geräte, mit denen wir gemeinsam experimentieren werden. Zusammengefasst kosten alle Komponenten 249 €. Aber keine Sorge: Wenn du das Buch im Rahmen meines Moduls „Digitalisierung und Programmierung“ an der Hochschule Osnabrück liest, erhältst du für das gesamte Semester ein komplettes Hardware-Kit.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#hands-on-programmieren-lernen",
    "href": "experiments.html#hands-on-programmieren-lernen",
    "title": "Experimente",
    "section": "",
    "text": "Abbildung 1: Tinkerforge Workbench mit vielen Geräten\n\n\n\n\n\n\n\nWas?\nBauteil\nAnzahl\nPreis pro Stück\n\n\n\n\nBunte LED\nRGB LED Bricklet 2.0\n1\n8 €\n\n\nButton mit integrierter, bunter LED\nRGB LED Button Bricklet\n1\n15 €\n\n\nLicht- und Farbsensor\nColor Bricklet 2.0\n1\n17 €\n\n\nLCD Touchdisplay\nLCD 128x64 Bricklet\n1\n33 €\n\n\nPiezo Lautsprecher\nPiezo Speaker Bricklet 2.0\n1\n19 €\n\n\nInfrarot-Entfernungsmesser\nDistance IR 4-30cm Bricklet 2.0\n1\n20 €\n\n\nAnaloger Spannungssensor\nAnalog In Bricklet 3.0\n1\n14 €\n\n\nSchalldruckpegelsenor\nSound Pressure Level Bricklet\n1\n35 €\n\n\nMikrocontroller\nMaster Brick 3.2\n2\n35 €\n\n\nAnschlusskabel 15 cm\nBricklet Kabel 15cm (7p-7p)\n8\n1 €\n\n\nUSB-A- auf USB-C Kabel\nUSB-A auf USB-C Kabel 100 cm\n1\n6 €\n\n\nMontageplatte\nMontageplatte 22x22 (12x12cm)\n2\n7 €\n\n\nSchrauben, Abstandshalter und Muttern\nBefestigungskit 12mm\n4\n2 €",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#spannende-experimente",
    "href": "experiments.html#spannende-experimente",
    "title": "Experimente",
    "section": "Spannende Experimente",
    "text": "Spannende Experimente\nKapitel für Kapitel werden wir an unterschiedlichen Experimenten arbeiten. Dabei lernst du nicht nur, wie man Hardware-Komponenten miteinander verbindet, sondern vor allem auch, wie man Computer – diese universellen Problemlösungsmaschinen – für eigene Ideen und Lösungen programmieren kann. Hier ist der Überblick, was dich in diesem Buch erwartet:\n\n\n\n\n\n\n\nKapitel\nExperiment(e)\n\n\n\n\n1  Farben\nWir lassen eine LED einen Regenbogenfarbverlauf über die Zeit erzeugen.\n\n\n3  Texte\nWir lernen, wie man Texte umständlich und ohne Tastatur eingeben kann – über Handgesten.\n\n\n4  Bilder\nWir verbinden Tabellenkalkulation mit Bildern und Touchdisplays 🤯\n\n\n?sec-codes\nWir lernen Morse-Code und wie wir diesen über einen Lautsprecher ausgeben können.\n\n\n?sec-conversion\nWir verwenden einfache Kippschalter, um analoge Werte in digitale Werte umzuwandeln.\n\n\n?sec-information\n\n\n\n?sec-sensors\nWir bauen einen Wasserstandssensor mit einem analogen Spannungssensor.\n\n\n?sec-signals\nWir basteln einen Pulsmesser aus einem Farbsensor 💓\n\n\n?sec-protocols\nWir übertragen Nachrichten über Lichtsignale 🔦\n\n\n?sec-encryption\nWir verstecken geheime Botschaften in harmlosen Nachrichten 🕵️‍♀️\n\n\n?sec-algorithms\n\n\n\n?sec-compression\nWir entwickeln ein Verfahren, um Information zu komprimieren.\n\n\n?sec-computer\nWir entwickeln eine Rechenmaschine, die zwei Bytes addieren kann, mit nur einem einem Bauteil.\n\n\n?sec-problems",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "href": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "title": "Experimente",
    "section": "Frust ist dein Freund – zumindest ein bisschen",
    "text": "Frust ist dein Freund – zumindest ein bisschen\nEins möchte ich gleich vorwegnehmen: Beim Programmierenlernen ist eine gewisse Portion Frust unvermeidbar. Klingt unangenehm? Ist es auch! Aber es ist zugleich Teil eines enorm wertvollen Lernprozesses. Jeder Fehler, den du machst, ist eine Gelegenheit, um zu verstehen, wie Computer wirklich funktionieren – nämlich absolut präzise und ohne jede Toleranz für Fehler.\nComputer sind gnadenlose Lehrer. Sie zeigen dir sofort und unerbittlich, wenn etwas nicht stimmt – sei es ein vergessener Punkt, ein falscher Buchstabe oder ein simpler Zahlendreher. Das kann frustrieren, aber genau dieses direkte und sofortige Feedback hilft dir auch, schnell und effektiv zu lernen. Sobald du verstehst, wie du aus Fehlermeldungen sinnvolle Schlüsse ziehst und deine Programme entsprechend korrigierst, wirst du belohnt – mit Erfolgserlebnissen und einer steilen Lernkurve.\n\n\n\n\n\n\nAbbildung 2: Ein frustrierter Frosch\n\n\n\nAlso, wenn mal etwas nicht klappt: Nimm es nicht persönlich, sondern sieh es als Herausforderung. Atme tief durch, mach dir klar, dass Fehler unvermeidbar und sogar wichtig sind, und probier es noch einmal. Ich verspreche dir: Es lohnt sich!\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "prerequisites.html",
    "href": "prerequisites.html",
    "title": "Voraussetzungen",
    "section": "",
    "text": "Visual Studio Code\nUm die Experimente in diesem Buch durchführen zu können, benötigt ihr die folgende Software auf eurem Computer:\nEine beliebte Entwicklungsumgebung, die ihr kostenlos herunterladen könnt. Hier geht’s zur Download-Seite.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "prerequisites.html#python",
    "href": "prerequisites.html#python",
    "title": "Voraussetzungen",
    "section": "Python",
    "text": "Python\nEine Programmiersprache, die für die Experimente verwendet wird. Ihr könnt Python von der offiziellen Website herunterladen: Python Download.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "prerequisites.html#software-von-tinkerforge",
    "href": "prerequisites.html#software-von-tinkerforge",
    "title": "Voraussetzungen",
    "section": "Software von Tinkerforge",
    "text": "Software von Tinkerforge\n\nTinkerforge-Bibliothek für Python\nEine Sammlung von Funktionen, die die Programmierung der Tinkerforge-Hardware erleichtern. Ihr könnt die Bibliothek mit dem folgenden Befehl installieren: pip install tinkerforge.\n\n\nBrick Daemon\nEin Hintergrundprozess, der die Kommunikation mit der Tinkerforge-Hardware ermöglicht. Ihr könnt den Brick Daemon von der Tinkerforge-Website herunterladen: Brick Daemon Download.\n\n\nBrick Viewer\nEin Tool, das eine grafische Benutzeroberfläche für die Interaktion mit der Tinkerforge-Hardware bietet. Ihr könnt den Brick Viewer von der Tinkerforge-Website herunterladen: Brick Viewer Download.\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "colors.html",
    "href": "colors.html",
    "title": "1  Farben",
    "section": "",
    "text": "Zusammenfassung\nIm ersten Kapitel steigen wir gleich voll ein und schreiben unser erstes Programm. Unser Ziel ist es, eine LED nacheinander in allen Farben des Regenbogens leuchten zu lassen. Um dahin zu kommen, lernen wir in Abschnitt 1.1 zuerst, wie man überhaupt eine LED aus einem Programm heraus steuern kann. In Abschnitt 1.2 werfen wir einen kurzen Blick auf Farben im allgemeinen und wie diese im Computer erzeugt werden. Dabei unterscheiden wir die additive von der subtraktiven Farbmischung. Danach bereiten wir uns in Abschnitt 1.3 auf den Regenbogenfarbverlauf vor, indem wir zuerst eine pulsierende LED programmieren. Wir lernen dann in Abschnitt 1.4, wie man mittels RGB-Farbcode überhaupt einen Regenbogen erzeugen kann und warum das für uns Menschen nützlich ist. Am Ende in Abschnitt 1.5 schreiben wir schließlich das Programm, das die LED in allen Farben des Regenbogens leuchten lässt.\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#zusammenfassung",
    "href": "colors.html#zusammenfassung",
    "title": "1  Farben",
    "section": "",
    "text": "Wir verstehen, wie Farben im Computer funktionieren und beschrieben werden.\nWir entwickeln unser erstes Programm am Beispiel einer LED-Steuerung.\nWir lernen Schleifen als wichtiges Konzept in der Programmierung kennen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#experimentaufbau",
    "href": "colors.html#experimentaufbau",
    "title": "1  Farben",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\nBereit für euer erstes Hardware-Experiment? Perfekt! Ihr braucht dafür eine LED (RGB LED Bricklet 2.0) und einen Mikrocontroller (Master Brick 3.2). Befestigt beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in Abbildung 1.1 gezeigt. Zwei Schrauben pro Gerät reichen völlig. Denkt an die kleinen, weißen Unterlegscheiben aus Kunststoff. Sie schützen eure Platinen vor Druckstellen.\nNeben der Hardware benötigt ihr auch die passende Software. Diese solltet ihr bereits installiert haben. Falls nicht, schaut im Abschnitt zu den Voraussetzungen vorbei. Dort ist alles genau beschrieben. Im Folgenden gehe ich davon aus, dass ihr alles am Laufen habt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Nahaufnahme der LED.\n\n\n\n\n\n\n\n\n\n\n\n(c) Montageplatte mit allen Komponenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Untenansicht.\n\n\n\n\n\n\n\n\n\n\n\n(e) Ansicht der vier Steckplätze.\n\n\n\n\n\n\n\nAbbildung 1.1: Einfaches Setup mit einem Mikrocontroller und einer LED.\n\n\n\n\n\nErste Schritte\nIm ersten Schritt wollen wir die LED und ihre Funktionen testen! Das geht ganz leicht mit dem Brick Viewer. Schließt zuerst den Master Brick über das USB-Kabel an euren Computer an und öffnet den Brick Viewer. Klickt dann auf den Connect-Button.\n\n\n\n\n\n\nAbbildung 1.2: Über den Connect-Button verbindet ihr den Brick Viewer mit dem angeschlossenen Master Brick.\n\n\n\nWenn alles geklappt hat, zeigt euch der Brick Viewer alle angeschlossenen Geräte in Tabs an. Schaut euch Abbildung 1.3 an – so etwa sollte es aussehen.\n\n\n\n\n\n\nAbbildung 1.3: Der Brick Viewer, nachdem ihr mit dem Master Brick verbunden seid.\n\n\n\nWechselt nun zum Tab der RGB LED. Hier könnt ihr auf unterschiedlichen Wegen die Farbe der LED einstellen. Mehr kann eine LED nicht!\nMit den drei Schiebereglern steuert ihr die einzelnen Farbkanäle – Rot, Grün, Blau. Der Wertebereich: 0 bis 255. Warum gerade diese Farben und diese Zahlen? Gute Frage. Die Antwort kommt weiter unten.\n\n\n\n\n\n\nAbbildung 1.4: Die Ansicht für die RGB LED im Brick Viewer, in der ihr alle Funktionen per Klick im Zugriff habt.\n\n\n\nFazit: Der Brick Viewer ist ideal zum Ausprobieren. Aber wenn ihr echte Projekte umsetzen wollt, müsst ihr programmieren lernen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-control-led",
    "href": "colors.html#sec-colors-control-led",
    "title": "1  Farben",
    "section": "1.1 Erstes Programm: LED ansteuern",
    "text": "1.1 Erstes Programm: LED ansteuern\nWie verbinden wir uns über ein Programm mit der LED und setzen ihre Farbe? Die Antwort darauf findet ihr im folgenden kurzen Codebeispiel.\n\n\n\n\nListing 1.1: Der Boilerplate-Code für die Verbindung mit den Geräten am Beispiel der RGB LED.\n\n\n1from tinkerforge.ip_connection import IPConnection\n2from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\n3ipcon = IPConnection()\n4ipcon.connect(\"localhost\", 4223)\n5led = BrickletRGBLEDV2(\"ZEP\", ipcon)\n\n\n\n\n\n1\n\nHier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.\n\n2\n\nHier importieren wir ein weiteres Objekt, das wir zur Darstellung der LED als Python-Objekt benötigen.\n\n3\n\nDie Verbindung erfolgt über eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.\n\n4\n\nMit connect stellen wir eine Verbindung zum angeschlossenen Master Brick her.\n\n5\n\nSchließlich holen wir uns eine virtuelle Instanz des RGB LED Bricklets, indem wir die UID nennen und sagen, welche Verbindung (ipcon) genutzt werden soll.\n\n\n\n\n\n1.1.1 Programme\nZunächst klären wir den Begriff Programm. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausführt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm später dafür zuständig, mit der LED zu interagieren und sie in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns ermöglichen, dem Computer präzise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut für Einsteiger eignet und gleichzeitig mächtig genug ist, um komplexe Aufgaben zu lösen.\nWenn wir ein Programm ausführen, arbeitet der Computer die Anweisungen Schritt für Schritt von oben nach unten ab. Die Nummerierung der Zeilen verdeutlicht das sehr schön. Der Computer beginnt bei Zeile 1 und arbeitet die Befehle Zeile für Zeile bis nach unten ab.\nEs gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir später kennen.\n\n\n1.1.2 Boilerplate Code\nDer Codeausschnitt in Listing 1.1 wird uns im Verlauf dieses Buches immer wieder begegnen. Wir benötigen ihn, um uns am Anfang des Programms mit den Geräten zu verbinden, die wir für unsere Anwendung benötigen. In der Informatik nennen wir solchen Code, den wir häufig in der gleichen Form benötigen und fast eins zu eins kopieren können, auch Boilerplate-Code. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.\n\n\n1.1.3 Bibliotheken\nBeginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr ähnliche Befehle, die mit dem Schlüsselwort from beginnen. Nach dem Schlüsselwort from folgt der Name einer Bibliothek, aus der wir ein für unser Programm benötigtes Objekt importieren. Die Kombination der Schlüsselwörter from ... import lässt sich also wörtlich übersetzen: “Aus der Bibliothek X importiere das Objekt Y”.\nEine Bibliothek in einer Programmiersprache ist die Bündelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek könnt ihr euch vorstellen wie einen Werkzeugkasten: Sie enthält fertige Werkzeuge (Funktionen und Klassen), damit ihr nicht alles von Grund auf selbst programmieren müsst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Geräten loslegen können. Für jedes Gerät gibt es in der Tinkerforge-Bibliothek eine eigene Klasse, über die wir auf die Funktionen jedes Geräts zugreifen können.\n\n\n1.1.4 Klassen und Objekte\nMit from ... import importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit importieren ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge später wirklich nutzen, steht auf einem anderen Blatt.\nIn dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ankündigen. Die erste Klasse heißt IPConnection und die zweite BrickletRGBLEDV2. Der Begriff Klasse ist hier analog zum Begriff Kategorie zu verstehen. Wir können zu einer Klasse gehörige Objekte erzeugen, und alle Objekte derselben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.\nStellt euch vor, ihr habt eine Klasse namens Auto. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa fahren(), bremsen() oder tanken(). Diese Dinge sollen für jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Wir können also sagen: “Mein Auto ist ein Objekt der Klasse Auto.” Jedes Auto hat neben den Funktionen die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte für diese Eigenschaften haben.\nGenauso verhält es sich mit den Klassen, die Tinkerforge für uns bereitgestellt hat. Die Klasse IPConnection beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen können, und die Klasse BrickletRGBLEDV2 beschreibt, wie wir mit der LED interagieren können. Wenn wir ein Objekt dieser Klasse erstellen, können wir alle Funktionen nutzen, die in der Klasse definiert sind. Eine LED muss nicht fahren oder bremsen wie ein Auto. Dafür hat sie andere Funktionen, wie etwa set_rgb_value(), die uns erlaubt, die Farbe der LED zu ändern. Eine Eigenschaft jeder LED ist ihre UID, die eindeutig ist und uns hilft, sie im System zu identifizieren.\n\n\n1.1.5 Schlüsselwörter\nSoeben haben wir mit from und import unsere ersten beiden Schlüsselwörter in Python kennengelernt! Aber was bedeutet das genau? Ein Schlüsselwort, das wir im Englischen auch keyword oder reserved keyword nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch häufig Namen vergeben müssen, etwa für Variablen oder Funktionen. Diese Namen dürfen nicht wie ein Schlüsselwort lauten, ansonsten funktioniert unser Programm nicht wie gewünscht. Welche Schlüsselwörter es in Python gibt, könnt ihr hier nachschauen.\nIm Codeausschnitt oben laden wir zuerst das Objekt für die Verbindung zum angeschlossenen Mikrocontroller, die über eine IP-Verbindung hergestellt wird. Was das genau ist? Später mehr dazu. Zusätzlich zur IPConnection laden wir anschließend noch die benötigten Klassen für die Geräte, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur die LED, in späteren Experimenten werden es auch mal mehrere Geräte sein.\n\n\n1.1.6 Objekte erzeugen\nIn Listing 1.1 in Zeile 4 erzeugen wir ein Objekt der Klasse IPConnection. Die fertige Instanz – so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde – speichern wir auf einer Variable mit dem Namen ipcon. Diesen Namen haben wir uns selbst ausgedacht, damit wir später darauf zugreifen können. Wir hätten auch einen anderen Namen wählen können. Eine Variable ist also ein Platzhalter für einen Wert, den wir später im Programm verwenden wollen. In diesem Fall ist ipcon der Platzhalter für die Verbindung zu unserem Mikrocontroller. Was eine Variable technisch ist, lernen wir später noch genauer kennen.\n\n\n1.1.7 Methoden\nÜber das Objekt ipcon können wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode connect(). Eine Methode ist eine Funktion, die zu einem Objekt gehört – wie etwa fahren() oder bremsen() in unserem Auto-Beispiel.\nWir können Methoden aufrufen, um eine bestimmte Aktion auszuführen. In diesem case stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, über den die Verbindung hergestellt werden soll. In unserem Fall ist das “localhost”, was für die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standardmäßig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt . nach dem Objekt, gefolgt vom Namen der Methode und den Klammern (), in denen wir eventuell benötigte Parameter angeben.\nEine Methode ist letztlich eine Funktion, die zu einem Objekt gehört. Zu einem späteren Zeitpunkt schreiben wir unsere eigenen Funktionen und lernen dann noch viel mehr darüber.\n\n\n1.1.8 Ein Objekt für die LED\nIn Zeile 6 erzeugen wir schließlich ein Objekt der Klasse BrickletRGBLEDV2. Dieses Objekt repräsentiert unsere LED und ermöglicht es uns, mit ihr zu interagieren. Wir nennen das Objekt led, was kurz und klar ist. Auch hier haben wir uns den Namen selbst ausgedacht, um später darauf zugreifen zu können. Auch wenn wir grundsätzlich Variablennamen frei wählen können, sollten sie immer so gewählt werden, dass sie den Inhalt der Variable beschreiben. Das macht es später einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten müssen. Dazu gehören etwa, dass Variablennamen nicht mit einer Zahl beginnen dürfen und keine Leerzeichen enthalten dürfen. Eine ausführliche Liste der Regeln findet ihr hier.\n\n\n1.1.9 Zusammenfassung unseres ersten Programms\nDamit haben wir unser erstes Programm von oben nach unten erläutert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:\n\n\n\n\n\n\n\nProgramme\nAbfolge von Anweisungen, die nacheinander ausgeführt werden.\n\n\nBoilerplate Code\nStandard-Code, den man immer wieder braucht.\n\n\nImportieren von Bibliotheken\nSammlung von fertigen Code-Elementen.\n\n\nSchlüsselwörter\nReservierte Begriffe der Programmiersprache.\n\n\nKlassen und Objekte\nKategorien und deren konkrete Instanzen.\n\n\nMethoden und Funktionen\nFunktionen, die zu einem Objekt gehören.\n\n\nVariablen\nPlatzhalter für Werte.\n\n\n\n\n\n1.1.10 Und jetzt?\nWir haben nun eine digitale Repräsentation unserer LED in Python. Wir können die LED jetzt zum Leuchten bringen, indem wir eine Methode der Klasse BrickletRGBLEDV2, die set_rgb_value() heißt, verwenden. Diese Methode erwartet drei Parameter: Rot, Grün und Blau. Mit diesen Parametern können wir die Farbe der LED einstellen.\n\n1led.set_rgb_value(0, 255, 0)\n\n\n1\n\nSetzt die LED auf grün. R = 0, G = 255, B = 0. Logisch, oder?\n\n\n\n\nMoment mal … Wo steht hier eigentlich grün? Steht da gar nicht. Stattdessen drei Zahlen. Willkommen bei der RGB-Farbkodierung. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Grün, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Weiß. Nur Grün auf 255? Na klar: grün.\nAber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie übersetzen wir die Welt in etwas, das ein Computer versteht?\nWarum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit drei Zahlen? Warum überhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?\nVorher müssen wir aber kurz zurück in die Schule.\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-light-and-colors",
    "href": "colors.html#sec-colors-light-and-colors",
    "title": "1  Farben",
    "section": "1.2 Licht und Farben",
    "text": "1.2 Licht und Farben\n\n1.2.1 Blick auf die Physik\nPhysik ist vielleicht schon eine Weile her. Erinnern wir uns dennoch kurz, was Licht ist und wie Farben damit zusammenhängen. Licht ist elektromagnetische Strahlung. Das bedeutet, es handelt sich um gekoppelte Schwingungen elektrischer und magnetischer Felder, die sich mit Lichtgeschwindigkeit ausbreiten. Vereinfacht können wir uns Licht als Wellen vorstellen, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenlängen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen über Infrarotstrahlung bis hin zu Röntgenstrahlen und Gammastrahlen reicht.\nBei Wellen unterscheiden wir zwischen der Frequenz (wie oft die Welle pro Sekunde schwingt) und der Wellenlänge (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenlänge sind umgekehrt proportional: Je höher die Frequenz, desto kürzer die Wellenlänge und umgekehrt.\nFrequenzen messen wir in Hertz (Hz), wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenlängen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) für violettes Licht und etwa 700 nm für rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abstände zwischen den Wellenlängen des sichtbaren Lichts sind also extrem klein.\nWas bedeutet das nun für eine LED? Eine LED (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchfließt. Die Farbe des Lichts hängt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenlängen, was zu verschiedenen Farben führt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenlänge von etwa 620–750 nm, während eine grüne LED Licht mit einer Wellenlänge von etwa 495–570 nm emittiert.\n\n\n\n\n\n\nAbbildung 1.5: Das elektromagnetische Spektrum, von dem das sichtbare Licht ein kleiner Teil ist. (Quelle: Wikipedia)\n\n\n\nDie RGB LED besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer grünen und einer blauen. Jede dieser LEDs kann unabhängig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Stromstärke bedeutet mehr Intensität der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Grün und Blau in unterschiedlichen Intensitäten können wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensität leuchten lassen, erhalten wir Weiß. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LEDs sind dann alle aus.\nJetzt wissen wir, warum die Methode set_rgb_value() drei Parameter erwartet: Rot, Grün und Blau. Diese Parameter sind die Intensitäten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 können wir jede Farbe im sichtbaren Spektrum erzeugen.\nEin Farbwert im Computer besteht also aus drei Zahlen besteht, die jeweils zwischen 0 und 255 liegen. Das gilt für unsere LED, aber auch für Pixel in TVs, Smartphones, digitalen Fotos oder Monitoren. Wie kommt es aber zu der merkwürdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grundsätzlich Werte speichert und wie dieser Speicher organisiert ist. Genaueres erfahren wir schon in Kapitel 2.\nKlingt alles theoretisch sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus und mischen zwei Farben mit voller Intensität!\n\nled.set_rgb_value(255, 255, 0)\n\nWas macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!\n\n\n1.2.2 Additive Farbmischung\nIhr solltet alle eure LEDs in Gelb aufleuchten sehen. In der additiven Farbmischung mischen wir Rot und Grün und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Grün, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensität leuchten lassen, erhalten wir eine neue Farbe, die stets heller ist als die Ursprungsfarben. Wir fügen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensität mischen, erhalten wir schließlich Weiß.\n\nled.set_rgb_value(255, 255, 255)\n\nAm anderen Ende des Spektrums erzeugen drei Nullen die Farbe Schwarz:\n\nled.set_rgb_value(0, 0, 0)\n\n\n\n1.2.3 Subtraktive Farbmischung\nIhr könnt euch merken, dass wir im Kontext von Computern oft von additiver Farbmischung sprechen, weil Bildschirme Licht erzeugen. Durch das Mischen der drei Farbkanäle entstehen neue Farben gemäß der additiven Farbmischung, also stets heller als ihre Grundfarben. Daneben gibt es aber noch die subtraktive Farbmischung. Sie funktioniert anders, nämlich genau umgekehrt. Statt beim Mischen Licht hinzuzufügen, nehmen wir Licht weg.\nErinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbkasten die Mischung aus Rot und Grün ergeben? Sicher nicht Gelb – eher Braun. Eine dunklere Farbe. Das liegt daran, dass wir es hier nicht mit additiver, sondern mit subtraktiver Farbmischung zu tun haben. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht absorbieren und reflektieren. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtspektrums werden nicht mehr reflektiert, sondern absorbiert und sind damit nicht mehr sichtbar. Das Ergebnis einer Mischung zweier Farben ergibt in der subtraktiven Farbmischung also stets eine dunklere Farbe – genau umgekehrt zur additiven Farbmischung.\nWas passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, nämlich Wärme. Deshalb wird eine schwarze Oberfläche auch besonders heiß, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspektrum und wandelt es in Wärme um. Dagegen wirken weiße Oberflächen fast wie Klimaanlagen. Es ist kein Zufall, dass wir in sonnigen Erdteilen viele weiße Fassaden sehen.\nWenn wir alle Farben mischen, ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zurück. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen kombinieren, um neue Farben zu erhalten.\n\n\n\n\n\n\n\n\n\n\n\n(a) Additive Farbmischung\n\n\n\n\n\n\n\n\n\n\n\n(b) Subtraktive Farbmischung\n\n\n\n\n\n\n\nAbbildung 1.6: Additive und subtraktive Farbmischung.\n\n\n\nIn Abbildung 1.6 sehen wir die beiden Farbmischungsarten im Vergleich. In Abbildung 1.6 (b) sehen wir die drei Grundfarben, die wir bei der subtraktiven Variante benötigen, um daraus alle weiteren Farben zu erhalten. Das sind Cyan, Magenta und Gelb. Im Englischen ist die Abkürzung CMY, wo das “Y” für Yellow steht. In der additiven Farbmischung sind es, wie oben schon gesehen, Rot, Grün und Blau. Wenn ihr Abbildung 1.6 (a) betrachtet, dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der additiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?\nIn der additiven Farbmischung entsteht Gelb durch das Mischen von Rot und Grün, wobei Blau fehlt. Im Umkehrschluss bedeutet das: Gelbes Licht enthält keine blaue Komponente, es reflektiert also kein Blau. In der subtraktiven Farbmischung (wie beim Farbkasten) wird Gelb erzeugt, indem Blau aus weißem Licht herausgefiltert wird – Gelb reflektiert also kein Blau, sondern absorbiert es. Gelb kann also auch als Blaufilter gesehen werden. Das erklärt, warum ein gelber Gegenstand unter blauem Licht dunkel erscheint: Er kann das blaue Licht nicht reflektieren.\nJetzt können wir auch erklären, warum Farbdrucker vier unterschiedliche Kartuschen benötigen (Abbildung 1.7). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb können wir jede beliebige Farbe mischen. Zusätzlich haben Drucker eine Kartusche für Schwarz, um erstens ein sattes Schwarz drucken zu können und zweitens die Farbkartuschen zu schonen. Denn schließlich müssen alle drei Farben gemischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen Schwarz enthalten (oder sogar ausschließlich), ist eine schwarze Kartusche einfach effizienter. Die Farbe Schwarz wird bei Druckerkartuschen als Key bezeichnet und mit “K” abgekürzt. Wir sprechen daher auch von CMYK.\n\n\n\n\n\n\nAbbildung 1.7: Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.\n\n\n\nFarben spielen eine so wichtige Rolle bei der Arbeit mit Computern. Deshalb lohnt es sich, ein wenig über die Hintergründe von Farben und deren Mischung zu verstehen. Wir werden später noch lernen, wie Bildschirme Farben darstellen. Spätestens dann wird uns das Thema der Farbmischung wieder begegnen.\nAb jetzt wollen wir weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, praxisnah verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED über die Methode set_rgb_value() verändern können, wenn wir wissen, welcher RGB-Code unsere gewünschte Farbe repräsentiert. Da wir jetzt mehr über die Farbmischung wissen, können wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:\n\nled.set_rgb_value(255, 0, 255)\n\nGemäß der Theorie der additiven Farbmischung (Abbildung 1.6 (a)) müssten Rot und Blau Magenta ergeben. Probiert es aus!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-pulsating-led",
    "href": "colors.html#sec-colors-pulsating-led",
    "title": "1  Farben",
    "section": "1.3 Pulsierende LED",
    "text": "1.3 Pulsierende LED\nDas deklarierte Ziel unseres ersten Experiments ist es, einen Regenbogenfarbverlauf zu erzeugen. Dazu müssen wir die Farbe der LED kontinuierlich ändern, sodass sie von Rot über Gelb, Grün, Cyan, Blau und Violett wieder zurück zu Rot wechselt.\nLasst uns aber möglichst einfach anfangen und uns dem Regenbogen schrittweise annähern. Zunächst wäre es schön, wenn wir die LED einfach Rot pulsieren lassen könnten. Dazu müssen wir nämlich nur den Rot-Kanal und nicht alle drei Kanäle der LED ansteuern. Gleichzeitig lernen wir schon hier ein Problem kennen, das uns in der Programmierung häufig begegnet und für das es eine elegante Lösung gibt.\n\n1.3.1 Abzählbare Wiederholungen\nWas bedeutet es, die LED pulsieren zu lassen? Und was müssen wir dafür tun? Pulsieren bedeutet, dass die LED über einen kurzen Zeitraum immer heller wird, kurz in der vollen Helligkeit verweilt und dann sofort wieder kontinuierlich dunkler wird. Sobald sie schwarz ist, fängt der Zyklus von vorne an.\nDen Ausdruck immer heller werden können wir bezogen auf die LED so übersetzen, dass wir den Anteil des Rot-Kanals schrittweise erhöhen. Wenn die LED zu Beginn aus ist, also alle Kanäle auf 0 stehen, können wir den Rot-Kanal von 0 auf 255 erhöhen und so die LED immer heller in Rot aufleuchten lassen.\nWir beginnen also mit einer schwarzen LED:\n\nled.set_rgb_value(0, 0, 0)\n\nAnschließend setzen wir den Wert für Rot auf 1:\n\nled.set_rgb_value(1, 0, 0)\n\nUnd erhöhen ihn schrittweise:\n\nled.set_rgb_value(2, 0, 0)\nled.set_rgb_value(3, 0, 0)\nled.set_rgb_value(4, 0, 0)\n# ...\n\nWenn wir nach diesem Muster fortfahren, hätten wir bis zum vollen Rot 255 Zeilen Code geschrieben, eine Zeile für jeden Erhöhungsschritt. Und anschließend das Gleiche nochmal rückwärts, damit wir wieder zu Schwarz kommen. Mit 510 Zeilen Code hätten wir dann einen Pulsierungszyklus durchlaufen. Wollen wir die LED öfter pulsieren lassen, vervielfacht sich unser Code entsprechend. Das kann nicht die Lösung für ein so einfaches Problem sein.\nUnd tatsächlich gibt es in der Programmierung eine bessere Möglichkeit, um sich wiederholende Abläufe abzubilden: die Schleife. In einem Fall, bei dem wir genau wissen, wie oft wir etwas wiederholen wollen, bietet sich eine Zählerschleife an:\n\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n\nVoilà! Unsere 510 Zeilen Code können wir mit einer Schleife auf zwei Zeilen reduzieren! Dazu müssen wir im Kopf der Schleife (for ... in ...) festlegen, wie oft der eingerückte Codeblock nach dem Doppelpunkt ausgeführt werden soll. In Python funktioniert das über die Angabe einer Folge, für die jedes Element einmal durchlaufen wird. Das aktuelle Element ist in der Schleife als r verfügbar. Und r nimmt nacheinander jeden Wert der Folge an, die nach dem Schlüsselwort in folgt. Diese Folge erzeugt hier die Funktion range(256), die – wie der Name preisgibt – eine Zahlenfolge von 0 bis zum angegebenen Wert minus eins erzeugt. In unserem Fall also von 0 bis 255.\nUm das besser nachvollziehen zu können, geben wir den Wert für r einfach mal aus:\n\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n1    print(r)\n\n\n1\n\nMit print() geben wir einen Wert auf der Konsole aus.\n\n\n\n\nJetzt wird es deutlich: Mit jedem Durchlauf der Schleife wird ein neuer Wert für r gesetzt und ausgegeben. Und zwar jeweils um eins erhöht. Die Funktion range(256) erzeugt genau gesagt eine sortierte Reihe mit den Zahlen von 0 bis 255. Das sieht in Python dann so aus:\n\nlist_of_numbers = range(256)\n1print(list(list_of_numbers))\n\n\n1\n\nMit der list()-Funktion wandeln wir die von range() erzeugte Folge in eine Liste um, die wir dann ausgeben können.\n\n\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]\n\n\nRückwärts erreichen wir das gleiche Ergebnis mit einer weiteren Schleife, deren Folge wir umkehren, sodass sie von 255 bis 0 geht:\n\nfor r in range(255, -1, -1):\n    led.set_rgb_value(r, 0, 0)\n\nWarum hat range() auf einmal drei Argumente? Ganz einfach: Standardmäßig erstellt die Funktion eine Folge von 0 bis zur angegebenen Zahl minus eins. Wir können die Folge aber beeinflussen, indem wir einen Startwert und einen Schrittwert angeben. In unserem Fall oben beginnen wir bei 255 (erster Parameter) und gehen bis -1 (zweiter Parameter), wobei wir in jedem Schritt um -1 verringern (dritter Parameter). Warum zählen wir bis -1, wo wir doch eigentlich die 0 als kleinste Zahl benötigen? Das liegt daran, dass die Folge von range() immer bis zum zweiten Parameter minus eins geht. Wenn wir also 0 als kleinste Zahl benötigen, müssen wir bis -1 zählen.\nFassen wir unsere Erkenntnis zusammen und lassen die LED pulsieren:\n\nimport time\n\n# Increase red step by step\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n    time.sleep(0.001)\n\n# Stay at full brightness for a bit\ntime.sleep(0.25)\n\n# Decrease red step by step\nfor r in range(255, -1, -1):\n    led.set_rgb_value(r, 0, 0)\n    time.sleep(0.001)\n\nSoweit bekannt? Fast – eine kleine Neuerung habe ich gerade eingebaut, nämlich die Funktion time.sleep(). Diese Funktion pausiert das Programm für die angegebene Zeit in Sekunden. In unserem Fall pausieren wir für 0,001 Sekunden, also 1 Millisekunde. Dadurch wird die LED langsamer heller und dunkler, was den Puls-Effekt verstärkt. Ohne diese Pause würde die LED so schnell aufleuchten, dass es für das menschliche Auge nicht mehr wahrnehmbar wäre. Tatsächlich würden wir auch die Hardware überfordern, weil die LED gar nicht so schnell die Farbe wechseln kann. Das Programm würde abstürzen.\nAm Höhepunkt warten wir erneut – dieses Mal eine Viertelsekunde –, bevor wir die LED langsam ausgehen lassen und den Rotanteil schrittweise wieder auf Null setzen. Dann endet unser Programm, leider viel zu früh. Die LED soll doch eigentlich weiter pulsieren, bis … ja, bis wann überhaupt?\n\n\n1.3.2 Bedingte Wiederholungen\nBeim Lösen von Problemen stoßen wir häufig auf Situationen, in denen wir bestimmte Schritte wiederholt ausführen möchten, aber nur unter bestimmten Bedingungen. Hier kommen bedingte Wiederholungen ins Spiel, die es uns ermöglichen, Schleifen zu erstellen, die nur dann fortgesetzt werden, wenn eine bestimmte Bedingung noch erfüllt ist.\nDas können wir auf unsere pulsierende LED anwenden. Sie soll ihren Pulsierzyklus Dunkel–Hell–Dunkel wiederholen, solange der Benutzer nicht unterbricht. Das ist zumindest ein pragmatisches Abbruchkriterium für unseren Fall. Wir definieren also hier keine feste Anzahl Wiederholungen wie bei der for ... in-Schleife, sondern wir wollen festlegen, unter welcher Bedingung die Schleife fortgesetzt wird. Wir könnten also sagen: solange die Bedingung X erfüllt ist, wiederhole die aufgeführten Schritte. Und weil Programmiersprachen für Menschen gemacht sind, klingt es im echten Programm auch so ähnlich:\n\nwhile 1==1:\n    print(\"This condition is always true\")\n    time.sleep(1)\n\nDas Schlüsselwort while führt eine bedingte Schleife ein, gefolgt von der Bedingung, die die Schleife steuert. Die Bedingung wird vor jedem neuen Schleifendurchlauf geprüft (auch vor dem ersten) und sollte sie falsch (false) sein, wird die Schleife beendet.\nWann wird die Schleife oben also beendet? Richtig – niemals. Die Bedingung 1==1 ist immer wahr, die Schleife läuft somit endlos. Wir sprechen auch von einer Endlosschleife, die wir in der Programmierung unbedingt vermeiden wollen, es sei denn, sie ist explizit gewollt und nicht versehentlich entstanden. Das kurze Programm oben schreibt also in Abständen von einer Sekunde den Text “This condition is always true” auf die Konsole.\nEine Bedingung ist in Python und anderen Programmiersprachen ein wichtiges Konzept, das es uns ermöglicht, Entscheidungen zu treffen und den Programmfluss zu steuern. In unserem Fall könnte die Bedingung lauten: solange der Benutzer nicht stoppt, wiederhole den Pulsierzyklus. Eine Bedingung hat die Eigenschaft, dass sie jederzeit ausgewertet werden kann und entweder den Wert wahr (true) oder falsch (false) annimmt. Wie aber drücken wir das in Python aus?\n\nwhile True:\n    print(\"I will loop forever\")\n    time.sleep(1)\n\nDie einfachste Möglichkeit ist es, das Ergebnis der Evaluation direkt hinzuschreiben. Die obige Schleife prüft in jedem Durchgang, ob der Wert True wahr ist - was er natürlich ist. Das ist also so ähnlich wie bei der Schleife weiter oben, die die Bedingung 1==1 geprüft hat. Die ist ebenfalls immer True oder wahr.\nWir lernen im Laufe des Buches noch viele echte Bedingungen kennen, deren Ergebnis nicht von Vornherein bekannt ist. Für unsere pulsierende LED reicht es aber aus, wenn wir eine gewollte Endlosschleife verwenden. Denn auch eine Endlosschleife können wir jederzeit verlassen, indem wir das Programm mit der Tastenkombination Strg+C abbrechen.\nWenn wir jetzt unseren Pulsierzyklus von oben in die neue bedingte while-Schleife einfügen, sind wir schon am Ziel. Der Pulsierzyklus wird wiederholt, solange das Programm nicht abgebrochen wird:\n\nwhile True:\n\n    # Increase red step by step\n    for r in range(256):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, -1, -1):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)\n\nDer Vollständigkeit halber das Ganze inklusive des Boilerplate-Codes für die Verbindung zu den Tinkerforge-Geräten:\n\n\n\n\nListing 1.2: Das fertige Programm, das die LED rot pulsieren lässt.\n\n\nimport time\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn LED off initially\nled.set_rgb_value(0, 0, 0)\n\nwhile True:\n\n    # Increase red step by step\n    for r in range(256):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, -1, -1):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-hue-circle",
    "href": "colors.html#sec-colors-hue-circle",
    "title": "1  Farben",
    "section": "1.4 Farbkreise",
    "text": "1.4 Farbkreise\nDas RGB-Farbschema ist für Computer optimal, weil sich damit mit nur drei Zahlen jede beliebige Farbe kodieren lässt. Zahlen sind schließlich die Sprache, mit der Computer am besten umgehen können. Für uns Menschen ist dieses Schema jedoch weniger intuitiv. Oder könntet ihr auf Anhieb sagen, welche Farbe hinter der Kombination (67, 201, 182) steckt?\nUm Farben für uns leichter wählbar zu machen, wurde der sogenannte Hue-Farbkreis entwickelt. Er ordnet die Farben auf einer Skala von 0 bis 360 Grad an – ähnlich wie die Winkel auf einem Kreis. Neben dem Farbton (Hue) lassen sich zusätzlich die Sättigung und die Helligkeit einstellen: Der Farbton bestimmt die eigentliche Farbe, die Sättigung, wie kräftig oder blass sie wirkt, und die Helligkeit, wie hell oder dunkel sie erscheint.\n\n\n\n\n\n\nAbbildung 1.8: Die Farbauswahl in Google Slides funktioniert über den Hue-Farbkreis.\n\n\n\nIn Abbildung 1.8 seht ihr, wie die Farbauswahl in Google Slides funktioniert. Mit dem Slider in der Mitte bestimmt ihr den Farbton. Habt ihr einen passenden Ton gefunden, könnt ihr im Rechteck darüber durch Verschieben des kleinen Kreises die Sättigung und Helligkeit anpassen.\nBeobachtet ihr dabei die RGB-Werte, erkennt ihr die Systematik der Farbton-Skala: Ausgehend von reinem Rot wird Schritt für Schritt Grün hinzugefügt – so entstehen Orange und Gelb. Danach nimmt der Rotanteil ab, während Blau hinzukommt. Über Cyan gelangen wir zu reinem Blau. Schließlich wird wieder Rot beigemischt, wodurch Violett bis Pink entstehen. Auf diese Weise bildet der Kreis den gesamten Regenbogen ab.\nDa die Skala am Ende wieder bei Rot ankommt, lässt sich der Farbverlauf nahtlos wiederholen – ohne harte Übergänge. Genau deshalb wird der Hue-Verlauf meist als Kreis dargestellt.\n\n\n\n\n\n\nAbbildung 1.9: Der Hue-Farbkreis mit HSV-Werten.\n\n\n\nAbbildung 1.9 zeigt den Hue-Farbkreis im HSV-Modell. HSV steht für Hue, Saturation, Value (Farbton, Sättigung, Helligkeit). Der Wert Value gibt die Helligkeit auf einer Skala von 0 bis 100 % an. Im Bild ist die Helligkeit konstant bei 100 %, während die Sättigung von innen nach außen zunimmt. In der Mitte sehen wir deshalb Weiß, während am äußeren Rand die Farben ihre volle Intensität haben.\nWenn wir ein Programm schreiben, das die gesamte Hue-Farbskala durchläuft und die LED jeweils in der passenden Farbe aufleuchten lässt, erhalten wir unser Regenbogenprogramm. Da die LED RGB-Werte benötigt, müssen wir den Verlauf des Hue-Farbkreises in RGB umsetzen. Ein Blick auf die Animation in Abbildung 1.8 hilft: Der Farbverlauf lässt sich in sechs Phasen unterteilen, wie Abbildung 1.10 zeigt:\n\nRot = 255, Blau = 0, Grün steigt linear\nRot sinkt linear, Grün = 255, Blau = 0\nRot = 0, Grün = 255, Blau steigt linear\nRot = 0, Grün sinkt linear, Blau = 255\nRot steigt linear, Grün = 0, Blau = 255\nRot = 255, Grün = 0, Blau sinkt linear\n\nDann beginnt der Zyklus von vorn.\n\n\n\n\n\n\nAbbildung 1.10: Der Hue-Farbverlauf mit den Veränderungen der RGB-Werte (Quelle: Ronja’s Tutorials).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-rainbow-led",
    "href": "colors.html#sec-colors-rainbow-led",
    "title": "1  Farben",
    "section": "1.5 Regenbogen-LED",
    "text": "1.5 Regenbogen-LED\nMit dem Wissen können wir uns an das erklärte Ziel unseres Experiments machen: die LED nacheinander in allen Farben des Regenbogens aufleuchten zu lassen. Beginnen wir mit der ersten Phase und schreiben dafür ein Python-Programm:\n\nfor green in range(256):\n    led.set_rgb_value(255, green, 0)\n    time.sleep(0.01)\n\nWeil wir genau wissen, wie oft wir die Schleife durchlaufen wollen, verwenden wir eine for-Schleife. Innerhalb der Schleife erhöhen wir die Variable green jeweils um 1, was effektiv den Grünanteil unseres RGB-Wertes erhöht. Mit jedem Durchlauf fügen wir somit mehr Grün hinzu, während Rot und Blau konstant bleiben. Phase 1 ist damit abgeschlossen – machen wir weiter mit Phase 2:\n\nfor red in range(255, -1, -1):\n    led.set_rgb_value(red, 255, 0)\n    time.sleep(0.01)\n\nWie wir mit einer for-Schleife rückwärts zählen, haben wir schon weiter oben kennengelernt. In Phase 2 verringern wir schrittweise den Rotanteil, während die anderen beiden Farben konstant bleiben. Damit kommen wir zu Phase 3:\n\nfor blue in range(256):\n    led.set_rgb_value(0, 255, blue)\n    time.sleep(0.01)\n\nIch glaube, ihr habt das Prinzip verstanden. Indem wir die sechs Phasen jeweils in einer eigenen Schleife abarbeiten, erhalten wir das vollständige Regenbogenprogramm:\n\n# phase 1\nfor green in range(256):\n    led.set_rgb_value(255, green, 0)\n    time.sleep(0.01)\n\n# phase 2\nfor red in range(255, -1, -1):\n    led.set_rgb_value(red, 255, 0)\n    time.sleep(0.01)\n\n# phase 3\nfor blue in range(256):\n    led.set_rgb_value(0, 255, blue)\n    time.sleep(0.01)\n\n# phase 4\nfor green in range(255, -1, -1):\n    led.set_rgb_value(0, green, 255)\n    time.sleep(0.01)\n\n# phase 5\nfor red in range(256):\n    led.set_rgb_value(red, 0, 255)\n    time.sleep(0.01)\n\n# phase 6\nfor blue in range(255, -1, -1):\n    led.set_rgb_value(255, 0, blue)\n    time.sleep(0.01)\n\nWie schön 🌈 Eine Sache fehlt aber noch.\n\n1.5.1 Runde für Runde\nDer Regenbogen soll am Ende wieder von vorne beginnen. Wie schon beim Pulsieren der Farben können wir auch hier eine while-Schleife verwenden und die Phasen kontinuierlich abspielen – solange, bis der Benutzer die Escape-Taste drückt:\n\nwhile True:\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(0.01)\n\n    # phase 2\n    for red in range(255, -1, -1):\n        led.set_rgb_value(red, 255, 0)\n        time.sleep(0.01)\n\n    # phase 3\n    for blue in range(256):\n        led.set_rgb_value(0, 255, blue)\n        time.sleep(0.01)\n\n    # phase 4\n    for green in range(255, -1, -1):\n        led.set_rgb_value(0, green, 255)\n        time.sleep(0.01)\n\n    # phase 5\n    for red in range(256):\n        led.set_rgb_value(red, 0, 255)\n        time.sleep(0.01)\n\n    # phase 6\n    for blue in range(255, -1, -1):\n        led.set_rgb_value(255, 0, blue)\n        time.sleep(0.01)\n\nWir haben es fast geschafft! Eine Kleinigkeit wollen wir an unserem Programm noch verbessern.\n\n\n1.5.2 Geschwindigkeit steuern\nVielleicht habt ihr gemerkt, dass die Geschwindigkeit, mit der unsere LED den gesamten Regenbogen einmal durchläuft, nicht sehr hoch ist. Ich würde das gerne beschleunigen. Die Zeit steuern wir über die time.sleep()-Funktion, sodass wir einfach den Wert in jedem Funktionsaufruf verringern könnten. Das wäre aber nicht sehr effizient, weil wir ihn an sechs Stellen anpassen müssen. Wenn wir danach merken, dass es zu schnell ist, müssten wir den Wert erneut überall editieren. Das geht einfacher!\nDer Trick liegt darin, den Wert für die Wartedauer als Variable zu definieren und nur an einer Stelle zu ändern.\n\npause_duration = 0.01\nwhile not keyboard.is_pressed('esc'):\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # etc.\n\nSchon besser! Wir gehen aber noch einen Schritt weiter. Statt dieses kleinteiligen Werts für eine Pause zwischen zwei kleinen Farbveränderungen möchte ich die Gesamtdauer für den Durchlauf eines Regenbogens angeben. Der Wert pause_duration soll dann auf dieser Basis errechnet werden. Dazu müssen wir nur die Anzahl der Pausen insgesamt kennen; in jeder der sechs Phasen sind es 256. Macht also:\n\\[\n6 \\times 256 = 1536\n\\]\nIm Programm setzen wir die Pausendauer also auf die Gesamtdauer in Sekunden geteilt durch 1536:\n\nrainbow_duration = 5\npause_duration = rainbow_duration / 1536\n\nwhile not keyboard.is_pressed('esc'):\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # etc.\n\nUnd schon können wir unseren Regenbogen beliebig zeitlich steuern. Damit sind wir am Ende des Kapitels angekommen. Wir schließen es mit dem vollständigen Code für unseren Regenbogenverlauf in Listing 1.3 ab. Vergesst nicht, den Wert für die UID eurer LED anzupassen, damit es auch bei euch funktioniert:\n\n\n\n\nListing 1.3: Das fertige Regenbogenprogramm.\n\n\nimport time\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn LED off initially\nled.set_rgb_value(0, 0, 0)\n\nrainbow_duration = 5\npause_duration = rainbow_duration / 1536\n\nwhile True:\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # phase 2\n    for red in range(255, -1, -1):\n        led.set_rgb_value(red, 255, 0)\n        time.sleep(pause_duration)\n\n    # phase 3\n    for blue in range(256):\n        led.set_rgb_value(0, 255, blue)\n        time.sleep(pause_duration)\n\n    # phase 4\n    for green in range(255, -1, -1):\n        led.set_rgb_value(0, green, 255)\n        time.sleep(pause_duration)\n\n    # phase 5\n    for red in range(256):\n        led.set_rgb_value(red, 0, 255)\n        time.sleep(pause_duration)\n\n    # phase 6\n    for blue in range(255, -1, -1):\n        led.set_rgb_value(255, 0, blue)\n        time.sleep(pause_duration)\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.\n\n\nSeid ihr bereit für das nächste Experiment?\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "numbers.html",
    "href": "numbers.html",
    "title": "2  Zahlen",
    "section": "",
    "text": "Zusammenfassung\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#zusammenfassung",
    "href": "numbers.html#zusammenfassung",
    "title": "2  Zahlen",
    "section": "",
    "text": "Wir verstehen wie ein Computer Zahlen darstellt und speichert.\nWir führen das Bit als zentrale Informationseinheit im Computer ein.\nWir lernen Kontrollstrukturen kennen, mit denen wir unser Programm steuern können.\nWir fügen Funktionen zu unserem Werkzeugkasten hinzu, um besseren Code zu schreiben.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#experimentaufbau",
    "href": "numbers.html#experimentaufbau",
    "title": "2  Zahlen",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\nDas erste Experiment in Kapitel 1 war ein guter Einstieg! In diesem Kapitel legen wir noch eine Schippe drauf: Unsere Hardware bekommt ein neues Bauteil – einen Drehknopf (Rotary Encoder Bricklet 2.0). Das montiert ihr einfach neben der LED, wie in Abbildung 2.1 gezeigt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Draufsicht.\n\n\n\n\n\n\n\n\n\n\n\n(c) Nahaufnahme des Rotary Encoders.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n(e) Untenansicht.\n\n\n\n\n\n\n\nAbbildung 2.1: Einfaches Setup mit einem Mikrocontroller, LED und einem Drehknopf.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-first-steps",
    "href": "numbers.html#sec-numbers-first-steps",
    "title": "2  Zahlen",
    "section": "2.1 Erste Schritte mit dem Drehknopf",
    "text": "2.1 Erste Schritte mit dem Drehknopf\nWie bei der LED werfen wir zuerst einen Blick auf den neuen Drehknopf im Brick Viewer. Schließt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Setup-Tab sollte nun neben der LED auch der Rotary Encoder auftauchen. Denkt daran: Dort findet ihr auch die UID eurer Geräte – die braucht ihr gleich für euer Programm.\n\n\n\n\n\n\nAbbildung 2.2: Der Brick Viewer nach dem Connect.\n\n\n\nWechselt nun in den Tab für den Drehknopf, wo ihr ihn direkt testen könnt: Ihr seht den aktuellen Zählwert. Der kann positiv oder negativ sein – je nachdem, wie oft und in welche Richtung ihr gedreht habt. Daneben zeigt ein Diagramm die zeitliche Entwicklung.\nDoch der Knopf kann mehr als nur zählen: Ihr könnt ihn auch drücken. Achtet mal auf den kleinen Kreis im Brick Viewer. Wird er gedrückt, leuchtet er rot. Noch löst das Drücken keine Aktion aus, aber wir überlegen später, welche Funktion wir damit verbinden wollen.\nUnd zuletzt: der Button Reset Count. Damit setzt ihr den Zähler zurück – eine praktische Funktion, die wir später ebenfalls ins Programm einbauen können.\n\n\n\n\n\n\n\n\nDas Diagramm zeigt den aktuellen Wert an.\n\n\n\n\n\n\n\n\n\n\n(a) Der Button wird rot, wenn er gedrückt ist.\n\n\n\n\n\n\n\nAbbildung 2.3: Die Funktionen des Rotary Encoders im Brick Viewer.\n\n\n\nFassen wir zusammen, was unser Drehknopf (Rotary Encoder) draufhat:\n\nEr zählt – vorwärts und rückwärts\nEr merkt, wenn ihr ihn drückt\nEr kann seinen Zähler zurücksetzen\n\nZeit also, das Ganze in Python auszuprobieren und zu sehen, welche coolen Anwendungen wir damit bauen können.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#zähler-auslesen",
    "href": "numbers.html#zähler-auslesen",
    "title": "2  Zahlen",
    "section": "2.2 Zähler auslesen",
    "text": "2.2 Zähler auslesen\nDer Drehknopf funktioniert ähnlich wie der Lautstärkeregler einer Stereoanlage (siehe Abbildung 2.4): Dreht ihr nach rechts, wird es lauter – nach links, leiser.\n\n\n\n\n\n\nAbbildung 2.4: Die gute alte Stereoanlage mit Drehknopf! Wer kennt sie nicht mehr? (Quelle: Wikimedia)\n\n\n\nIm Hintergrund verändert sich bei jeder Drehung der Wert, den der Knopf sendet – mal höher, mal niedriger, je nach Ausgangszustand. Im Brick Viewer habt ihr das schon gesehen. Probieren wir es jetzt in einem Programm aus: Der folgende Code verbindet sich mit dem Drehknopf, liest den aktuellen Wert und gibt ihn in der Konsole aus. Denkt daran, eure eigene UID einzutragen:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\n1knob = BrickletRotaryEncoderV2('WZd', ipcon)\n2count = knob.get_count(reset=False)\nprint(count)\n\n\n1\n\nWir erstellen eine virtuelle Repräsentation des Drehknopfs in unserem Programm, um seine Funktionen verwenden zu können.\n\n2\n\nÜber die virtuelle Repräsentation des Drehknopfs können wir mittels get_count() den aktuellen Wert abfragen. Der Parameter reset bestimmt, ob der Zähler nach dem Auslesen zurückgesetzt werden soll oder nicht.\n\n\n\n\nDie Ausgabe sollte mit dem Wert übereinstimmen, den ihr auch im Brick Viewer seht – kein Wunder, beide nutzen dieselbe Programmierschnittstelle. Damit habt ihr die erste Funktion des Drehknopfs erfolgreich aus Python getestet.\nDreht ihr den Knopf und startet das Programm erneut, erscheint natürlich ein anderer Wert. Klar! Aber jedes Mal neu starten? Das geht besser. Die Lösung kennt ihr schon aus Kapitel 1: eine Schleife, die das Programm so lange wiederholt, bis wir es beenden:\n\nwhile True:\n    count = knob.get_count(reset=False)\n    print(count)\n\nZur Erinnerung: while True erzeugt eine Endlosschleife. Normalerweise wollen wir so etwas vermeiden – außer, wir brauchen es genau dafür. Endlosschleifen sind praktisch, wenn wir kontinuierlich Daten lesen oder auf Ereignisse warten. Und keine Sorge: Mit Strg+C könnt ihr das Programm jederzeit beenden.\nWenn ihr das Programm ausführt, werdet ihr direkt ein Problem erkennen. Die Schleife rennt förmlich und gibt nacheinander immer wieder denselben Wert aus. Nur wenn wir am Knopf drehen, ändert sich der Wert – wird aber von der Schleife x-mal auf die Konsole geschrieben. Wie könnten wir das verbessern?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-control-structures",
    "href": "numbers.html#sec-numbers-control-structures",
    "title": "2  Zahlen",
    "section": "2.3 Kontrollstrukturen",
    "text": "2.3 Kontrollstrukturen\nWie wäre es hiermit?\n\nlast_count = None\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n        print(last_count)\n\nGehen wir durch, was hier passiert: Zuerst weisen wir der Variable last_count vor dem ersten Schleifendurchlauf den Wert None zu. Anschließend wird in jedem Durchlauf der aktuelle Zählerstand ausgelesen und in der Variable new_count gespeichert. Danach prüfen wir, ob sich der neue Wert im Vergleich zum alten unterscheidet. Da last_count im ersten Durchlauf None ist, wird die Bedingung in Zeile 5 beim Start immer True sein. Somit geben wir den Wert zu Beginn auf jeden Fall aus – genau so, wie es für die Anwendung sinnvoll ist.\nIn den folgenden Schleifendurchläufen wird nur dann etwas ausgegeben, wenn sich der Wert verändert hat, ihr also tatsächlich am Drehknopf gedreht habt. Ansonsten bleibt die Ausgabe unverändert.\nDie Prüfung, ob der aktuelle Wert (gespeichert in new_count) sich vom alten Wert unterscheidet, erfolgt in Zeile 5. Hier lernen wir auch ein neues Konzept der Programmierung kennen: die Kontrollstruktur if, gefolgt von einer Bedingung.\nNeu ist hier die Kontrollstruktur if. Sie prüft eine Bedingung, die – wie ihr schon aus Kapitel 1 kennt – nur True oder False sein kann. Ist sie wahr (True), läuft der eingerückte Code darunter. Ist sie falsch (False), passiert nichts.\nÜbertragen auf unser Programm heißt das: print(last_count) läuft nur dann, wenn sich der Wert tatsächlich verändert hat. In diesem Fall merken wir uns den neuen Wert und aktualisieren last_count. Beim nächsten Schleifendurchlauf prüfen wir wieder, ob sich etwas getan hat. Meistens ist das nicht so – und genau deshalb sehen wir nur dann eine Ausgabe, wenn wir wirklich am Knopf drehen. Ziemlich effizient, oder?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#led-dimmer-1.0",
    "href": "numbers.html#led-dimmer-1.0",
    "title": "2  Zahlen",
    "section": "2.4 LED-Dimmer 1.0",
    "text": "2.4 LED-Dimmer 1.0\nWenden wir das Gelernte an und bauen einen praktischen LED-Dimmer. Dafür holen wir unsere LED aus Kapitel 1 mit dazu und kombinieren sie mit dem Drehknopf.\nDie Idee ist simpel: Der Zähler des Knopfs steuert die Helligkeit der LED. Dreht ihr nach rechts, wird sie heller, nach links, dunkler. Wie bei der Stereoanlage in Abbildung 2.4.\nBevor wir uns an die eigentliche Anwendungslogik machen, brauchen wir Zugriff auf beide Geräte – LED und Drehknopf. Dazu erweitern wir den bekannten Boilerplate-Code und speichern die Geräte in eigenen Variablen:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nknob = BrickletRotaryEncoderV2('WZd', ipcon) \nled = BrickletRGBLEDV2('ZG1', ipcon)\n\nDieser Teil muss immer am Anfang unseres Programms stehen, damit alles funktioniert. In den kommenden Beispielen setzen wir ihn als gegeben voraus und wiederholen ihn nicht jedes Mal.\nAls Startpunkt nehmen wir den Code von oben, der den Zählerwert auf der Konsole ausgibt. Schließlich brauchen wir genau diese Information – wann sich der Wert ändert und wie er aktuell steht – auch, um die LED zu steuern.\nDamit wir die LED von aus bis volle Helligkeit dimmen können, legen wir uns zuerst auf eine Farbe fest. Ich bin zwar kein Fan von weißem LED-Licht, aber für dieses Kapitel ist es am einfachsten: voll aufgedreht leuchtet die LED weiß, ausgedreht ist sie schwarz – klar! Später kümmern wir uns darum, wie wir das Licht wärmer machen können.\nErinnern wir uns also: Was bedeuten die Zustände An und Aus im RGB-Farbraum?\n\n# White\nled.set_rgb_value(255, 255, 255)\n\n# Black (off)\nled.set_rgb_value(0, 0, 0)\n\nDamit haben wir die beiden Extremzustände festgelegt. Doch was passiert dazwischen, wenn die LED gedimmt ist? Ganz einfach: Wir lassen die drei RGB-Werte gemeinsam von 1 bis 254 hoch- oder runterlaufen. Höhere Werte ergeben ein helleres Weiß, niedrigere ein dunkleres.\nSetzen wir diese Erkenntnisse in Programmcode um und weisen den Zählerwert den RGB-Werten der LED zu. Spoiler-Alert: Das ist etwas naiv, aber lasst uns mal schauen, was passiert und wo möglicherweise Probleme auftreten:\n\nknob.reset()\nlast_count = 0\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n        print(last_count)\n\n        # Setze RGB-Werte auf den Zählerwert\n        led.set_rgb_value(last_count, last_count, last_count)\n\nLasst es mal laufen und dreht voll auf oder runter! Beobachtet dabei den Wert für last_count. Was passiert, wenn er kleiner als Null wird? Oder wenn er größer als 255 wird? Bumm! Das Programm stürzt ab!\nWarum? Auf der Kommandzeile bekommen wir eine lange Fehlermeldung mit der folgenden Aussage ganz am Ende:\n#| code-line-numbers: false\nstruct.error: ubyte format requires 0 &lt;= number &lt;= 255\nWenn man die Fehlermeldung googelt oder ChatGPT befragt, bekommt man Hilfe. Offensichtlich wird für einen RGB-Wert, den wir der Funktion set_rgb_value() übergeben, ein bestimmter Datentyp erwartet, der ubyte heißt. Das steht für “unsigned byte” und bedeutet, dass der Wert zwischen 0 und 255 liegen muss.\nMoment 🧐 – was hat jetzt das Byte mit 0 bis 255 zu tun? Bisher dachten wir doch, das wäre wegen des RGB-Codes? Stimmt auch, aber der RGB-Code liegt nicht zufällig im Wertebereich von 0 bis 255.\nUm das zu verstehen, müssen wir das Binärsystem kennen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#zahlensysteme",
    "href": "numbers.html#zahlensysteme",
    "title": "2  Zahlen",
    "section": "2.5 Zahlensysteme",
    "text": "2.5 Zahlensysteme\nEigentlich ist es schnell erklärt. Das Binärsystem ist wie das Dezimalsystem, mit dem wir alltäglich unterwegs sind – nur nutzt es statt der Basis 10 die Basis 2. Einfach, oder? Wenn nicht, lest weiter – das hier soll schließlich ein Einführungsbuch sein.\n\n2.5.1 Unser Dezimalsystem\nWir wenden das Dezimalsystem täglich intuitiv an. Es fragt sich wahrscheinlich niemand von euch, was die Systematik dahinter ist, oder? Und doch habt ihr es alle einmal in der Schule gelernt, und wir müssen es an dieser Stelle etwas auffrischen. Solltet ihr mit Stellenwertsystemen noch 100 % vertraut sein, könnt ihr diesen Abschnitt getrost überspringen.\nNehmen wir eine Zahl wie die 123 als Beispiel. Wir haben sofort ein Gefühl für die Zahl, wir wissen etwa, wie groß sie ist. Und wenn wir es etwas genauer erklären müssen, können die meisten von euch sicher erläutern, wofür – also für welchen Wert – jede Ziffer steht. Wir beginnen mit der kleinsten Wertigkeit, also der Ziffer ganz rechts: der 3. Sie steht für die Einserstelle, und davon haben wir 3. Die nächste Stelle steht für die Zehner, und weil dort eine 2 steht, sind es zwanzig. Also \\(3+20=23\\). Schließen wir auch die dritte und letzte Ziffer in unsere Erläuterung ein: Die 1 steht für die Hunderterstelle, also \\(1*100=100\\). Damit haben wir \\(100+20+3=123\\). Ganz einfach und intuitiv.\n\n\n\n\n\n\n\n\n\n\n\n(a) Im Dezimalsystem hat jede Stelle einen anderen Wert.\n\n\n\n\n\n\n\n\n\n\n\n(b) Durch Ausmultiplizieren errechnen wir den Wert der Zahl.\n\n\n\n\n\n\n\nAbbildung 2.5: Das Dezimalsystem ist ein Stellenwertsystem.\n\n\n\nDas Ganze funktioniert nicht nur mit dreistelligen Zahlen, sondern prinzipiell mit beliebig langen Zahlen. Wir wissen, dass die nächste Ziffer, die wir links im Beispiel in Abbildung 2.6 sehen, für die Tausenderstelle steht. Die nächste Stelle würde für die Zehntausenderstelle stehen – und so weiter. Warum fällt es uns so leicht?\nErstens, weil wir damit jeden Tag umgehen. Das Dezimalsystem ist das System, das wir am häufigsten verwenden, und wir haben es von klein auf gelernt. Es ist intuitiv und einfach zu verstehen. Zweitens aber auch, weil wir die Systematik kennen: Jede Stelle ist 10-mal so viel wert wie die vorherige.\n\n\n\n\n\n\nAbbildung 2.6: Jede Stelle steht für eine höhere Potenz der Basis 10.\n\n\n\nWurde uns das Dezimalsystem von Gott gegeben? Vielleicht – wenn man an die Schöpfung glaubt1 und daran, dass Gott uns so geschaffen hat, wie wir sind, dann hat er implizit dafür gesorgt, dass wir dezimal denkende Wesen werden. Warum? Eine Theorie besagt, dass die menschliche Anatomie, insbesondere die Anzahl der Finger, einen Einfluss auf unser Zahlensystem hatte. Zählt einfach mal anhand eurer Finger durch.\n\n\n2.5.2 Das Oktalsystem\nNun gibt es auch Wesen mit weniger als zehn Fingern (und auch mit mehr?). Nehmt mal einen Cartoon-Charakter wie Mickey Mouse als Beispiel. In Abbildung 2.7 seht ihr, wie hier wahrscheinlich gezählt wird. Hätte ein Volk von Mickey-Mäusen sich auch für das Dezimalsystem entschieden?\n\n\n\n\n\n\nAbbildung 2.7: Cartoon-Charaktere haben nur acht Finger. Quelle: Erstellt mit ChatGPT nach Petzold (2022)\n\n\n\nVermutlich nicht!\n\n\n\n\n\n\nAbbildung 2.8: Das Oktalsystem funktioniert wie das Dezimalsystem. Nur die Basis ist 8 statt 10.\n\n\n\n\n\n2.5.3 Das Binärsystem\nTreiben wir es noch ein wenig weiter auf die Spitze und nehmen ein paar Finger weg – sagen wir bis auf zwei. Dann wären wir vielleicht bei einem Delfin mit zwei Flossen, wie ihr ihn in Abbildung 2.9 seht. Delfine haben sich vermutlich auf ein System geeinigt, das auch für unsere heutigen Computer die Grundlage darstellt: das Binärsystem.\n\n\n\n\n\n\nAbbildung 2.9: Delfine würden anders zählen. Eher wie Computer.\n\n\n\nDas Wort “binär” stammt aus dem Lateinischen und bedeutet “paarweise” oder “zu zweit”. Von diesem Wort stammt auch der Name des Stellenwertsystems mit der Basis 2 – und das nicht ohne Grund. Im Binärsystem gibt es für jede Stelle genau zwei Möglichkeiten: 0 oder 1. Ein anderer Begriff ist übrigens Dualsystem, was genau das Gleiche meint. Auch das Wort “dual” kommt von den Römern und heißt so viel wie “zwei enthaltend”.\n\n\n\n\n\n\nAbbildung 2.10: Eine Binärziffer ist vergleichbar mit einem Lichtschalter, der an oder aus sein kann.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nAbbildung 2.11: Das Binärsystem funktioniert wie alle anderen Stellenwertsysteme auch.\n\n\n\n\n\n\n2.5.4 Andere Systeme\n\nRömische Zahlen\nTally-Schreibweise",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-bit-and-bytes",
    "href": "numbers.html#sec-numbers-bit-and-bytes",
    "title": "2  Zahlen",
    "section": "2.6 Bits & Bytes",
    "text": "2.6 Bits & Bytes\n\n2.6.1 Zwei Zustände\nWarum haben wir uns Zahlensysteme angeschaut, und was hat das mit Computern zu tun? Ganz einfach: Computer denken binär. Das bedeutet, sie kennen nur zwei Zustände: an oder aus, 0 oder 1.\nWir kommen später noch einmal ausführlich darauf zurück, aber so viel schon vorweg: Eine Binärziffer nennen wir im Englischen “binary digit”, kurz “bit”. Jetzt klingelt es, oder?\nEin Bit ist eine Informationseinheit. Nicht irgendeine, sondern die kleinste, die es gibt. Die Erklärung, warum das so ist, folgt später. Wir wollen uns an dieser Stelle die Frage stellen, was wir mit einem Bit alles anstellen können.\nEin Bit ist alleine ziemlich einsam und eingeschränkt. Wenn sich ein Computer mit einem Bit lediglich merken kann, ob eine Lampe an oder aus ist, dann sind das genau zwei Möglichkeiten. Nicht besonders viel. Wir kamen aber von den Farben über Zahlensysteme zu den Bits – und unsere ursprüngliche Frage war, wie ein Computer mit seinen Mitteln – also Nullen und Einsen (oder eben Bits) – so viele unterschiedliche Farben abbilden und speichern kann. Zwei würden gerade einmal für Schwarz/Weiß ausreichen.\nIhr ahnt es vielleicht schon: Wir gesellen zum ersten ein zweites Bit hinzu. Und schon können wir vier unterschiedliche Zustände abbilden: 00, 01, 10 und 11. Damit könnten wir zum Beispiel die Farben Schwarz, Blau, Grün und Cyan darstellen. Etwas willkürlich (warum gerade diese Farben), aber denkbar.\nWas passiert, wenn wir ein drittes Bit hinzunehmen? Sind es nun sechs Zustände? Nein, es sind acht: 000, 001, 010, 011, 100, 101, 110 und 111. Damit könnten wir die Farben Schwarz, Blau, Grün, Cyan, Rot, Magenta, Gelb und Weiß darstellen (oder jede andere Kombination, die wir uns wünschen).\nMit jedem zusätzlichen Bit können wir also nicht plus zwei mehr Zustände abbilden, sondern wir verdoppeln unsere Möglichkeiten. Also müssen wir mal zwei – und nicht plus zwei – rechnen. Das ist eine gute Nachricht, denn die Anzahl der Farben, die wir mit jedem zusätzlichen Bit darstellen können, verdoppelt sich jedes Mal.\nDas halten wir fest, aber schauen wir zurück auf unsere RGB-Farben und die Fehlermeldung, die wir zuletzt bekommen haben. Der Wert für eine Farbe aus dem RGB-Farbcode muss zwischen 0 und 255 liegen. Wir haben somit inklusive der Null 256 Möglichkeiten für jede der drei RGB-Grundfarben. Wie viele Bits benötigen wir dafür? Rechnen wir es aus:\n\\[\n\\begin{aligned}\n2^0 &= 1 \\\\\n2^1 &= 2 \\\\\n2^2 &= 4 \\\\\n2^3 &= 8 \\\\\n2^4 &= 16 \\\\\n2^5 &= 32 \\\\\n2^6 &= 64 \\\\\n2^7 &= 128 \\\\\n2^8 &= 256 \\\\\n\\end{aligned}\n\\]\nStopp! \\(2^8 = 256\\), das genügt uns völlig. Mit 8 Bits können wir somit 256 Zustände abbilden – genau passend für 256 Rot-, Grün- oder Blauanteile.\n\n\n2.6.2 Acht Bits macht ein Byte\nUnd das ist kein Zufall: 8 Bits sind für Computer eine besondere Größe. Wir nennen eine Gruppe von 8 Bits ein Byte. Und jetzt dürfte es erneut klingeln.\n\n\n\n\n\n\nAbbildung 2.12: Ein Byte könnt ihr euch vorstellen wie acht Glühbirnen nebeneinander.\n\n\n\nIn Abbildung 2.12 ist ein Byte als Reihe von acht Glühbirnen dargestellt. Ihr könnt euch vorstellen, dass Bits mit dem Wert 1 leuchten und Bits mit dem Wert 0 aus sind. Um den Wert zu ermitteln, den das Byte gerade darstellt, könnt ihr jeder Glühbirne von rechts nach links die entsprechenden Wertigkeiten der Stellen aus dem Binärsystem zuweisen und die Werte addieren. Stellen, an denen die Glühbirne leuchtet, werden addiert, die anderen werden ausgelassen (Abbildung 2.13). Das Byte im gezeigten Beispiel steht somit für:\n\\[\n32 + 8 + 1 = 41\n\\]\nWofür steht das Byte, wenn alle Lampen leuchten? Oder anders gefragt: Was ist die größte Zahl, die wir mit einem Byte darstellen können?\n\\[\n128+64+32+16+8+4+2+1 = 255\n\\]\nDie Antwort überrascht uns nicht, denn schließlich haben wir es ja schon herausgefunden: Ein Byte erlaubt uns, Werte zwischen 0 (alle Glühbirnen aus) und 255 (alle Glühbirnen an) darzustellen. Insgesamt also 256 Möglichkeiten. Somit können wir mit 8 Glühbirnen die Intensität einer der drei Grundfarben im RGB-Code darstellen.\n\n\n\n\n\n\nAbbildung 2.13: Jede Glühbirne steht für eine Stelle aus dem Binärsystem.\n\n\n\nDas erklärt auch die Fehlermeldung von oben: Ein Byte kann Werte zwischen 0 und 255 darstellen. Wir haben im Experiment den Drehknopf voll nach oben oder nach unten gedreht, wodurch der Wert entweder größer als 255 oder kleiner als 0 wurde. Und damit ist es kein gültiger Wert im Sinne eines Bytes mehr.\n\n\n2.6.3 Kilo, Mega, Giga\nEin Byte besteht aus 8 Bits. Wenn wir also von Bytes sprechen, reden wir oft auch von Kilobytes, Megabytes, Gigabytes et cetera. Diese Begriffe sind wichtig, um die Größe von Daten zu beschreiben. In Tabelle 2.1 seht ihr eine Übersicht über die verschiedenen Größenordnungen.\n\n\n\nTabelle 2.1: Verschiedene Mengeneinheiten für Bytes und deren ungefähre Entsprechung.\n\n\n\n\n\n\n\n\n\n\n\nPotenz (Bytes)\nAusgeschrieben\nBezeichnung (Abkürzung)\nEntspricht ca.\n\n\n\n\n\\(10^3\\)\nTausend\nKilobyte (KB)\nkleine Textdatei\n\n\n\\(10^6\\)\nMillion\nMegabyte (MB)\nDigitales Foto\n\n\n\\(10^9\\)\nMilliarde\nGigabyte (GB)\nFilm (DVD 4,7 GB)\n\n\n\\(10^{12}\\)\nBillion\nTerabyte (TB)\nGängige Festplattenkapazität\n\n\n\\(10^{15}\\)\nBilliarde\nPetabyte (PB)\nSpeichervolumen Rechenzentrum\n\n\n\\(10^{18}\\)\nTrillion\nExabyte (EB)\nInternetverkehr pro Tag\n\n\n\\(10^{21}\\)\nTrilliarde\nZettabyte (ZB)\nDatenbestand weltweit (&gt;100 ZB)\n\n\n\\(10^{24}\\)\nQuadrillion\nYottabyte (YB)\nkeine Entsprechung\n\n\n\n\n\n\nJetzt, da ihr wisst, was mit einem Byte gemeint ist, könnt ihr eine ungefähre Vorstellung für die Größenordnungen von Datenmengen entwickeln. Die ersten drei Zeilen aus Tabelle 2.1 könnt ihr selbst einmal nachvollziehen. Schaut euch dazu mal eine Textdatei an, notiert deren Größe und rechnet aus, wie viele Glühbirnen für die Speicherung gebraucht werden. Denkt daran: Ein Byte entspricht acht Glühbirnen.\nWir kommen in den späteren Kapiteln immer wieder auf die Bits und Bytes zurück, weil wir in Computern letztlich überall mit diesen Einheiten arbeiten. Es ist somit gut, wenn ihr schon an dieser Stelle ein grundlegendes Verständnis für diese Konzepte entwickelt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-led-dimmer-part-2",
    "href": "numbers.html#sec-led-dimmer-part-2",
    "title": "2  Zahlen",
    "section": "2.7 LED-Dimmer 2.0",
    "text": "2.7 LED-Dimmer 2.0\nZurück zu unserem eigentlichen Vorhaben. Wir waren gerade dabei, einen Dimmer für unsere LED zu basteln, als uns die Zahlensysteme dazwischengekommen sind. Dafür haben wir jetzt ein besseres Verständnis dafür, wie ein Computer Farben sieht – nämlich als lange Sequenz aus Nullen und Einsen. Und zwar 24 davon, weil jede Grundfarbe ein Byte an Speicher verwendet.\n\n2.7.1 min() und max()\nWas müssen wir also in unserem Programm verändern, jetzt, da wir wissen, was zuvor das Problem war? Genau! Wir müssen sicherstellen, dass die Werte, die wir an die LED senden, im gültigen Bereich für ein Byte liegen – und zwar zwischen 0 und 255.\n\nknob.reset()\nlast_count = 0\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n\n        # Clamp last_count to valid byte range\n1        last_count = max(0, min(255, last_count))\n\n        print(last_count)\n\n        # Setze RGB-Werte auf den Zählerwert\n        led.set_rgb_value(last_count, last_count, last_count)\n\n\n1\n\nDie Funktionen min() und max() sorgen dafür, dass der Wert von last_count immer zwischen 0 und 255 bleibt. Wenn last_count kleiner als 0 ist, wird er auf 0 gesetzt. Wenn er größer als 255 ist, wird er auf 255 gesetzt.\n\n\n\n\nDie neue Logik in Zeile 9 hilft uns dabei. Nachdem wir den neuen Wert des Zählers in der Variable last_count gespeichert haben (Zeile 6), wenden wir eine geschickte Kombination der beiden Funktionen max() und min() an, um sicherzustellen, dass der Wert im gültigen Bereich bleibt. Wie funktioniert das genau? Dazu gehen wir die Zeile Schritt für Schritt durch.\nZunächst einmal der Ausdruck min(255, last_count). Die Funktion min() gibt einfach den kleineren der beiden Werte zurück, die ihr übergeben werden. Wenn last_count also größer als 255 ist, wird 255 zurückgegeben. Andernfalls wird last_count zurückgegeben. Das Ergebnis dieser Auswertung ist gleichzeitig der zweite Wert, den wir der Funktion max() übergeben.\nDie Funktion max() macht genau das Gegenteil. Sie gibt den größeren der beiden ihr übergebenen Werte zurück. Zur Auswahl stehen ihr der Wert 0 und das Ergebnis der min()-Funktion. Das bedeutet, dass max() sicherstellt, dass der endgültige Wert von last_count niemals kleiner als 0 ist.\nUnd voilà! Nach Zeile 9 kann der Wert von last_count nur noch zwischen 0 und 255 liegen. Problem gelöst!\nProbiert es am besten direkt aus und dreht mal voll auf! Es sollte nun kein Fehler mehr auftreten.\n\n\n2.7.2 Helligkeit entkoppeln\nVielleicht habt ihr es auch bemerkt, aber so richtig toll funktioniert unser Dimmer immer noch nicht. Zwar erscheint keine Fehlermeldung mehr, wenn wir endlos aufdrehen. Jedoch wird die LED auch nicht gedimmt, wenn wir wieder in die andere Richtung drehen. Der Grund dafür ist einfach: Die Helligkeit der LED hängt in unserem Programm direkt vom Zählerstand des Drehknopfes ab. Wenn der über 255 kommt, wird die Helligkeit zwar auf 255 gedeckelt, der Zähler wird aber im Hintergrund trotzdem weiter hochgezählt. Wenn wir die LED wieder dimmen, also einen Helligkeitswert von weniger als 255 erreichen möchten, dann müssen wir zunächst mit dem Drehknopf wieder bis unter die 255 kommen.\nViel schöner wäre es, wenn wir zwar endlos überdrehen könnten, aber mit der ersten Drehung in die andere Richtung die Helligkeit der LED sofort verringern. Ein einfacher Weg wäre, für den Zählerstand des Drehknopfes analog zu last_count nur Werte zwischen 0 und 255 zu erlauben. Dazu könnten wir den Zähler – genau wie last_count – manuell auf 0 oder 255 setzen, je nachdem, ob wir größer als 255 oder kleiner als 0 waren. Leider bietet der Drehknopf über seine Programmierschnittstelle keine solche Funktion an. Wir können den Wert zwar auslesen, aber nicht programmatisch verändern.\nWir müssen also einen Workaround entwickeln. Eine Möglichkeit wäre, die Helligkeit unabhängig vom Zählerstand zu verwalten und dafür eine eigene Variable brightness einzuführen. Wir könnten den Wert von brightness dann erhöhen oder verringern, wenn wir eine Drehung in die eine oder andere Richtung erkannt haben.\nUm zu erkennen, ob und in welche Richtung der Drehknopf gedreht wurde, können wir die Differenz zwischen dem aktuellen und dem letzten Zählerstand betrachten. Sie gibt uns direkt Aufschluss: Ist die Differenz positiv, wurde der Knopf nach oben gedreht, ist sie negativ, wurde er nach unten gedreht.\n\nknob.reset()\nlast_count = 0\n\n1brightness = 0\nled.set_rgb_value(brightness, brightness, brightness) \n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n2        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n3        brightness += diff\n        brightness = max(0, min(255, brightness))\n\n        # Setze RGB-Werte auf den Zählerwert\n        led.set_rgb_value(brightness, brightness, brightness)\n\n4        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n1\n\nDie neue Variable brightness zu Beginn mit 0 initialisieren. Die LED soll aus sein.\n\n2\n\nHier ermitteln wir die Differenz zwischen dem aktuellen und dem letzten Zählerstand und speichern sie in der Variable diff.\n\n3\n\nWir passen die Helligkeit an, indem wir brightness um diff erhöhen oder verringern. Dabei stellen wir sicher, dass der Wert zwischen 0 und 255 bleibt.\n\n4\n\nZur Überprüfung geben wir beide Variablen aus. Wenn wir den Wertebereich 0–255 verlassen, gehen die Werte der beiden Variablen auseinander.\n\n\n\n\n\n\n2.7.3 Konstanten\nDas sieht schon sehr gut aus! Unser Dimmer ist fast fertig, die grundlegende Funktionalität läuft robust. Eine Kleinigkeit stört mich noch: Der Dimmer reagiert nur sehr langsam, und wir müssen scheinbar endlos drehen, um die LED auf die volle Helligkeit zu bekommen. Können wir das beschleunigen?\nDas ist natürlich eine rhetorische Frage – in der Programmierung können wir so gut wie alles umsetzen. Und in diesem Fall ist es sogar recht einfach. Damit die LED schneller hell oder dunkel wird, wenn wir am Drehknopf drehen, können wir die Anpassung der Helligkeit einfach verstärken. Momentan wird die Variable brightness um die Differenz des Zählerstands erhöht oder verringert. Wir könnten stattdessen einen festen, höheren Schrittwert definieren, um die Helligkeit schneller zu ändern.\nDazu definieren wir eine neue Variable, die eine Besonderheit hat. Wir geben ihr den Namen STEP, der nur aus Großbuchstaben besteht (Zeile 3). Gemäß der Regeln für die Bennung von Variablen in Python werden Namen in GROSSBUCHSTABEN üblicherweise für Konstanten verwendet – und tatsächlich ist STEP genau genommen auch keine Variable, sondern eine Konstante.\nEine Konstante unterscheidet sich dadurch, dass ihr Wert einmal festgelegt wird und sich danach nicht mehr ändert. In unserem Fall wollen wir, dass STEP immer den Wert 10 hat. Konstanten definieren wir typischerweise zu Beginn eines Python-Programms, damit man einen schnellen Überblick über alle definierten Konstanten und ihre Werte bekommen kann.\nEs ist wichtig zu verstehen, dass der fixe Wert einer Konstante sich nur auf die Ausführung des Programms bezieht. Zwischen mehreren Ausführungen desselben Programms kann der Wert einer Konstante geändert werden. Zum Beispiel könnten wir als Hersteller des LED-Dimmers für eine neue Version entscheiden, dass dieser sich noch schneller dimmen lassen soll, und wir erhöhen den Wert für STEP auf 20. Oder der Benutzer könnte diesen Wert über die Einstellungen der hypothetischen Dimmer-App anpassen.\nWenn wir – wie in Zeile 15 gezeigt – die Differenz des Zählers mit der Schrittgröße multiplizieren, können wir die Anpassung der Helligkeit verstärken.\n\n\n\n\nListing 2.1: Der fertige LED-Dimmer (ohne Boilerplate-Code)\n\n\nknob.reset()\nbrightness = 0\n1STEP = 10\nled.set_rgb_value(brightness, brightness, brightness) \n\nlast_count = 0\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n2        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        # Setze RGB-Werte auf den Zählerwert\n        led.set_rgb_value(brightness, brightness, brightness)\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n\n\n\n1\n\nHier definieren wir eine Konstante STEP und weisen ihr den Wert 10 zu.\n\n2\n\nDie Helligkeit wird nun um diff * STEP angepasst, was bedeutet, dass jede Drehung des Knopfes einen größeren Einfluss auf die Helligkeit hat.\n\n\n\n\nMit dem LED-Dimmer haben wir die zentrale Funktion des Drehknopfes zur Genüge kennengelernt. Das Gerät hat aber noch eine andere Funktion.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#druckknopf-auslesen",
    "href": "numbers.html#druckknopf-auslesen",
    "title": "2  Zahlen",
    "section": "2.8 Druckknopf auslesen",
    "text": "2.8 Druckknopf auslesen\nNeben dem Zähler besitzt der Drehknopf (der Name sagt es schon) noch eine Funktion, nämlich die eines einfachen Druckknopfes. Wir haben es weiter oben in Abschnitt 2.1 mit dem Brick Viewer schon ausprobiert: Der Drehknopf lässt sich drücken und erzeugt eine haptische Rückmeldung, ein leichtes Knacken. Im Brick Viewer wurde der kleine Kreis auf der rechten Seite dann rot eingefärbt.\nSelbstverständlich können wir den Zustand des Buttons auch aus einem Programm heraus abfragen. Dazu bietet uns der Drehknopf eine Methode is_pressed() an:\n\nwhile True:\n    if knob.is_pressed():\n        print(\"Button pressed\")\n    else:\n        print(\"Button not pressed\")\n\nDie Funktion liefert True zurück, wenn der Button gerade gedrückt ist, und ansonsten False. Das können wir wunderbar nutzen und darüber eine Bedingung formulieren, um entweder “Button pressed” oder “Button not pressed” auf der Konsole auszugeben. Ihr erinnert euch bestimmt an das if-Statement aus Abschnitt 2.3. Das ist genau das, was wir jetzt brauchen!\n\n\n\n\nListing 2.2: Ein erster Test des Drehknopf-Buttons.\n\n\n1button_pressed_before = False\nwhile True:\n    button_pressed_after = knob.is_pressed()\n\n2    if button_pressed_before == True and button_pressed_after == False:\n3        print(\"Button was pressed and released\")\n    \n4    button_pressed_before = button_pressed_after\n\n\n\n\n\n1\n\nWir initialisieren eine Variable button_pressed_before, die den vorherigen Zustand des Buttons speichert. Am Anfang gehen wir mal davon aus, dass er nicht gedrückt ist.\n\n2\n\nMit dem if-Statement überprüfen wir, ob der Button logelassen wurde. Dazu muss der vorherige Zustand True und der aktuelle Zustand False sein.\n\n3\n\nWenn der Button soeben losgelassen wurde, geben wir eine entsprechende Information auf der Konsole aus.\n\n4\n\nAm Ende der Schleife aktualisieren wir den vorherigen Zustand button_pressed_before, damit er den aktuellen Zustand für die nächste Iteration speichert.\n\n\n\n\nDas reicht fürs Erste – der Button kann tatsächlich nicht mehr als das. Reicht aber auch: Damit können wir unserem Dimmer schon einen zusätzlichen Mehrwert verleihen. Schließlich kann unsere LED nicht nur weiß leuchten.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-led-dimmer-part-3",
    "href": "numbers.html#sec-led-dimmer-part-3",
    "title": "2  Zahlen",
    "section": "2.9 LED-Dimmer 3.0",
    "text": "2.9 LED-Dimmer 3.0\nWäre es nicht praktisch, wenn wir das Licht der LED nicht nur dimmen, sondern auch den Farbton verändern könnten? Weißes Licht ist am Abend bekanntlich nicht empfehlenswert, und grünes Licht soll beruhigend wirken.\nLasst uns unseren Dimmer so erweitern, dass per Knopfdruck der Farbton gewechselt werden kann. Fürs Erste wollen wir die Farben Weiß, Gelb und Grün anbieten. Das lässt sich später beliebig erweitern.\n\n2.9.1 Farbe per Variable steuern\nDer Ausgangspunkt für unser dimmbares Stimmungslicht ist der Dimmer aus Listing 2.1. Von hier aus fügen wir Schritt für Schritt die Logik für den Farbwechsel per Button ein. Lasst uns aber zunächst ganz ohne Button versuchen, die Farbe der LED zu ändern.\nBisher haben wir es uns einfach gemacht und die LED in Weiß leuchten lassen. Dazu mussten wir nur jeden der drei RGB-Farbkanäle auf den gleichen Wert setzen. Wenn wir neben Weiß auch Gelb und Grün anbieten wollen, müssen wir die Farbkanäle unterschiedlich ansteuern. Für Gelb setzen wir den roten und den grünen Kanal auf den gleichen Wert, während der blaue Kanal auf 0 bleibt. Für Grün setzen wir den grünen Kanal auf den gleichen Wert und die anderen beiden auf 0. Um so eine Logik umzusetzen, haben wir das passende Instrument bereits in unserem Werkzeugkasten: Kontrollstrukturen.\nNehmen wir mal an, wir hätten eine Variable color, auf der die aktuelle Farbe gespeichert ist, in der die LED leuchten soll. Sie könnte also die Werte “white”, “yellow” oder “green” annehmen. Dann könnten wir mit if-Statements die notwendige Logik umsetzen:\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nErinnert euch, dass der Code nach einem if nur dann ausgeführt wird, wenn die vorangegangene Bedingung erfüllt ist. Da die Variable color zu einem Zeitpunkt nur einen der drei Werte annehmen kann, muss genau eine der drei Bedingungen erfüllt sein und alle anderen entsprechend nicht.\nWenn wir jetzt zu Beginn unseres Programms color auf einen der drei Werte setzen, können wir die Logik schnell mal testen:\n\ncolor = \"white\"\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nAlles sollte so sein wie zuvor, die LED leuchtet weiß.\n\ncolor = \"yellow\"\n\nJetzt sollte beim Start des Programms die LED gelb leuchten. Dasselbe probiert mal mit “green” aus, das dürfte auch funktionieren.\n\n\n2.9.2 Farbe per Knopfdruck ändern\nDie aktuelle Farbe in einer Variable zu speichern ist eine gute Idee gewesen. Darauf können wir aufbauen und den Button für den Wechsel der Farbe nutzen. Aber wie?\nZunächst erinnern wir uns an die Logik aus Listing 2.2, in dem wir den Button bereits aus einem Programm heraus getestet haben. Dort haben wir eine Logik gebastelt, die erkennt, wenn der Button gedrückt und wieder losgelassen wird. Wenn das der Fall war, wurde der Wert “Button gedrückt” auf der Konsole ausgegeben. Könnten wir diese Logik nicht verwenden, um statt etwas auszugeben einfach die Farbe zu wechseln?\nNatürlich können wir das. Passen wir den Code entsprechend an:\n\nbutton_pressed_before = False\nwhile True:\n    button_pressed_after = knob.is_pressed()\n\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n    button_pressed_before = button_pressed_after\n\nWieder ein Haufen voller ifs - aber es sollte funktionieren. Gehen wir es einmal durch: Wenn der Button losgelassen wurde (Zeile 5) gelangen wir zur Prüfung der if-Statements. Im ersten Fall wird geprüft, ob die LED gerade Weiß leuchtet (color == \"white\"). Ist das der Fall, dann wechseln wir jetzt auf Gelb. Im zweiten Schritt sehen wir ein elif, das sehr ähnlich zu einem if ist, mit der Einschränkung, dass es nur überhaupt geprüft wird, wenn das vorherige if nicht schon wahr war. Das macht in diesem Fall einen großen Unterschied (im Vergleich zu weiter oben, als wir einfache if-Statements verwendet haben, um die Farbe der LED mit set_rgb_color zu setzen). Überlegt mal, was passieren würde, wenn wir hier folgenden Code einsetzen würden:\n\nif color == \"white\":\n    color = \"yellow\"\nif color == \"yellow\":\n    color = \"green\"\nif color == \"green\":\n    color = \"white\"\n\nGeht das mal im Kopf durch. Wenn color aktuell den Wert white hat, dann wird durch das erste if der Wert auf yellow gesetzt. Anschließend wird das zweite if geprüft, das jetzt wahr ist, und der Wert wird auf green gesetzt. Das dritte if wird dann also ebenfalls wahr sein, und der Wert wird wieder auf white gesetzt. Im Endeffekt haben wir also nichts gewonnen, die LED bliebe weiß. Hier ist die Verwendung von elif entscheidend. Denn ein elif wird nur geprüft, wenn das vorherige if oder elif nicht wahr war. Nach der ersten Anpassung wäre hier also Schluss und die Farbe ist wie gewünscht Gelb.\nFügen wir alles zusammen - die neue Logik zum setzen der Farben basierend auf der Varible colorund die Logik zum Ändern der Variable, sowie die Logik des Dimmers aus Listing 2.1:\n\n\n\n\nListing 2.3: Farbwechsel und Helligkeitsanpassung in einem Programm.\n\n\nbutton_pressed_before = False\n\n# 1. Main loop to keep program running\nwhile True:\n    new_count = knob.get_count(reset=False)\n    button_pressed_after = knob.is_pressed()\n\n    # 2. Logic for color change on button release\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n        # Update LED to reflect new color\n        if color == \"white\":\n            led.set_rgb_value(brightness, brightness, brightness)\n        if color == \"yellow\":\n            led.set_rgb_value(brightness, brightness, 0)\n        if color == \"green\":\n            led.set_rgb_value(0, brightness, 0)\n\n    button_pressed_before = button_pressed_after\n\n    # 3. Logic for brightness adjustment\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        # Update LED to reflect new color\n        if color == \"white\":\n            led.set_rgb_value(brightness, brightness, brightness)\n        if color == \"yellow\":\n            led.set_rgb_value(brightness, brightness, 0)\n        if color == \"green\":\n            led.set_rgb_value(0, brightness, 0)\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n\n\nSchaut euch den Code in Ruhe an und prüft, ob ihr ihn Zeile für Zeile nachvollziehen könnt. An dieser Stelle hat unser Programm schon eine beträchtliche Größe angenommen, und so langsam wird es unübersichtlich. Versuchen wir also, Struktur hineinzubringen. Im Wesentlichen besteht das Programm aus drei Teilen, jeden habe ich mit einem vorangestellten Kommentar markiert:\n\nHauptschleife, um das Programm am Laufen zu halten\nLogik für Farbwechsel bei Tastenfreigabe\nLogik zur Helligkeitsanpassung\n\nIn der Hauptschleife wird am Anfange immer wieder der aktuelle Zählerstand und der Zustand des Buttons abgefragt und auf jeweils einer Variable gespeichert. Diese Werte benötigen wir, um zu entscheiden, ob wir die Farbe ändern oder die Helligkeit anpassen müssen.\nUm einen potenziellen Farbwechsel kümmert sich der zweite Block, der mit dem if button_pressed_before == True ... beginnt. Die Bedingung prüft, ob der Button gerade aus dem gedrückten Zustand in den nicht gedrückten Zustand wechselt, der Benutzer ihn also gerade losgelassen hat. In diesem Moment soll die Farbe gewechselt werden. Die Logik dafür haben wir gerade entwickelt.\nUm die Helligkeitsanpassung kümmert sich dann der dritte und letzte größere Block. Er beginnt mit if new_count != last_count, was prüft, ob der Drehknop betätigt wurde. Wenn ja, dann wird die Helligkeit entsprechend der Differenz angepasst. Diese Logik haben wir in Abschnitt 2.7 zusammen entwickelt.\nWer von euch jetzt ganz genau hinsieht, der erkennt, dass die Blöcke 2 und 3 zum Teil identischen Code ausführen. In der Programmierung ist das eine rote Flagge 🚩! Lasst uns darüber sprechen, warum!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-functions",
    "href": "numbers.html#sec-numbers-functions",
    "title": "2  Zahlen",
    "section": "2.10 Funktionen",
    "text": "2.10 Funktionen\nIn der Programmierung möchten wir Wiederholungen um jeden Preis vermeiden. Wir sprechen auch vom DRY-Prinzip, was für Don’t Repeat Yourself steht. Wenn wir feststellen, dass wir denselben Code an mehreren Stellen verwenden, sollten wir darüber nachdenken, etwas zu verändern. Warum? Und was?\nNehmen wir in unserem Beispiel an, wir führen eine vierte Farbe ein, sagen wir Blau. Dann müssten wir den Code in den Blöcken 2 und 3 anpassen, um die neue Farbe zu berücksichtigen. Das bedeutet, dass wir den gleichen Code an mehreren Stellen ändern müssten, was fehleranfällig und mühsam ist. Zwei mag noch nicht nach einem Problem klingen, aber selbst hier zeigt sich das Problem der Wiederholung. Wird eine Stelle vergessen, ist der Code inkonsistent und funktioniert nicht mehr wie gewünscht.\nDie Lösung liegt darin, häufig verwendeten Code in Funktionen auszulagern. Funktionen sind ein mächtiges Werkzeug in der Programmierung. Sie ermöglichen es uns, Codeblöcke zu definieren, die wir immer wieder verwenden können, ohne sie jedes Mal neu schreiben zu müssen. Funktionen helfen uns dabei, unseren Code sauberer, übersichtlicher und wartbarer zu gestalten.\nIm Listing 2.3 wird dieser Teil an zwei Stellen wiederholt:\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nZeit, diesen Code nur einmal zu schreiben! Machen wir daraus eine Funktion. Wie das geht? Im Prinzip müssen wir vier Dinge klären:\n\nWas soll die Funktion tun?\nWie sieht das Ergebnis aus?\nWas benötigt die Funktion, um ihre Aufgabe zu erledigen?\nWie heisst die Funktion?\n\n\n\n\n\n\n\nAbbildung 2.14: Funktionen folgen einem Eingabe-Verarbeitung-Ausgabe (EVA) Schema.\n\n\n\n\ndef set_led_color(color, brightness):\n    if color == \"white\":\n        led.set_rgb_value(brightness, brightness, brightness)\n    if color == \"yellow\":\n        led.set_rgb_value(brightness, brightness, 0)\n    if color == \"green\":\n        led.set_rgb_value(0, brightness, 0)\n\nIn Listing 2.4 seht ihr den fertigen Code für den Dimmer mit Farbwechsel per Knopfdruck.\n\n\n\n\nListing 2.4: Der fertige Dimmer mit Farbwechsel per Knopfdruck.\n\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nknob = BrickletRotaryEncoderV2('WZd', ipcon) \nled = BrickletRGBLEDV2('ZG1', ipcon)\n\nknob.reset()\nbrightness = 0\nSTEP = 10\nled.set_rgb_value(brightness, brightness, brightness) \nlast_count = 0\n\ncolor = \"white\"\nbutton_pressed_before = False\n\ndef set_led_color(color, brightness):\n    if color == \"white\":\n        led.set_rgb_value(brightness, brightness, brightness)\n    if color == \"yellow\":\n        led.set_rgb_value(brightness, brightness, 0)\n    if color == \"green\":\n        led.set_rgb_value(0, brightness, 0)\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n    button_pressed_after = knob.is_pressed()\n\n    # If button changes from pressed to not pressed\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n        print(f\"Color changed to: {color}\")\n        set_led_color(color, brightness)   \n\n    button_pressed_before = button_pressed_after\n\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n        set_led_color(color, brightness)\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#footnotes",
    "href": "numbers.html#footnotes",
    "title": "2  Zahlen",
    "section": "",
    "text": "Hände hoch, wer daran noch glaubt!↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "3  Texte",
    "section": "",
    "text": "Zusammenfassung\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#zusammenfassung",
    "href": "text.html#zusammenfassung",
    "title": "3  Texte",
    "section": "",
    "text": "Wir lernen, wie Computer Texte darstellen und speichern.\nWir führen ASCII und Unicode als Standards für die Textdarstellung ein.\nWir verstehen Binärcodierung und wie sie im Computer zum Einsatz kommt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#experimentaufbau",
    "href": "text.html#experimentaufbau",
    "title": "3  Texte",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\nFür dieses Kapitel benötigen wir erneut die LED (RGB LED Bricklet 2.0), ersetzen aber den Drehknopf aus Kapitel 2 durch einen Infrarot-Abstandssensor (Distance IR 4-30cm Bricklet 2.0). Beide Geräte schließen wir an den Mikrocontroller (Master Brick 3.2) an und fixieren sie auf einer Montageplatte. Wie in der Abbildung gezeigt, befestigen wir den Abstandssensor mit einem Metallwinkel so, dass er bündig mit der Platte ist und nach vorn zeigt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Draufsicht.\n\n\n\n\n\n\n\n\n\n\n\n(c) Nahaufnahme des IR-Abstandssensors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Seitenansicht, leicht schräg.\n\n\n\n\n\n\n\nAbbildung 3.1: Einfaches Setup mit einem Mikrocontroller, LED und einem Infrarot-Abstandssensor.\n\n\n\n\n\nErste Schritte mit dem Abstandssensor\nWie bei der LED werfen wir zuerst einen Blick auf den neuen Abstandssensor im Brick Viewer. Schließt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Tab Setup sollten nun neben der LED auch der Abstandssensor erscheinen. Denkt daran: Dort findet ihr auch die UID eurer Geräte – die braucht ihr gleich im Programm.\n\n\n\n\n\n\nAbbildung 3.2: Nach erfolgreicher Verbindung erscheint der Infrarot-Entfernungsmesser in der Übersicht des Brick Viewers.\n\n\n\nWechselt in den Tab für den Abstandssensor, wo ihr ihn direkt testen könnt: Ihr seht die aktuelle Entfernung, die der Sensor misst, in Echtzeit oben in der Mitte (in Zentimetern). Darunter zeigt ein Kurvendiagramm den zeitlichen Verlauf. Bewegt eure Hand vor dem Sensor, um ein Gefühl für sein Verhalten zu bekommen. Was passiert, wenn ihr sehr nah vor dem Sensor seid? Und was, wenn ihr eure Hand weiter weg bewegt?\n\n\n\n\n\n\nAbbildung 3.3: Der Brick Viewer zeigt die aktuelle Entfernung im Zeitverlauf an.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#lichtschranke",
    "href": "text.html#lichtschranke",
    "title": "3  Texte",
    "section": "3.1 Lichtschranke",
    "text": "3.1 Lichtschranke\nEinen Infrarot-Abstandssensor verwenden wir in der Praxis zur berührungslosen Messung des Abstands zu einem Objekt. Der Sensor sendet einen unsichtbaren Infrarotlichtstrahl aus und misst das Licht, das vom Objekt zurückgeworfen wird. Anhand der Intensität oder des Winkels des zurückkehrenden Lichts berechnet der Sensor die Entfernung. Diese Sensoren sind aus der Praxis nicht wegzudenken und kommen in vielen Szenarien zum Einsatz, zum Beispiel:\n\nObjekterkennung an einem Fließband\nFüllstandsmessung in Behältern\nHinderniserkennung für Roboter, etwa bei Staubsaugerrobotern\nPositionierung von Werkstücken in Maschinen\nEinparkhilfe beim Auto\n\nLetztlich lassen sich alle Anwendungsfälle auf zwei Fragen reduzieren:\n\nBefindet sich ein Objekt in der Sicht des Sensors?\nWie weit ist ein Objekt vom Abstandssensor entfernt?\n\nWir starten mit der einfacheren der beiden Fragen: Befindet sich ein Objekt in der Sicht des Sensors? Das beschreibt im Kern die Funktion einer Lichtschranke.\nWie ihr beim Ausprobieren im Brick Viewer festgestellt habt, misst der Sensor Entfernungen zwischen 4 und 30 cm. Das bedeutet: Objekte außerhalb dieses Bereichs werden nicht erkannt – weder näher als 4 cm noch weiter als 30 cm. Eine Lichtschranke hat somit die Aufgabe zu prüfen, ob der IR-Abstandssensor einen Wert kleiner als 30 cm misst. Dann befindet sich ein Objekt in seiner Sichtlinie.\nVerbinden wir uns mit dem Sensor und schreiben das notwendige Grundgerüst. Tragt eure UIDs ein und legt beide Bricklets an, Sensor und LED:\n\n\n\n\nListing 3.1: Boilerplate-Code für IR-Abstandssensor und RGB-LED\n\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\nimport time\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\n\n1ir = BrickletDistanceIRV2('2a7S', ipcon)\n2led = BrickletRGBLEDV2('ZEL', ipcon)\n\n\n\n\n\n1\n\nTragt hier die UID eures IR-Sensors ein.\n\n2\n\nTragt hier die UID eurer RGB-LED ein.\n\n\n\n\nDer Sensor ist danach in der Variablen ir gespeichert. Über sie können wir seine Funktionen aufrufen. Eine davon erlaubt uns das Auslesen des aktuell gemessenen Werts:\n\ndistance = ir.get_distance()\n\nEin Blick in die Dokumentation verrät, dass der Rückgabewert in Millimetern angegeben wird. Ein Wert an der oberen Grenze (rund 300 mm) signalisiert typischerweise, dass sich kein Objekt innerhalb der Reichweite befindet. Damit wir besser testen können, lesen wir den Wert kontinuierlich aus und schreiben ihn auf die Konsole:\n\nwhile True:\n    distance = ir.get_distance()\n    print(f\"Aktuelle Entfernung: {distance} mm\")\n\nIhr werdet sehen, dass wir sehr viele Ausgaben erzeugen, weil in jedem Schleifendurchlauf der Wert ausgegeben wird – auch wenn er sich nicht verändert hat. Geben wir erneut nur die Veränderungen aus, um die Ausgaben zu reduzieren:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if distance != last_distance:\n        print(f\"Aktuelle Entfernung: {distance} mm\")\n        last_distance = distance\n\nIhr erinnert euch: Dasselbe Prinzip haben wir in Abschnitt 2.7 verwendet, um nur bei einer Änderung des Drehknopfs eine Ausgabe zu erzeugen. Wir merken uns den letzten Wert und vergleichen ihn mit dem aktuell gemessenen. Ist er gleich, passiert nichts. Hat er sich verändert (distance != last_distance), geben wir den neuen Wert aus und aktualisieren den letzten Wert (last_distance = distance).\nWir sind unserem Etappenziel einer Lichtschranke schon sehr nah. Anhand der Ausgabe könnten wir entscheiden, ob ein Objekt in der Sicht des Sensors ist oder nicht. Das soll aber unser Programm automatisch erledigen. Dazu fügen wir eine weitere Bedingung mit einer if-Anweisung hinzu:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &lt; 300:\n            print(f\"Objekt erkannt: {distance} mm\")\n        else:\n            print(\"Kein Objekt in Reichweite\")\n    \n        last_distance = distance\n\nDie neue if-Anweisung prüft, ob der Abstand kleiner als 300 mm ist. Dann befindet sich etwas vor dem Sensor. In diesem Fall geben wir einen entsprechenden Hinweis aus. Andernfalls kommt der Hinweis „Kein Objekt in Reichweite“. Diesen anderen Fall bildet der optionale else-Teil ab. Code hinter else wird immer dann ausgeführt, wenn keine der vorher definierten Bedingungen über if oder elif zutrifft.\nDamit unsere Lichtschranke auch ohne Blick auf die Konsole funktioniert, bringen wir im letzten Schritt die LED ins Spiel. Sie soll rot aufleuchten, wenn ein Objekt erkannt wird. Die LED haben wir bereits kennengelernt, den Code können wir übernehmen:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &lt; 300:\n            print(f\"Objekt erkannt: {distance} mm\")\n1            led.set_rgb_value(255, 0, 0)\n        else:\n            print(\"Kein Objekt in Reichweite\")\n2            led.set_rgb_value(0, 0, 0)\n    \n        last_distance = distance\n\n\n1\n\nDie LED leuchtet rot, wenn ein Objekt erkannt wird.\n\n2\n\nDie LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.\n\n\n\n\nProbiert es aus – die Lichtschranke sollte funktionieren und Objekte innerhalb von 30 cm zuverlässig erkennen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#hinderniserkennung",
    "href": "text.html#hinderniserkennung",
    "title": "3  Texte",
    "section": "3.2 Hinderniserkennung",
    "text": "3.2 Hinderniserkennung\nDie Lichtschranke leuchtet immer rot, sobald ein Objekt erkannt wird. Dabei spielt die Entfernung keine Rolle. Lasst uns die Idee zu einer Hinderniserkennung für einen hypothetischen Staubsaugerroboter erweitern. Die LED soll anzeigen, ob sich ein Objekt bereits nahe am Roboter befindet oder ob es noch weit genug entfernt ist.\nNehmen wir an, dass Objekte, die 17 cm oder näher am Roboter sind, als Gefahr gelten. Alles, was zwischen 17 und 30 cm Abstand hält, sieht der Roboter nicht als bedrohlich an. Die drei Zustände wollen wir über die Farbe der LED abbilden:\n\nGelb: Objekt in mittlerer Entfernung erkannt (17 cm &lt; Abstand &lt; 30 cm)\nRot: Nahes Objekt erkannt (&lt;= 17 cm)\nAus: Kein Objekt vor dem Sensor (&gt;= 30 cm)\n\nWir können dazu den Code der Lichtschranke erweitern:\n\n\n\n\nListing 3.2: Der Code für die zweistufige Hinderniserkennung.\n\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &gt; 170 and distance &lt; 300:\n1            led.set_rgb_value(255, 255, 0)\n        elif distance &lt;= 170:\n2            led.set_rgb_value(255, 0, 0)\n        else:\n3            led.set_rgb_value(0, 0, 0)\n    \n        last_distance = distance\n\n\n\n\n\n1\n\nDie LED leuchtet gelb, wenn ein Objekt in mittlerer Entfernung erkannt wird.\n\n2\n\nDie LED leuchtet rot, wenn ein Objekt in naher Entfernung erkannt wird.\n\n3\n\nDie LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.\n\n\n\n\nIhr erinnert euch an die additive Farbmischung aus Abbildung 1.6 (a)? Gelb entsteht durch die Kombination von Rot und Grün. Wir verwenden hier eine elif-Anweisung, die eine weitere Bedingung prüft, wenn die vorherige if-Bedingung nicht zutrifft. So können wir mehrere Bedingungen hintereinander prüfen. Der letzte else-Teil fängt alle Fälle ab, in denen kein Objekt erkannt wurde.\nUnser Staubsaugerroboter könnte den Code oben verwenden, um Hindernisse zu erkennen und bei zu großer Nähe ein Ausweichmanöver zu starten.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#universelles-eingabegerät",
    "href": "text.html#universelles-eingabegerät",
    "title": "3  Texte",
    "section": "3.3 Universelles Eingabegerät",
    "text": "3.3 Universelles Eingabegerät\nEine andere Möglichkeit, den Abstandssensor und den Code aus Listing 3.2 zu verwenden, ist ein Eingabegerät für Informationen in unseren Computer. Wie soll ein Abstandssensor als Eingabegerät für Informationen fungieren?\nWie wir später noch sehen werden, benötigen wir für die Darstellung von Informationen unterschiedliche Zustände – mindestens zwei. Genau das verkörpert das Bit, das wir in Abschnitt 2.6 kennengelernt haben: Ein Bit hat zwei Zustände, an oder aus, 0 oder 1.\nWas wäre, wenn wir die beiden Bereiche „nah“ und „weit genug entfernt“ nicht länger als Entfernungen interpretieren, sondern einfach als zwei Zustände? Sagen wir, der Bereich „weit genug entfernt“ steht für die 1 und der Bereich „nah“ für die 0. Dann könnten wir über die bewusste Platzierung eines soliden Gegenstands und anschließende Messung der Entfernung den Zustand eines Bits kodieren:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &gt; 170 and distance &lt; 300:\n            print(\"1\")\n        elif distance &lt;= 170:\n            print(\"0\")\n    \n        last_distance = distance\n\nWenn ihr den Code ausführt, werdet ihr ein Problem erkennen: Platzieren wir unsere Hand nahe am Sensor, um eine 0 zu kodieren, gibt das Programm nacheinander sehr viele Nullen aus. Dasselbe gilt für Einsen. Dabei wollen wir mit einer Handgeste jeweils nur eine 1 oder 0 übermitteln, nicht eine ganze Reihe. Das liegt daran, dass sich unsere Hand minimal bewegt – ein Millimeter reicht.\nWir müssen unser Programm so anpassen, dass es nicht erneut auf eine Änderung reagiert, solange die Hand nicht wieder weggenommen wurde. Das erkennen wir daran, dass der Sensor die maximale Entfernung von 30 cm misst. Erst wenn dieses Ereignis wieder auftritt, soll ein neuer Zustand kodiert werden.\nEine Lösung besteht darin, dass wir uns merken, ob unser Eingabegerät aktuell empfangsbereit ist oder nicht. Wir führen dafür die Variable receiving ein, die den Zustand unseres Eingabegeräts beschreibt. Ist sie True, ist das Gerät bereit, eine Eingabe zu empfangen. Ist sie False, ignorieren wir alle Änderungen, bis die Hand wieder weggenommen wurde.\n\nlast_distance = 0\nreceiving = False\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        \n1        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(f\"1 bei {distance} mm\")\n                receiving = False\n            elif distance &lt;= 170:\n                print(f\"0 bei {distance} mm\")\n                receiving = False\n2        else:\n            if distance &gt;= 300:\n3                receiving = True\n                print(\"Bereit für den nächsten Code\")\n\n        last_distance = distance\n\n\n1\n\nNur im Empfangsmodus wird anhand der Entfernung ein Bit kodiert.\n\n2\n\nWenn wir nicht im Empfangsmodus sind, prüfen wir, ob die Hand wieder weggenommen wurde (&gt;= 30 cm).\n\n3\n\nWenn die Hand weg ist, schalten wir wieder in den Empfangsmodus.\n\n\n\n\nDas sieht schon gut aus. Probiert aber einmal aus, eure Hand sehr langsam von oben nach unten vor den Sensor zu bewegen, und zwar im nahen Bereich, sodass eigentlich eine 0 kodiert werden sollte. In manchen Fällen erkennt das Programm fälschlicherweise eine 1 statt der 0. Warum ist das so? Der Sensor hat bei der Messung eine leichte zeitliche Verzögerung. Wenn er aktuell 30 cm Abstand misst und wir unsere Hand langsam nach unten bewegen, misst der Sensor zunächst einen Abstand knapp unter 30 cm. Das Programm reagiert sofort und kodiert eine 1, obwohl wenig später der Sensorwert in den Bereich der 0 kommt (zum Beispiel 8 cm).\nWir können das Problem umgehen, indem wir einen kleinen Verzug einbauen, sobald ein Unterschied erkannt wurde. Nach diesem zeitlichen Verzug messen wir erneut, um sicherzugehen, die korrekte Position der Hand zu erwischen. So könnte das im Code aussehen:\n\nlast_distance = 0\nreceiving = False\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        # 100 ms warten und erneut messen\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(f\"1 bei {distance} mm\")\n                receiving = False\n            elif distance &lt;= 170:\n                print(f\"0 bei {distance} mm\")\n                receiving = False\n        else:\n            if distance &gt;= 300:\n                receiving = True\n                print(\"Bereit für den nächsten Code\")\n\n        last_distance = distance\n\nTestet es jetzt: Unser Eingabegerät erkennt die Zustände 0 und 1 zuverlässig.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#texte-kodieren",
    "href": "text.html#texte-kodieren",
    "title": "3  Texte",
    "section": "3.4 Texte kodieren",
    "text": "3.4 Texte kodieren\nKönnen wir unser universelles Eingabegerät dazu verwenden, dem Computer Texte zu diktieren? Schließlich bedeutet „universell“, dass es für viele Zwecke einsetzbar ist. Und die Antwort lautet: ja! Wenn wir ein Gerät entwickeln, mit dem wir Bits kodieren können, können wir damit alles eingeben, was ein Computer darstellen kann.\nIn Kapitel 2 haben wir gesehen, wie wir mit 8 Bits den Wert einer der drei Grundfarben im RGB-Code darstellen können. Wenn wir unser Eingabegerät einsetzen, um hintereinander 24 Bits zu übermitteln und diese als einen RGB-Farbcode zu interpretieren, könnten wir damit unsere LED in einer beliebigen Farbe aufleuchten lassen. Das versuchen wir später. Jetzt kümmern wir uns um eine ebenso wichtige Form der Information: Texte.\nTexte bestehen allgemein aus Zeichen. Die meisten Zeichen in Texten sind Buchstaben, die wir in Klein- und Großbuchstaben unterscheiden. Dazu kommen Zahlen und Satzzeichen. Schaut auf das Keyboard eures Computers – dort findet ihr die meisten Zeichen, die ihr für Texte benötigt.\n\n3.4.1 Wie viele Bits benötigen wir?\nGenau wie bei den Farben, für die wir 24 Bits benötigen (jeweils 8 pro Farbe im RGB-Code), stellt sich bei Texten die Frage, wie viele Bits wir benötigen, um ein Zeichen darzustellen. Die Antwort hängt von der Anzahl der benötigten Zeichen ab.\nNähern wir uns von der anderen Seite und erweitern unseren Zeichencode Bit für Bit. Wir beginnen klein und fangen mit einem Bit an. Wenn wir Bits als Text interpretieren, wie viele Zeichen (oder Buchstaben) können wir dann mit einem einzigen Bit darstellen? Richtig: zwei!\n\nlast_distance = 0\nreceiving = False\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        # 100 ms warten und erneut messen\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"B\")\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"A\")\n                receiving = False\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\nLasst das Programm laufen und legt eure Hand einmal nahe vor den Sensor, dann zweimal weiter weg und wieder nah. Das habt ihr gerade geschrieben: „ABBA“.\nNeben der bekannten schwedischen Band lassen sich mit den Buchstaben A und B jedoch nicht viele andere Wörter bilden. Wir sind also gut beraten, mindestens ein zweites Bit hinzuzunehmen. Die Anzahl Bits, die wir für einen Buchstaben benötigen, erhöht sich damit auf zwei. Wie bilden wir das im Programm ab?\nAm einfachsten, indem wir uns die Bits zunächst merken, sie also hintereinander in eine Zeichenkette schreiben. Sobald eine vorher definierte Länge einer Nachricht – hier zunächst zwei Bits – erreicht ist, dekodieren wir die Bitfolge und erhalten den passenden Buchstaben. Danach geht es wieder von vorn los und unsere Bit-Zeichenkette ist wieder leer.\n\n1MESSAGE_LENGTH = 2\n2bits = \"\"\n3text = \"\"\nlast_distance = 0\nreceiving = False\n\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"1\")\n4                bits += \"1\"\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"0\")\n5                bits += \"0\"\n                receiving = False\n\n6            if len(bits) == MESSAGE_LENGTH:\n                print(f\"Bits: {bits}\")\n7                letter = decode_letter(bits)\n                print(f\"Buchstabe: {letter}\")\n8                text += letter\n                print(f\"Text: {text}\")\n9                bits = \"\"\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\n\n1\n\nDie Länge einer Nachricht. So viele Bits müssen wir sammeln, bis wir die Nachricht entschlüsseln können.\n\n2\n\nWir erstellen eine leere Zeichenkette bits, in der wir jedes empfangene Bit speichern.\n\n3\n\ntext sammelt die dekodierten Buchstaben zu einem Text.\n\n4\n\nWir merken uns das Bit, indem wir es an das Ende von bits hinzufügen – hier eine „1“.\n\n5\n\nDasselbe für eine „0“.\n\n6\n\nWenn wir genug Bits zusammen haben, dekodieren wir die Bitfolge.\n\n7\n\ndecode_letter(bits) wandelt die Bitfolge in einen Buchstaben um. Die Funktion implementieren wir gleich.\n\n8\n\nWir fügen den Buchstaben dem bisherigen Text an.\n\n9\n\nDanach setzen wir die Bit-Zeichenkette zurück.\n\n\n\n\nDirekt nach dem Start wartet das Programm darauf, dass ihr eure Hand vor den Sensor haltet. Jede erkannte Änderung wird nach 100 Millisekunden noch einmal gemessen, um den Wert zu stabilisieren. Befinden wir uns im Empfangsmodus (receiving ist True), schreiben wir je nach Abstand eine „1“ (weit) oder „0“ (nah) ans Ende der Zeichenkette bits und schalten den Empfang vorübergehend aus. Sobald die Länge von bits der erwarteten MESSAGE_LENGTH entspricht, rufen wir decode_letter(bits) auf, erhalten den passenden Buchstaben, hängen ihn an text an und leeren bits. Erst wenn der Sensor wieder mindestens 30 cm misst, schalten wir den Empfang erneut frei, damit die nächste Eingabe beginnen kann.\nOkay – probieren wir es aus. Unser Programm sammelt das erste Bit, dann das zweite und dann…\nNameError: name 'decode_letter' is not defined\nWas ist das? Eine Fehlermeldung, die uns sagt: Die Funktion decode_letter() ist nicht definiert. Wir müssen sie also noch implementieren. Wir haben die Funktion zwar schon namentlich genannt, aber es gibt nirgends eine Definition. Das holen wir jetzt nach.\nErinnert euch an Abschnitt 2.10: Wir müssen wissen, was die Funktion tun soll, was sie dafür benötigt und was sie zurückgibt. Einen Namen haben wir bereits: decode_letter.\nDie Funktion soll unsere Zeichenkette voller Bits der Länge zwei, also so etwas wie “00”, “01”, “10” oder “11”, in einen Buchstaben umwandeln. Die Eingabe ist bits und die Ausgabe ein Buchstabe, den diese Bitfolge kodiert. Unsere Funktion könnte so aussehen:\n\ndef decode_letter(bits):\n    if bits == \"00\":\n        return \"A\"\n    elif bits == \"01\":\n        return \"B\"\n    elif bits == \"10\":\n        return \"C\"\n    elif bits == \"11\":\n        return \"D\"\n\nMit einem if-Statement, begleitet von drei elif-Zweigen, prüfen wir, welchem der möglichen Werte die Zeichenkette bits entspricht, und geben einen Buchstaben A, B, C oder D zurück. Da es mit zwei Bits insgesamt vier Möglichkeiten gibt, können wir auch nur vier Buchstaben damit abbilden. Wir erweitern das weiter unten, damit wir alle Buchstaben des Alphabets abdecken können.\n\nUnser aktuelles Codesystem für vier Buchstaben.\n\n\nBitfolge\nDezimalzahl\nBuchstabe\n\n\n\n\n00\n0\nA\n\n\n01\n1\nB\n\n\n10\n2\nC\n\n\n11\n3\nD\n\n\n\nDie Tabelle fasst unser Codesystem zusammen. In der zweiten Spalte haben wir zur Bitfolge die entsprechende Dezimalzahl eingetragen. Erinnert euch: Das Binärsystem ist ein Stellenwertsystem wie jedes andere auch, nur eben zur Basis 2. Wie ihr die entsprechende Dezimalzahl zu einer Binärzahl errechnet, haben wir in Abschnitt 2.5.3 gelernt.\nFügen wir die Funktion in unser Programm ein. Wichtig ist: Eine Funktion muss vor ihrer Verwendung definiert sein.\n\n\nCode\nMESSAGE_LENGTH = 2\nbits = \"\"\ntext = \"\"\nlast_distance = 0\nreceiving = False\n\ndef decode_letter(bits):\n    if bits == \"00\":\n        return \"A\"\n    elif bits == \"01\":\n        return \"B\"\n    elif bits == \"10\":\n        return \"C\"\n    elif bits == \"11\":\n        return \"D\"\n\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"1\")\n                bits += \"1\"\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"0\")\n                bits += \"0\"\n                receiving = False\n\n            if len(bits) == MESSAGE_LENGTH: \n                print(f\"Bits: {bits}\")\n                letter = decode_letter(bits)\n                print(f\"Buchstabe: {letter}\")\n                text += letter\n                print(f\"Text: {text}\")\n                bits = \"\"\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\n\nCool, neben „ABBA“ können wir jetzt auch „ADAC“ schreiben. Wir wollen aber natürlich noch mehr, und bevor wir Bit für Bit hinzufügen, überlegen wir, wie viele Bits wir eigentlich benötigen.\nEs gibt 26 Buchstaben im Alphabet, und vielleicht wollen wir auch ein Leerzeichen kodieren. Die Unterscheidung zwischen Klein- und Großbuchstaben lassen wir an dieser Stelle einmal weg – sie wäre aber für ein praxistaugliches Codesystem wichtig. Somit sind es 27 Zeichen, die wir kodieren wollen. Mit jedem zusätzlichen Bit verdoppeln wir unsere Möglichkeiten, das haben wir in Abschnitt 2.6 gelernt. Rufen wir uns noch einmal die Tabelle in den Sinn, um zu erkennen, wie viele Bits wir benötigen.\n\nAnzahl Bits und mögliche Kodierungen.\n\n\nAnzahl Bits\nMögliche Kodierungen\n\n\n\n\n1\n\\(2^1 = 2\\)\n\n\n2\n\\(2^2 = 4\\)\n\n\n3\n\\(2^3 = 8\\)\n\n\n4\n\\(2^4 = 16\\)\n\n\n5\n\\(2^5 = 32\\)\n\n\n6\n\\(2^6 = 64\\)\n\n\n7\n\\(2^7 = 128\\)\n\n\n8\n\\(2^8 = 256\\)\n\n\n\nDemnach reichen uns fünf Bits aus, denn damit können wir insgesamt 32 Kodierungen vornehmen. Wir hätten somit noch fünf freie Plätze, die wir vielleicht für Satzzeichen wie Punkt oder Komma verwenden.\nUm das in unserem Programm zu reflektieren, müssen wir die Funktion decode_letter anpassen und gleichzeitig die Länge einer Nachricht auf 5 Bits erhöhen. Damit wir es etwas einfacher haben und die Buchstaben den Dezimalzahlen von 0–25 zuordnen können, wandeln wir die Bitfolge zuerst in eine Dezimalzahl um:\n\ndef decode_letter(bits):\n    \n    # In Dezimalzahl umwandeln\n1    decimal = int(bits, 2)\n\n    if decimal == 0:\n        return \"A\"\n    elif decimal == 1:\n        return \"B\"\n    elif decimal == 2:\n        return \"C\"\n    elif decimal == 3:\n        return \"D\"\n    elif decimal == 4:\n        return \"E\"\n    ...\n    elif decimal == 25:\n        return \"Z\"\n    else:\n        return \"?\"\n\n\n1\n\nDie Funktion int wandelt die Bitfolge in eine Dezimalzahl um. Der erste Parameter ist die Bitfolge als String, der zweite die Basis (hier 2 für Binärzahlen).\n\n\n\n\nFür die Umwandlung der Bitfolge verwenden wir die Funktion int(), die uns später noch öfter begegnen wird. Sie wandelt Zeichenketten in ganze Zahlen um, und wenn wir als zweiten Parameter die Basis des Zahlensystems angeben, funktioniert das auch mit Binärzahlen.\nDie Lösung funktioniert, allerdings ist sie nicht besonders elegant. Wir müssen für jeden Buchstaben einen eigenen if/elif-Zweig schreiben, was schnell unübersichtlich wird. Zudem wird unser Code extrem lang – im Codeblock oben deutet ... bereits an, dass es noch viele weitere Buchstaben zwischen E und Z gibt. Glücklicherweise geht das eleganter, und zwar mit einem Wörterbuch.\n\n\n3.4.2 Wörterbücher\nEin Dictionary (deutsch: Wörterbuch) ist in der Programmierung eine Sammlung von Schlüssel-Wert-Paaren. Über einen Schlüssel – zum Beispiel eine Zahl – greifen wir direkt auf den zugehörigen Wert zu, etwa einen Buchstaben. Stellt euch das wie ein Telefonbuch vor, bei dem ihr über den Namen die Nummer herausfindet. Das ist ideal, wenn wir Bitfolgen zuerst in Dezimalzahlen umwandeln und dann schnell den passenden Buchstaben nachschlagen möchten. Statt viele if/elif-Zweige zu schreiben, legen wir einmalig eine Nachschlagetabelle an. Das macht den Code kürzer, übersichtlicher und leichter erweiterbar.\nFür unsere Zeichendekodierung können wir ein Dictionary nutzen, das die Dezimalwerte 0–25 auf „A“–„Z“ abbildet und zum Beispiel 26 als Leerzeichen reserviert. Damit wird decode_letter deutlich kompakter und leichter zu pflegen.\n\n# Nachricht auf 5 Bits erweitern\nMESSAGE_LENGTH = 5\n\n# Dictionary mit 0–25 =&gt; A–Z und 26 =&gt; Leerzeichen\n1SYMBOLS = {}\n2SYMBOLS[0] = \"A\"\nSYMBOLS[1] = \"B\"\nSYMBOLS[2] = \"C\"\nSYMBOLS[3] = \"D\"\nSYMBOLS[4] = \"E\"\n...\nSYMBOLS[25] = \"Z\"\nSYMBOLS[26] = \" \"\n\ndef decode_letter(bits):\n    decimal = int(bits, 2)\n    return SYMBOLS.get(decimal, \"?\")\n\n\n1\n\nMit geschweiften Klammern erzeugen wir ein leeres Dictionary.\n\n2\n\nMit den eckigen Klammern können wir einem Schlüssel einen Wert zuweisen. Wenn es den Eintrag nicht gibt, wird er neu angelegt. Andernfalls wird er überschrieben.\n\n\n\n\nWenn ihr später weitere Zeichen (z. B. Punkt oder Komma) ergänzen wollt, könnt ihr sie einfach hinzufügen:\n\nSYMBOLS[27] = \",\"\nSYMBOLS[28] = \".\"\n\nWie ihr an der Schreibweise von SYMBOLS erkennen könnt, handelt es sich um eine Konstante. Logisch, schließlich verändert sich unser Codesystem für die Symbole im Verlauf des Programms nicht. Wir initialisieren ein leeres Dictionary mit geschweiften Klammern (Zeile 5). Die Zuweisung der Werte erfolgt dann über die eckigen Klammern, wobei in den eckigen Klammern der Schlüssel (englisch: Key) steht und der Wert, den wir dem Schlüssel zuweisen möchten, hinter dem Gleichheitszeichen folgt.\nPrinzipiell könnten wir mit den eckigen Klammern auch Werte abfragen. Wenn wir zum Beispiel SYMBOLS[0] schreiben, erhalten wir den Wert “A” zurück. Wenn wir einen Schlüssel abfragen, der nicht existiert, bekommen wir jedoch einen Fehler. Eine bessere Möglichkeit zum Abfragen von Werten bietet daher die get()-Methode. Sie liefert den Wert für den Schlüssel zurück, den wir als erstes Argument übergeben. Wenn dieser Schlüssel nicht existiert, bekommen wir den Wert None zurück, was robuster ist, als wenn das Programm mit einem Fehler abbräche. Zudem können wir als zweites Argument einen Standardwert angeben, der zurückgegeben wird, wenn der Schlüssel nicht existiert. In unserem Fall ist das ein Fragezeichen “?”, das signalisiert, dass die Bitfolge keinem bekannten Buchstaben zugeordnet werden kann.\nÜberprüft euch selbst: Welcher Wert kommt bei folgendem Aufruf zurück?: SYMBOLS.get(5)\n\n\n\n\nListing 3.3: Der vollständige Code für die Texteingabe mit dem Infrarot-Abstandssensor.\n\n\n\nCode\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\nimport time\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\n\nir = BrickletDistanceIRV2('2a7S', ipcon)\nled = BrickletRGBLEDV2('ZEL', ipcon)\n\nMESSAGE_LENGTH = 5 # Anzahl Bits pro Buchstabe\nbits = \"\"\ntext = \"\"\nlast_distance = 0\nreceiving = False\n\n# Dictionary mit 0–25 =&gt; A–Z und 26 =&gt; Leerzeichen\nSYMBOLS = {}\nSYMBOLS[0] = \"A\"\nSYMBOLS[1] = \"B\"\nSYMBOLS[2] = \"C\"\nSYMBOLS[3] = \"D\"\nSYMBOLS[4] = \"E\"\nSYMBOLS[5] = \"F\"\nSYMBOLS[6] = \"G\"\nSYMBOLS[7] = \"H\"\nSYMBOLS[8] = \"I\"\nSYMBOLS[9] = \"J\"\nSYMBOLS[10] = \"K\"\nSYMBOLS[11] = \"L\"\nSYMBOLS[12] = \"M\"\nSYMBOLS[13] = \"N\"\nSYMBOLS[14] = \"O\"\nSYMBOLS[15] = \"P\"\nSYMBOLS[16] = \"Q\"\nSYMBOLS[17] = \"R\"\nSYMBOLS[18] = \"S\"\nSYMBOLS[19] = \"T\"\nSYMBOLS[20] = \"U\"\nSYMBOLS[21] = \"V\"\nSYMBOLS[22] = \"W\"\nSYMBOLS[23] = \"X\"\nSYMBOLS[24] = \"Y\"\nSYMBOLS[25] = \"Z\"\nSYMBOLS[26] = \" \"\n\ndef decode_letter(bits):\n    decimal = int(bits, 2)\n    return SYMBOLS.get(decimal, \"?\")\n\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"1\")\n                bits += \"1\"\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"0\")\n                bits += \"0\"\n                receiving = False\n\n            if len(bits) == MESSAGE_LENGTH: \n                print(f\"Bits: {bits}\")\n                letter = decode_letter(bits)\n\n                print(f\"Buchstabe: {letter}\")\n                text += letter\n                \n                print(f\"Text: {text}\")\n                bits = \"\"\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.\nKlont das Repository und öffnet den Ordner in eurem Visual Studio Code, um es schnell ausführen zu können.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#ascii-code",
    "href": "text.html#ascii-code",
    "title": "3  Texte",
    "section": "3.5 ASCII-Code",
    "text": "3.5 ASCII-Code\nIm vorigen Abschnitt haben wir zusammen überlegt, wie wir Texte kodieren und als Bitfolge über ein universelles Eingabegerät basierend auf einem IR-Abstandssensor übertragen können. Ziemlich cool, findet ihr nicht? Dabei haben wir jedem Buchstaben eine eindeutige Bitfolge zugewiesen und sind letztlich auf unser eigenes 5-Bit-Kodierungssystem gekommen.\nWeil eine der ersten Anwendungen mit dem Computer die Verarbeitung von Texten war, haben sich darüber, wie man Texte kodieren kann, schon andere sehr schlaue Leute Gedanken gemacht. Das Ergebnis ist der ASCII-Code, den es seit den 1960er-Jahren gibt und der weltweit standardisiert ist.\nDer ASCII-Code basiert auf sieben Bits und kann somit 128 verschiedene Symbole verwalten. Die vollständige Liste an Symbolen seht ihr in Abbildung 3.4. Die Tabelle enthält fünf Spalten, wobei die ersten vier den Zahlencode für das kodierte ASCII-Zeichen in unterschiedlichen Zahlensystemen angeben. Ganz links seht ihr die Dezimalzahl, daneben die Binärdarstellung. Zusätzlich wird noch die Oktalzahl und die Hexadezimalschreibweise mit angezeigt. Oktal kennen wir bereits, was es mit Hexadezimal auf sich hat, lernen wir später in Kapitel 4.\nWenn ihr genau hinseht, erkennt ihr, dass die Binärzahl nicht aus 7, sondern aus 8 Bits besteht. Die erste Ziffer ganz links ist aber immer 0. Das liegt daran, dass Computer häufig in 8-Bit-Einheiten – also in Bytes – denken. Auch der Speicher eines Computers ist so organisiert. Deshalb benötigt ein ASCII-Symbol in der Praxis statt sieben, acht Bits auf unserem Computer.\nWas passiert mit dem vermeintlich „verschwendeten“ Bit? Damit könnten wir doch immerhin 128 weitere Symbole abbilden. Und das wird auch gemacht: Es gibt verschiedene lokale Erweiterungen des ASCII-Codes, die zusätzliche Zeichen definieren. Für den deutschen Sprachraum etwa die Umlaute ä, ö, ü und das scharfe S (ß). Für andere Sprachen gibt es ähnliche Erweiterungen. Wir nennen diese Erweiterungen auch Codepages.\nDie Codepage, die wir üblicherweise verwenden, nennt sich Windows-1252 (CP-1252) und ist eine Erweiterung des ASCII-Codes, die 256 Zeichen umfasst. Die ersten 128 Zeichen sind identisch mit dem ASCII-Code, die weiteren 128 enthalten zusätzliche Zeichen, die in westeuropäischen Sprachen benötigt werden.\n\n\n\n\n\n\nAbbildung 3.4: Die ursprüngliche ASCII-Codetabelle kodiert die Symbole als 7-Bit-Binärzahlen\n\n\n\nDer ASCII-Code – das steht für American Standard Code for Information Interchange – beinhaltet ein paar nette Eigenschaften. So können wir zum Beispiel einen Großbuchstaben in einen Kleinbuchstaben umwandeln, indem wir 32 zu seinem Dezimalcode addieren. Umgekehrt funktioniert das natürlich auch.\nFür unsere Texteingabe über den IR-Abstandssensor bedeutet das: Wir benötigen überhaupt keinen eigenen Code, sondern können einfach den ASCII-Code verwenden. Allerdings müssen wir unsere Nachricht auf die Länge 7 erweitern, was mehr Aufwand bei der Eingabe macht. Dafür verwenden wir einen Standard. Argument genug – passen wir den Code an.\nDie Änderungen finden im Wesentlichen in der Funktion decode_letter() statt. Zudem ändern wir den Wert der Konstante MESSAGE_LENGTH:\n\nMESSAGE_LENGTH = 7 # Anzahl Bits pro Buchstabe\n\n...\n\ndef decode_letter(bits):\n    # Links eine 0 hinzufügen, damit es 8 Bits sind\n    bits = \"0\" + bits\n\n    # Binärstring in Dezimalzahl und dann in ASCII-Zeichen umwandeln\n    decimal = int(bits, 2)\n    return chr(decimal)\n\nDie decode_letter()-Funktion fügt nun zunächst dem übergebenen Bit-String, der aus 7 Bits bestehen sollte, eine 0 an den Anfang hinzu. Damit haben wir die 8 Bits aus der ASCII-Tabelle in Abbildung 3.4 komplettiert. Anschließend erfolgt – wie zuvor – die Konvertierung von binär nach dezimal. Die wesentliche Änderung steht in der Zeile darunter: Wir geben das Ergebnis der Funktion chr() zurück, der wir den Dezimalwert unseres kodierten Symbols übergeben. Brauchen wir also kein Dictionary mehr?\nGanz genau! Es gibt bereits eine Funktion, die die passenden Symbole für Codes liefern kann. Wenn wir in die offizielle Dokumentation der Funktion chr() schauen, dann steht dort:\n\nReturn the string representing a character with the specified Unicode code point. For example, chr(97) returns the string ‘a’, while chr(8364) returns the string ‘€’. This is the inverse of ord().\n\nDie Funktion gibt also die Repräsentation des Codes als Zeichen zurück. Aber was steht da? Mit dem angegebenen Unicode-Codepunkt? Was ist denn jetzt schon wieder Unicode? Wir haben doch gerade über ASCII gesprochen.\n\n3.5.1 Unicode\nUnicode ist ein internationaler Standard, der jedes Zeichen aus praktisch allen Schriftsystemen der Welt eindeutig beschreibt. Während ASCII nur 128 Symbole umfasst und damit vor allem die englische Sprache abdeckt, definiert Unicode einen gemeinsamen Zeichensatz mit weit über einer Million möglichen Codepunkten. Ein Codepunkt ist dabei eine Nummer, die einem Zeichen zugeordnet ist, zum Beispiel hat der Buchstabe „A“ den Codepunkt U+0041 und das Eurozeichen „€“ den Codepunkt U+20AC.\nWichtig ist die Unterscheidung zwischen Zeichensatz und Kodierung: Unicode ist der Zeichensatz (die Menge aller Zeichen mit ihren Codepunkten), während Formate wie UTF-8, UTF-16 oder UTF-32 beschreiben, wie diese Codepunkte als Bits und Bytes gespeichert oder übertragen werden. UTF-8 ist heute die am weitesten verbreitete Kodierung im Web. Sie ist variabel lang und hat eine zentrale Eigenschaft: Die ersten 128 Codepunkte (0–127) entsprechen exakt dem ASCII-Code. Dadurch ist UTF-8 vollständig rückwärtskompatibel zu ASCII. Eine reine ASCII-Datei ist zugleich gültiges UTF-8, und Funktionen wie chr() und ord() in Python arbeiten mit Unicode-Codepunkten. Wenn ihr also chr(65) aufruft, erhaltet ihr „A“ – das passt sowohl in ASCII als auch in Unicode. Für Zeichen außerhalb des ASCII-Bereichs verwendet UTF-8 mehr als ein Byte, bleibt aber weiterhin eindeutig und effizient.\nUTF-8 verwendet je nach Zeichen unterschiedlich viele Bytes – zwischen einem und vier. Häufige Zeichen wie die ASCII-Buchstaben brauchen nur 1 Byte. Ein „A“ hat den Codepunkt U+0041 und wird in UTF-8 als 0x41 gespeichert. Zeichen mit Akzenten benötigen oft 2 Bytes, zum Beispiel „ä“ (U+00E4) als 0xC3 0xA4. Das Eurozeichen „€“ (U+20AC) braucht 3 Bytes: 0xE2 0x82 0xAC. Ein Emoji wie „😊“ (U+1F60A) benötigt 4 Bytes: 0xF0 0x9F 0x98 0x8A.\nEine hilfreiche Analogie: Stellt euch UTF-8 wie einen Paketdienst mit vier Paketgrößen (S, M, L, XL) vor. Die meisten Sendungen (ASCII-Zeichen) passen in Größe S und sind damit sehr platzsparend. Für seltenere oder komplexere Zeichen wird automatisch eine größere Paketgröße gewählt. Am „Adressaufkleber“ – den ersten Bits des ersten Bytes – erkennt der Empfänger sofort, wie groß das Paket ist und wie viele Folgebytes er einlesen muss. So bleibt Text kompakt, und reine ASCII-Texte sind automatisch gültiges UTF-8.\nAuf diese Weise wird sichergestellt, dass die häufigsten Zeichen möglichst wenig Speicherplatz benötigen, während dennoch alle Zeichen der Welt eindeutig kodiert werden können. Das macht UTF-8 zur bevorzugten Wahl für die Textverarbeitung in modernen Anwendungen und im Web. Ihr könnt das übrigens selbst einmal überprüfen: Erstellt zwei leere Textdateien und speichert beide als UTF-8. Fügt in die erste einen Text nur aus Buchstaben, Zahlen und Leerzeichen ein und in die zweite einen Text mit Sonderzeichen und Emojis. Dabei sollte in jeder Datei die gleiche Anzahl Zeichen stehen. Wie unterscheidet sich die Größe der Dateien im Dateiexplorer?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#led-dimmer-4.0",
    "href": "text.html#led-dimmer-4.0",
    "title": "3  Texte",
    "section": "3.6 LED-Dimmer 4.0",
    "text": "3.6 LED-Dimmer 4.0\nIn Kapitel 2 haben wir bereits drei Versionen eines LED-Dimmers gebaut. Eine letzte, vierte Variante kommt noch dazu: Lasst uns schauen, ob wir die Helligkeit mit dem Abstandssensor steuern können.\nDas war wieder einmal eine rhetorische Frage, natürlich können wir das! Mit Computern lässt sich so gut wie jedes Problem lösen, es geht nur um das Wie. Vielleicht habt ihr schon eine Idee, nachdem wir den Abstandssensor in diesem Kapitel schon intensiv kennengelernt haben.\nDer Dimmer aus Kapitel 2 lässt die LED in verschiedenen Stufen heller und dunkler leuchten. Über den Drehknopf haben wir zunächst 1er-Schritte umgesetzt, was bedeutete, dass wir 256 Ticks des Drehknopfs benötigten, um die LED auf volle Helligkeit zu schalten. Später haben wir dann eine Konstante STEP eingeführt, um die Schritte zu vergrößern, sodass nur noch eine Umdrehung notwendig war.\nWie lässt sich das auf den Abstandssensor übertragen? Im Gegensatz zum Drehknopf, den wir beliebig lange in eine Richtung drehen können, hat der Abstandssensor einen festen Messbereich zwischen 4 und 30 cm. Das macht unsere Aufgabe einfacher, denn eine Transformation des Messbereichs in den Helligkeitsbereich der LED ist ausreichend. Wenn der Abstandssensor nun einen Wert von 4 cm misst, soll die LED auf 0 % Helligkeit dimmen, und bei 30 cm auf 100 % Helligkeit.\nNehmen wir an, der aktuelle Messwert ist in distance gespeichert, dann könnten wir den Helligkeitswert brightness so berechnen:\n\nbrightness = (distance - 40) / (300 - 40) * 255\n\nVergewissern wir uns, dass die Formel richtig ist. Wenn distance den Wert 4 cm hat, dann sollte brightness 0 sein. Das passt, denn der erste Teil der Formel wird dann 0. Und 0 geteilt durch egal was ergibt 0. Wenn distance = 300, dann sollte brightness 255 sein. Das passt ebenfalls, denn der erste Teil der Formel wird dann 260 und 260 geteilt durch 260 ergibt 1. Multipliziert mit 255 ergibt 255. Sieht also gut aus.\nDer folgende Code baut die Berechnungslogik in den LED-Dimmer aus Abschnitt 2.7 ein, der nur eine Farbe (Weiß) beherrscht. Wir könnten ihn aber genau wie in Abschnitt 2.9 um weitere Farben erweitern:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nir = BrickletDistanceIRV2('2a7S', ipcon) \n\nled = BrickletRGBLEDV2('ZEL', ipcon)\nled.set_rgb_value(0, 0, 0)  # Anfangszustand: aus\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        last_distance = distance\n\n        # Abstand (40–300 mm) auf LED-Helligkeit (0–255) abbilden\n        brightness = int((distance - 40) / (300 - 40) * 255)\n        led.set_rgb_value(brightness, brightness, brightness)  # LED-Helligkeit setzen\n\nJe näher wir mit der Hand an den Sensor kommen, desto dunkler wird die LED – und umgekehrt.\nDamit schließen wir dieses Kapitel ab. Wir haben gelernt, wie Computer Texte kodieren. Der Umweg über unser eigenes Eingabegerät für Binärcodes hat sich gelohnt: Eure Programmierskills sind gewachsen!\nIm folgenden Kapitel 4 beschäftigen wir uns mit Bildern, wie Computer sie sehen, und wie ein Bild auf den Bildschirm kommt.\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "images.html",
    "href": "images.html",
    "title": "4  Bilder",
    "section": "",
    "text": "Zusammenfassung\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#zusammenfassung",
    "href": "images.html#zusammenfassung",
    "title": "4  Bilder",
    "section": "",
    "text": "Wir führen das Hexadezimalsystem als ein Zahlensystem mit einer Basis &gt; 10 ein\n\n\n\n\n\n\n\nExperiment\n\n\n\n\nEinführung in die Idee einer Pixelmatrix aus Farbwerten als Bild\nVerwendung des LCD-Displays zur Veranschaulichung, auch wenn nur schwarz/weiß\nVerwendung von Zeichen auf dem LCD, um Pixel-Bitmaps für Schriftarten hervorzuheben\nStudierende nutzen Bitmap-Sheet, um ein eigenes Logo zu entwerfen und auf dem LCD anzuzeigen",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#experimentaufbau",
    "href": "images.html#experimentaufbau",
    "title": "4  Bilder",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\n\n\nErste Schritte mit …",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-bitmaps",
    "href": "images.html#sec-images-bitmaps",
    "title": "4  Bilder",
    "section": "4.1 Bitmaps",
    "text": "4.1 Bitmaps",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-compressed",
    "href": "images.html#sec-images-compressed",
    "title": "4  Bilder",
    "section": "4.2 Komprimierte Bilder",
    "text": "4.2 Komprimierte Bilder",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-hexadecimal",
    "href": "images.html#sec-images-hexadecimal",
    "title": "4  Bilder",
    "section": "4.3 Hexadezimal",
    "text": "4.3 Hexadezimal",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-rgb-code",
    "href": "images.html#sec-images-rgb-code",
    "title": "4  Bilder",
    "section": "4.4 Der RGB-Code",
    "text": "4.4 Der RGB-Code\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "sound.html",
    "href": "sound.html",
    "title": "5  Ton",
    "section": "",
    "text": "Zusammenfassung",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ton</span>"
    ]
  },
  {
    "objectID": "sound.html#experimentaufbau",
    "href": "sound.html#experimentaufbau",
    "title": "5  Ton",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\n\n\nErste Schritte mit …\n\n\n\n\nAdami, Christoph. 2016. „What is Information?“ Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nPólya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Ton</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Adami, Christoph. 2016. “What Is Information?”\nPhilosophical Transactions of the Royal Society A: Mathematical,\nPhysical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, and Dennis Brylow. 2020. Computer Science: An\nOverview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer\nHardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nPólya, George, and John Horton Conway. 2004. How to Solve It: A New\nAspect of Mathematical Method. Expanded Princeton Science Library\ned. Princeton Science Library. Princeton [N.J.]: Princeton University\nPress.\n\n\nScott, John C. 2009. But How Do It Know?: The Basic Principles of\nComputers for Everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]