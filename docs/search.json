[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Computer Science",
    "section": "",
    "text": "Vorwort\nGl√ºckwunsch ‚Äì du bist angekommen! Wie auch immer dein Weg hierher aussah, du hast es geschafft, dieses Buch zu √∂ffnen. Vielleicht bist du Student oder Studentin an der Hochschule Osnabr√ºck und wurdest (zu deinem Gl√ºck) gezwungen, oder du bist ganz bewusst hier gelandet und freust dich darauf, etwas Neues zu lernen ‚Äì genau wie ich.\nDieses Buch entstand urspr√ºnglich, um meinen Veranstaltungen an der Hochschule Osnabr√ºck eine verst√§ndliche und praxisnahe Grundlage zu geben. Es dient als Hauptlekt√ºre f√ºr meine Vorlesungen, aber auch als Nachschlagewerk f√ºr alle, die vielleicht mal eine Sitzung verpasst haben oder Themen eigenst√§ndig vertiefen wollen. Besonders willkommen sind dabei Quereinsteiger, Wiederholer oder einfach neugierige Menschen, die bisher noch gar keinen Kontakt mit der Hochschule Osnabr√ºck hatten.\nHier bekommst du keine trockene Theorie pr√§sentiert, sondern eine spannende, praxisnahe Einf√ºhrung in die Grundlagen moderner Computer und unserer digitalen Welt. Das Fach, das sich dahinter verbirgt, hei√üt auf Deutsch Informatik, international auch bekannt als Computer Science. Der Titel Hands-On Computer Science verr√§t bereits: Hier wird es praktisch ‚Äì und zwar von Anfang an.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#was-macht-dieses-buch-besonders",
    "href": "index.html#was-macht-dieses-buch-besonders",
    "title": "Hands-On Computer Science",
    "section": "Was macht dieses Buch besonders?",
    "text": "Was macht dieses Buch besonders?\nLehrb√ºcher zur Informatik gibt es reichlich. Viele davon sind gro√üartig, aber kaum eines passt perfekt zu dem, was ich mit meinen Studierenden vorhabe. Woran liegt das?\nViele klassische Informatikb√ºcher versuchen, das gesamte Fachgebiet m√∂glichst umfassend abzubilden. Das ist sinnvoll f√ºr angehende Informatiker, aber meine Zielgruppe bist du: Studierende in Studieng√§ngen wie Management nachhaltiger Ern√§hrungssysteme, Lebensmittelproduktion oder kAgrarsystemtechnologien ‚Äì oder vielleicht bist du nicht mal Student oder Studentin, sondern einfach interessiert daran, endlich Zugang zur digitalen Welt zu finden.\nKurz gesagt: Dieses Buch ist f√ºr jeden gedacht, der Lust hat, in die digitale Welt einzutauchen, ohne sich gleich mit komplizierten Details zu √ºberfordern. Daf√ºr brauchst du kein allumfassendes Nachschlagewerk, sondern einen klaren roten Faden, der dich Schritt f√ºr Schritt an die grundlegenden Konzepte heranf√ºhrt.\nViele B√ºcher versprechen Praxisn√§he, doch oft endet diese in n√ºchternen √úbungsaufgaben am Kapitelende. Genau hier setzt Hands-On Computer Science an und macht zwei Dinge anders:\n\nDu lernst informatische Konzepte direkt anhand spannender Projekte mit Hardware wie Microcontrollern, Sensoren, Buttons, LEDs und Displays kennen.\nDu arbeitest kontinuierlich am LiFi-Projekt, das dich durch alle Kapitel begleitet und dabei immer weiter w√§chst.\nTheorie und Praxis sind nicht getrennt, sondern eng miteinander verbunden ‚Äì Programmieren und informatische Grundlagen lernst du gleichzeitig.\n\nSchon ab Kapitel 1 beginnst du zu programmieren und zwar nicht abstrakt, sondern konkret mit Bauteilen wie Buttons. Im Laufe des Buches lernst du Schritt f√ºr Schritt neue Hardware-Komponenten kennen, die immer direkt mit relevanten informatischen Konzepten verkn√ºpft sind. So schlie√üt du am Ende nicht nur das LiFi-Projekt erfolgreich ab, sondern verf√ºgst fast nebenbei √ºber ein solides Fundament in der Informatik. Wenn alles gut l√§uft, merkst du kaum, wie schnell du gelernt hast.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#tipps-f√ºr-die-lekt√ºre",
    "href": "index.html#tipps-f√ºr-die-lekt√ºre",
    "title": "Hands-On Computer Science",
    "section": "Tipps f√ºr die Lekt√ºre",
    "text": "Tipps f√ºr die Lekt√ºre\nWeil es in diesem Buch viel ums Programmieren geht, findest du nat√ºrlich viele Codebl√∂cke. Als Einstiegssprache verwenden wir Python. Warum ausgerechnet Python? Das erf√§hrst du sp√§ter genauer.\nCodebl√∂cke sind deutlich sichtbar vom √ºbrigen Text abgehoben, meist grau hinterlegt und in einer Schreibmaschinenschrift dargestellt, etwa Courier New oder Consolas. Hier ein kleines Beispiel:\n1led.set_rgb_value(0, 0, 0)\n2led.set_rgb_value(255, 255, 255)\n\nprint(\"Diese Zeile hat keine Annotation\")\n\n3# Lasse die LED blau aufleuchten\nled.set_rgb_value(0, 0, 255)\n\n1\n\nSchaltet die LED aus, weil der RGB-Code (0,0,0) schwarz erzeugt.\n\n2\n\nSchaltet die LED auf wei√ües Licht, weil drei Mal die 255 die Farbe Wei√ü ergibt.\n\n3\n\nAuch Kommentare sind f√ºr kurze Erl√§uterungen n√ºtzlich.\n\n\nKommentare sind mit einer kleinen Zahl versehen. Wenn du die Online-Version nutzt und mit der Maus √ºber diese Zahl f√§hrst, erscheint ein Tooltip, der die Codezeile erkl√§rt. Das funktioniert nur online, nicht in PDF oder Druckversion.\nNoch ein kleiner Tipp: Wenn du mit der Maus √ºber den Codeblock f√§hrst, siehst du rechts oben ein Clipboard-Symbol. Ein Klick darauf kopiert den Code direkt in deine Zwischenablage, und du kannst ihn problemlos in dein ge√∂ffnetes Visual Studio Code oder eine andere IDE einf√ºgen und ausprobieren.\nAlle Codebeispiele findest du au√üerdem im GitHub-Repository, das zu diesem Buch geh√∂rt.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "experiments.html",
    "href": "experiments.html",
    "title": "Experimente",
    "section": "",
    "text": "Hands-On Programmieren lernen\nHast du dich schon einmal gefragt, wie man Informationen √ºber Licht √ºbertragen kann? Oder wie man mit Licht den Puls messen kann? Oder wie man mit zwei einfachen Kabeln einen Wasserstandssensor baut? Das alles klingt vielleicht weit hergeholt, ist aber tats√§chlich machbar ‚Äì und wie genau, das wollen wir in diesem Buch herausfinden! Dabei werden wir nicht nur die digitale Welt der Computer und Programmierung kennenlernen, sondern auch mit spannenden Ger√§ten in der analogen Welt arbeiten. In jedem Kapitel arbeiten wir mit anderen Ger√§ten, die dir unterschiedliche Facetten der digitalen Welt n√§herbringen und gleichzeitig erm√∂glichen, das Programmieren spielerisch zu erlernen.\nHier ein √úberblick √ºber die Ger√§te, mit denen wir gemeinsam experimentieren werden. Zusammengefasst kosten alle Komponenten 249 ‚Ç¨. Aber keine Sorge: Wenn du das Buch im Rahmen meines Moduls ‚ÄûDigitalisierung und Programmierung‚Äú an der Hochschule Osnabr√ºck liest, erh√§ltst du f√ºr das gesamte Semester ein komplettes Hardware-Kit.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#hands-on-programmieren-lernen",
    "href": "experiments.html#hands-on-programmieren-lernen",
    "title": "Experimente",
    "section": "",
    "text": "Abbildung¬†1: Tinkerforge Workbench mit vielen Ger√§ten\n\n\n\n\n\n\n\nWas?\nBauteil\nAnzahl\nPreis pro St√ºck\n\n\n\n\nBunte LED\nRGB LED Bricklet 2.0\n1\n8 ‚Ç¨\n\n\nButton mit integrierter, bunter LED\nRGB LED Button Bricklet\n1\n15 ‚Ç¨\n\n\nLicht- und Farbsensor\nColor Bricklet 2.0\n1\n17 ‚Ç¨\n\n\nLCD Touchdisplay\nLCD 128x64 Bricklet\n1\n33 ‚Ç¨\n\n\nPiezo Lautsprecher\nPiezo Speaker Bricklet 2.0\n1\n19 ‚Ç¨\n\n\nInfrarot-Entfernungsmesser\nDistance IR 4-30cm Bricklet 2.0\n1\n20 ‚Ç¨\n\n\nAnaloger Spannungssensor\nAnalog In Bricklet 3.0\n1\n14 ‚Ç¨\n\n\nSchalldruckpegelsenor\nSound Pressure Level Bricklet\n1\n35 ‚Ç¨\n\n\nMikrocontroller\nMaster Brick 3.2\n2\n35 ‚Ç¨\n\n\nAnschlusskabel 15 cm\nBricklet Kabel 15cm (7p-7p)\n8\n1 ‚Ç¨\n\n\nUSB-A- auf USB-C Kabel\nUSB-A auf USB-C Kabel 100 cm\n1\n6 ‚Ç¨\n\n\nMontageplatte\nMontageplatte 22x22 (12x12cm)\n2\n7 ‚Ç¨\n\n\nSchrauben, Abstandshalter und Muttern\nBefestigungskit 12mm\n4\n2 ‚Ç¨",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#spannende-experimente",
    "href": "experiments.html#spannende-experimente",
    "title": "Experimente",
    "section": "Spannende Experimente",
    "text": "Spannende Experimente\nKapitel f√ºr Kapitel werden wir an unterschiedlichen Experimenten arbeiten. Dabei lernst du nicht nur, wie man Hardware-Komponenten miteinander verbindet, sondern vor allem auch, wie man Computer ‚Äì diese universellen Probleml√∂sungsmaschinen ‚Äì f√ºr eigene Ideen und L√∂sungen programmieren kann. Hier ist der √úberblick, was dich in diesem Buch erwartet:\n\n\n\n\n\n\n\nKapitel\nExperiment(e)\n\n\n\n\n1¬† Farben\nWir lassen eine LED einen Regenbogenfarbverlauf √ºber die Zeit erzeugen.\n\n\n3¬† Texte\nWir lernen, wie man Texte umst√§ndlich und ohne Tastatur eingeben kann ‚Äì √ºber Handgesten.\n\n\n4¬† Bilder\nWir verbinden Tabellenkalkulation mit Bildern und Touchdisplays ü§Ø\n\n\n5¬† Codes\nWir lernen Morse-Code und wie wir diesen √ºber einen Lautsprecher ausgeben k√∂nnen.\n\n\n6¬† Umwandlung\nWir verwenden einfache Kippschalter, um analoge Werte in digitale Werte umzuwandeln.\n\n\n7¬† Information\n\n\n\n8¬† Sensoren\nWir bauen einen Wasserstandssensor mit einem analogen Spannungssensor.\n\n\n9¬† Signale\nWir basteln einen Pulsmesser aus einem Farbsensor üíì\n\n\n10¬† Protokolle\nWir √ºbertragen Nachrichten √ºber Lichtsignale üî¶\n\n\n11¬† Verschl√ºsselung\nWir verstecken geheime Botschaften in harmlosen Nachrichten üïµÔ∏è‚Äç‚ôÄÔ∏è\n\n\n12¬† Algorithmen\n\n\n\n13¬† Kompression\nWir entwickeln ein Verfahren, um Information zu komprimieren.\n\n\n14¬† Computer\nWir entwickeln eine Rechenmaschine, die zwei Bytes addieren kann, mit nur einem einem Bauteil.\n\n\n15¬† Probleme",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "href": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "title": "Experimente",
    "section": "Frust ist dein Freund ‚Äì zumindest ein bisschen",
    "text": "Frust ist dein Freund ‚Äì zumindest ein bisschen\nEins m√∂chte ich gleich vorwegnehmen: Beim Programmierenlernen ist eine gewisse Portion Frust unvermeidbar. Klingt unangenehm? Ist es auch! Aber es ist zugleich Teil eines enorm wertvollen Lernprozesses. Jeder Fehler, den du machst, ist eine Gelegenheit, um zu verstehen, wie Computer wirklich funktionieren ‚Äì n√§mlich absolut pr√§zise und ohne jede Toleranz f√ºr Fehler.\nComputer sind gnadenlose Lehrer. Sie zeigen dir sofort und unerbittlich, wenn etwas nicht stimmt ‚Äì sei es ein vergessener Punkt, ein falscher Buchstabe oder ein simpler Zahlendreher. Das kann frustrieren, aber genau dieses direkte und sofortige Feedback hilft dir auch, schnell und effektiv zu lernen. Sobald du verstehst, wie du aus Fehlermeldungen sinnvolle Schl√ºsse ziehst und deine Programme entsprechend korrigierst, wirst du belohnt ‚Äì mit Erfolgserlebnissen und einer steilen Lernkurve.\n\n\n\n\n\n\nAbbildung¬†2: Ein frustrierter Frosch\n\n\n\nAlso, wenn mal etwas nicht klappt: Nimm es nicht pers√∂nlich, sondern sieh es als Herausforderung. Atme tief durch, mach dir klar, dass Fehler unvermeidbar und sogar wichtig sind, und probier es noch einmal. Ich verspreche dir: Es lohnt sich!\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "colors.html",
    "href": "colors.html",
    "title": "1¬† Farben",
    "section": "",
    "text": "Setup\nBereit f√ºr dein erstes Hardware-Experiment? Du brauchst daf√ºr eine LED (RGB LED Bricklet 2.0) und einen Mikrocontroller (Master Brick 3.2). Befestige beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in Abbildung¬†1.1 gezeigt. Zwei Halterungen pro Ger√§t reichen v√∂llig. Denk an die kleinen, wei√üen Kunststoff-Unterlegscheiben ‚Äì die sch√ºtzen deine Platinen vor Druckstellen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#setup",
    "href": "colors.html#setup",
    "title": "1¬† Farben",
    "section": "",
    "text": "(a) Montageplatte mit allen Komponenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Nahaufnahme des Buttons.\n\n\n\n\n\n\n\n\n\n\n\n(c) Nahaufnahme des Master Bricks.\n\n\n\n\n\n\n\nAbbildung¬†1.1: Einfaches Setup mit Mikrocontroller und Button mit integrierter LED.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#erste-schritte-mit-dem-brick-viewer",
    "href": "colors.html#erste-schritte-mit-dem-brick-viewer",
    "title": "1¬† Farben",
    "section": "1.1 Erste Schritte mit dem Brick Viewer",
    "text": "1.1 Erste Schritte mit dem Brick Viewer\nDer Button ist mehr als nur ein Knopf. Er hat zwei Tricks drauf: Er erkennt, ob er gedr√ºckt wird, und er kann leuchten. In Farbe! Wie wir das testen? Das geht ganz leicht mit dem Brick Viewer.\nSchlie√üe zuerst den Master Brick √ºber das USB-Kabel an deinen Computer an und √∂ffne den Brick Viewer. Klicke dann auf den Connect-Button.\n\n\n\n\n\n\nAbbildung¬†1.2: √úber den Connect-Button verbindet sich der Brick Viewer mit dem angeschlossenen Master Brick.\n\n\n\nWenn alles geklappt hat, zeigt dir der Brick Viewer alle angeschlossenen Ger√§te in Tabs an. Schau dir Abbildung¬†1.3 an ‚Äì so etwa sollte es aussehen.\n\n\n\n\n\n\nAbbildung¬†1.3: Der Brick Viewer nachdem ihr mit dem Master Brick verbunden seid.\n\n\n\nWechsle nun zum Tab des RGB LED Buttons. Hier kannst du sowohl die Farbe der LED einstellen als auch den aktuellen Zustand des Buttons sehen. Im Moment steht da vermutlich ‚Äûreleased‚Äú, was so viel bedeutet wie ‚Äûnicht gedr√ºckt‚Äú. Probier es direkt aus: Dr√ºck den Button! Schau, was passiert!\nMit den drei Schiebereglern steuerst du die Farbe ‚Äì Rot, Gr√ºn, Blau. Wertebereich: 0 bis 255. Warum gerade diese Zahlen? Gute Frage. Die Antwort kommt weiter unten.\n\n\n\n\n\n\nAbbildung¬†1.4: Die Ansicht f√ºr den RGB LED Button im Brick Viewer, in der alle Funktionen per Klick im Zugriff sind.\n\n\n\nFazit: Der Brick Viewer ist top zum Rumprobieren. Aber wenn du echte Projekte umsetzen willst, musst du programmieren k√∂nnen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#unser-erstes-programm",
    "href": "colors.html#unser-erstes-programm",
    "title": "1¬† Farben",
    "section": "1.2 Unser erstes Programm",
    "text": "1.2 Unser erstes Programm\nWie verbindet man sich eigentlich √ºber ein Programm mit dem Button? Die Antwort darauf findest du im folgenden kurzen Codebeispiel.\n\n\n\n\nListing¬†1.1: Der Boilerplate Code f√ºr die Verbindung mit den Ger√§ten am Beispiel des Buttons.\n\n\n1from tinkerforge.ip_connection import IPConnection\n2from tinkerforge.bricklet_rgb_led_button import BrickletRGBLEDButton\n\n3ipcon = IPConnection()\n4ipcon.connect(\"localhost\", 4223)\n5btn = BrickletRGBLEDButton(\"Ds3\", ipcon)\n\n\n\n\n\n1\n\nHier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.\n\n2\n\nHier importieren wir ein weietres Objekt, das wir zur Darstellung des Buttons als Python-Objekt ben√∂tigen.\n\n3\n\nDie Verbindung erfolgt √ºber eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.\n\n4\n\nMit connect stellen wir eine Verbindung zum angeschlossenen Master Brick her.\n\n5\n\nSchlie√ülich holen wir uns eine virtuelle Instanz des RGB LED Button Bricklets, indem wir die UID nennen und sagen, welche Verbindung (ipcon) genutzt werden soll.\n\n\n\n\n\n1.2.1 Programme\nZun√§chst einmal kl√§ren wir den Begriff Programm. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausf√ºhrt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm sp√§ter daf√ºr zust√§ndig, mit dem Button zu interagieren und die LED in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns erm√∂glichen, dem Computer pr√§zise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut f√ºr Einsteiger eignet und gleichzeitig m√§chtig genug ist, um komplexe Aufgaben zu l√∂sen.\nWenn wir ein Programm ausf√ºhren, arbeitet der Computer die Anweisungen Schritt f√ºr Schritt von oben nach unten ab. Es gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir sp√§ter kennen.\n\n\n1.2.2 Boilerplate Code\nDer Codeauschnitt in Listing¬†1.1 wird uns im Verlauf dieses Buches immer wieder begegnen. Wir ben√∂tigen ihn, um uns am Anfang des Programms mit den Ger√§ten zu verbinden. In der Informatik nennen wir solchen Code, den wir h√§ufig in der gleichen Form ben√∂tigen und fast eins zu eins kopieren k√∂nnen, auch Boilerplate Code. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.\n\n\n1.2.3 Bibliotheken\nBeginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr √§hnliche Befehle, die mit dem Schl√ºsselwort from beginnen. Nach dem Schl√ºsselwort from folgt der Name einer Bibliothek, aus der wir ein f√ºr unser Programm ben√∂tigtes Objekte importieren. Die Kombination der Schl√ºsselw√∂rter from ...import l√§sst sich also w√∂rtlich √ºbersetzen: ‚ÄúAus der Bibliothek X importiere das Objekt Y‚Äù.\nEine Bibliothek in einer Programmiersprache ist die B√ºndelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek kannst du dir vorstellen wie einen Werkzeugkasten: Sie enth√§lt fertige Werkzeuge (Funktionen und Klassen), damit du nicht alles von Grund auf selbst schreiben musst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Ger√§ten loslegen k√∂nnen.\n\n\n1.2.4 Klassen und Objekte\nMit from ... import importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit importieren ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge sp√§ter wirklich nutzen steht auf einem anderen Blatt.\nIn dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ank√ºndigen. Die erste Klasse heisst IPConnection und die zweite BrickletRGBLEDButton. Der Begriff Klasse ist hier verstehen analog zum Begriff Kategorie. Wir k√∂nnen zu einer Klasse geh√∂rige Objekte erzeugen, und alle Objekte der selben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.\nStellt euch vor, ihr habt eine Klasse namens Auto. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa fahren(), bremsen() oder tanken(). Diese Dinge sollen f√ºr jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Du kannst also sagen: ‚ÄúMein Auto ist ein Objekt der Klasse Auto.‚Äù Jedes Auto hat die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte f√ºr diese Eigenschaftan haben.\nGenauso verh√§lt es sich mit den Klassen, die Tinkerforge f√ºr uns bereitgestellt hat. Die Klasse IPConnection beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen k√∂nnen, und die Klasse BrickletRGBLEDButton beschreibt, wie wir mit dem Button interagieren k√∂nnen. Wenn wir ein Objekt dieser Klasse erstellen, k√∂nnen wir die Funktionen nutzen, die in der Klasse definiert sind. Ein Button muss nicht fahren oder bremsen wie ein Auto. Daf√ºr hat er andere Funktionen, wie etwa get_button_state() oder set_color(), die uns erlauben, den Status des Buttons abzufragen oder die Farbe der integrierten LED zu √§ndern. Eine Eigenschaft jedes Buttons ist seine UID, die eindeutig ist und uns hilft, ihn im System zu identifizieren.\n\n\n1.2.5 Schl√ºsselw√∂rter\nSoeben haben wir mit from und import unsere ersten beiden Schl√ºsselw√∂rter in Python kennengelernt! Aber was bedeutet das genau? Ein Schl√ºsselwort, das wir im Englischen auch keyword oder reserved keyword nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch h√§ufig Namen vergeben m√ºssen, etwa f√ºr Variablen oder Funktionen. Diese Namen d√ºrfen nicht wie ein Schl√ºsselwort lauten, ansonsten funktioniert unser Programm nicht wie gew√ºnscht. Welche Schl√ºsselw√∂rter es in Python gibt, k√∂nnt ihr hier nachschauen.\nIm Codeausschnitt oben laden wir zuerst das Objekt f√ºr die Verbindung zum angeschlossenen Mikrocontroller, die √ºber eine IP-Verbindung hergestellt wird. Was das genau ist? Sp√§ter mehr dazu. Zus√§tzlich zur IPConnection laden wir anschlie√üend noch die ben√∂tigen Klassen f√ºr die Ger√§te, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur der Button mit integrierter LED.\n\n\n1.2.6 Objekte erzeugen\nIn Listing¬†1.1 in Zeile 4 erzeugen wir ein Objekt der Klasse IPConnection. Die fertige Instanz - so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde - speichern wir auf einer Variable mit dem Namen ipcon. Diesen Namen haben wir uns selbst ausgedacht, damit wir sp√§ter darauf zugreifen k√∂nnen. Eine Variable ist also ein Platzhalter f√ºr einen Wert, den wir sp√§ter im Programm verwenden wollen. In diesem Fall ist ipcon der Platzhalter f√ºr die Verbindung zu unserem Mikrocontroller. Was eine Variable genau ist, lernen wir sp√§ter noch genauer kennen.\n\n\n1.2.7 Methoden\n√úber das Objekt ipcon k√∂nnen wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode connect(). Eine Methode ist eine Funktion, die zu einem Objekt geh√∂rt. Wie etwa fahren() oder bremsen() in unserem Auto-Beispiel.\nWir k√∂nnen Methoden aufrufen, um eine bestimmte Aktion auszuf√ºhren. In diesem Fall stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, √ºber den die Verbindung hergestellt werden soll. In unserem Fall ist das ‚Äúlocalhost‚Äù, was f√ºr die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standarm√§√üig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt . nach dem Objekt, gefolgt vom Namen der Methode und den Klammern (), in denen wir eventuell ben√∂tigte Parameter angeben.\n\n\n1.2.8 Ein Objekt f√ºr den Button\nIn Zeile 6 erzeugen wir schlie√ülich ein Objekt der Klasse BrickletRGBLEDButton. Dieses Objekt repr√§sentiert unseren Button und erm√∂glicht es uns, mit ihm zu interagieren. Wir nennen das Objekt btn, was f√ºr Button steht. Auch hier haben wir uns den Namen selbst ausgedacht, um sp√§ter darauf zugreifen zu k√∂nnen. Auch wenn wir grunds√§tzlich Variablennamen frei w√§hlen k√∂nnen, sollten sie immer so gew√§hlt werden, dass sie den Inhalt der Variable beschreiben. Das macht es sp√§ter einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten m√ºssen. Dazu geh√∂ren etwa, dass Variablennamen nicht mit einer Zahl beginnen d√ºrfen und keine Leerzeichen enthalten d√ºrfen. Eine ausf√ºhrliche Liste der Regeln findest du hier.\n\n\n1.2.9 Zusammenfassung unseres ersten Programms\nDamit haben wir unser erstes Programm von oben nach unten erl√§utert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:\n\n\n\n\n\n\n\nProgramme\nAbfolge von Anweisungen, die nacheinander ausgef√ºhrt werden.\n\n\nBoilerplate Code\nStandard-Code, den man immer wieder braucht.\n\n\nImportieren von Bibliotheken\nSammlung von fertigen Code-Elementen.\n\n\nSchl√ºsselw√∂rter\nReservierte Begriffe der Programmiersprache.\n\n\nKlassen und Objekte\nKategorien und deren konkrete Instanzen.\n\n\nMethoden und Funktionen\nFunktionen, die zu einem Objekt geh√∂ren.\n\n\nVariablen\nPlatzhalter f√ºr Werte.\n\n\n\n\n\n1.2.10 Und jetzt?\nWir haben nun eine virtuelle, digitale Repr√§sentation unseres Buttons im Python. Damit k√∂nnen wir die LED des Buttons zum Leuchten bringen. Dazu verwenden wir eine Methode der Klasse BrickletRGBLEDButton, die set_color() hei√üt. Diese Methode erwartet drei Parameter: Rot, Gr√ºn und Blau. Mit diesen Parametern k√∂nnen wir die Farbe der LED einstellen.\n\n1btn.set_color(0, 255, 0)\n\n\n1\n\nSetzt die LED auf gr√ºn. R = 0, G = 255, B = 0. Logisch, oder?\n\n\n\n\nMoment mal ‚Ä¶ Wo steht hier eigentlich gr√ºn? Steht da gar nicht. Stattdessen: Zahlen. Willkommen bei der RGB-Farbkodierung. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Gr√ºn, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Wei√ü. Nur Gr√ºn auf 255? Na klar: gr√ºn.\nAber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie √ºbersetzen wir die Welt in etwas, das ein Computer versteht?\nWarum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit drei Zahlen? Warum √ºberhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#farben-und-licht",
    "href": "colors.html#farben-und-licht",
    "title": "1¬† Farben",
    "section": "1.3 Farben und Licht",
    "text": "1.3 Farben und Licht\nPyhsik ist vielleicht schon eine Weile her und wir halten es hier auch kurz. Erinnern wir uns kurz, was Licht und damit Farben sind. Licht ist eine Form von elektromagnetischer Strahlung. Das bedeutet, dass es sich um Wellen handelt, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenl√§ngen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen √ºber Infrarotstrahlung bis hin zu R√∂ntgenstrahlen und Gammastrahlen reicht.\nBei Wellen unterscheiden wir zwischen der Frequenz (wie oft die Welle pro Sekunde schwingt) und der Wellenl√§nge (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenl√§nge sind umgekehrt proportional: Je h√∂her die Frequenz, desto k√ºrzer die Wellenl√§nge und umgekehrt.\nFrequenzen messen wir in Hertz (Hz), wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenl√§ngen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) f√ºr violettes Licht und etwa 700 nm f√ºr rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abst√§nde zwischen den Wellenl√§ngen des sichtbaren Lichts sind also extrem klein.\nWas bedeutet das nun f√ºr eine LED? Eine LED (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchflie√üt. Die Farbe des Lichts h√§ngt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenl√§ngen, was zu verschiedenen Farben f√ºhrt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenl√§nge von etwa 620-750 nm, w√§hrend eine gr√ºne LED Licht mit einer Wellenl√§nge von etwa 495-570 nm emittiert.\n\n\n\n\n\n\nAbbildung¬†1.5: Das elektromagnetische Spektrum, wovon das sichtbare Licht ein Teil ist. (Quelle: Wikipedia)\n\n\n\nDie RGB LEDs, die in unserem Button verbaut ist, besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer gr√ºnen und einer blauen. Jede dieser LEDs kann unabh√§ngig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Spannung bedeutet mehr Intensit√§t der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Gr√ºn und Blau in unterschiedlichen Intensit√§ten k√∂nnen wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensit√§t leuchten lassen, erhalten wir Wei√ü. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LED sind dann alle aus.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#farben-im-computer",
    "href": "colors.html#farben-im-computer",
    "title": "1¬† Farben",
    "section": "1.4 Farben im Computer",
    "text": "1.4 Farben im Computer\nNun wissen wir, warum die Methode set_color() drei Parameter erwartet: Rot, Gr√ºn und Blau. Diese Parameter sind die Intensit√§ten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 k√∂nnen wir jede Farbe im sichtbaren Spektrum erzeugen.\nWie kommt es aber zu der merkw√ºrdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grunds√§tzlich Werte speichert und wie dieser Speicher organisiert ist. Kurz gesagt: Der Wertebereich 0 bis 255 passt genau in ein sogenanntes Byte. Ein Byte ist eine Speichereinheit, die aus 8 Bits besteht. Ein Bit kann entweder 0 oder 1 sein. Mit 8 Bits k√∂nnen wir also \\(2^8 = 256\\) verschiedene Werte darstellen, von 0 bis 255. Das ist genau der Bereich, den wir f√ºr die RGB-Farbkodierung verwenden. Dazu lernen wir sp√§ter noch mehr.\nWir halten also fest, dass sich ein Farbwert im Computer aus drei Zahlen zusammensetzt, die jeweils zwischen 0 und 255 liegen. Das gilt f√ºr unsere LED, aber beispielsweise auch f√ºr Pixel in Bildern oder auf eurem Bildschirm. Das beleuchten wir sp√§ter auch noch genauer.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#farben-mischen",
    "href": "colors.html#farben-mischen",
    "title": "1¬† Farben",
    "section": "1.5 Farben mischen",
    "text": "1.5 Farben mischen\nKlingt alles theoretisch ja sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus!\n\nbtn.set_color(255, 255, 0)\n\nWas macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!\n\n1.5.1 Additive Farbmischung\nIhr solltet alle euren Button in Gelb aufleuchten sehen. In der additiven Farbmischung mischen wir Rot und Gr√ºn und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Gr√ºn, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensit√§t leuchten lassen, erhalten wir eine neue Farbe, die stest heller ist als die Ursprungsfarben. Wir f√ºgen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensit√§t mischen erhalten wir schlie√ülich Wei√ü.\n\nbtn.set_color(255, 255, 255)\n\n\n\n1.5.2 Subtraktive Farbmischung\nDie subtraktive Farbmischung funktioniert anders, n√§mlich genau umgekehrt. Statt beim Mischen Licht hinzuzuf√ºgen, nehmen wir Licht weg.\nErinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbenkasten die Mischung aus Rot und Gr√ºn ergeben? Sicher nicht gelb - eher braun. Eind unklere Farbe. Das liegt daran, dass wir hier nicht von additiver, sondern von subtraktiver Farbmischung sprechen. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht absorbieren und reflektieren. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtsprektrums werden nicht mehr refklektiert, sondern absorbiert und sind damit nicht mehr sichtbar.\nWas passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, n√§mlich W√§rme. Deshalb wird eine schwarze Oberfl√§che auch besonders hei√ü, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspekturm und wandelt es in W√§re um. Dagegen wirken wei√üe Oberfl√§chen fast wie Klimaanlagen. Es ist kein Zuall, dass wir in sonnigen Erdteilen viele wei√üe Fassaden sehen.\nWenn wir alle Farben mischen ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zur√ºck. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen kombinieren, um neue Farben zu erhalten.\n\n\n\n\n\n\n\n\n\n\n\n(a) Additive Farbmischung\n\n\n\n\n\n\n\n\n\n\n\n(b) Subtraktive Farbmischung\n\n\n\n\n\n\n\nAbbildung¬†1.6: Additive und subtraktive Farbmischung.\n\n\n\nDie Grundfarben, die wir bei der subtraktiven Variante ben√∂tigen, um daraus alle weiteren Farben zu erhalten sind Cyan, Magenta sowie Gelb. Im Englischen ist die Abk√ºrzung CMY, wo das ‚ÄúY‚Äù f√ºr Yellow steht. In der additiven Farbmischung sind es Rot, Gr√ºn und Blau. Wenn ihr Abbildung¬†1.6 (b) betrachtet dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der subtraktiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?\nDas war nat√ºrlich eine rethorische Frage. Wenn wir in der additiven Farbmischung Gr√ºn und Rot mischen, um Gelb zu erhalten, muss es im Umkehrschluss bedeuten, dass\nDamit k√∂nnen wir auch erkl√§ren, warum Farbdrucker vier unterschiedliche Kartuschen ben√∂tigen (Abbildung¬†1.7). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb k√∂nnen wir jede beliebige Farbe mischen. Zus√§tzlich haben Drucker eine Kartusche f√ºr Schwarz, um erstens ein sattes Schwarz drucken zu k√∂nnen und zweitens die Farbkartuschen zu schonen. Denn schlie√ülich m√ºssen alle drei Farben gemmischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen schwarz enthalten (oder sogar ausschlie√ülich) ist eine schwarze Kartusche einfach effizienter.\n\n\n\n\n\n\nAbbildung¬†1.7: Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.\n\n\n\nFarben spielen eine so wichtige Rolle f√ºr uns und die Arbeit mit Computern. Deshalb lohnt es sich, ein wenig √ºber die Hintergr√ºnde von Farben und deren Mischung zu verstehen. Wir werden sp√§ter noch lernen, wie Bildschirme Farben darstellen. Sp√§testens dann wird uns das Thema der Farbmischung wieder begegnen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#der-rgb-code",
    "href": "colors.html#der-rgb-code",
    "title": "1¬† Farben",
    "section": "1.6 Der RGB-Code",
    "text": "1.6 Der RGB-Code\nWir wollen jetzt weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, besser verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED √ºber die Methode set_color() ver√§ndern k√∂nnen, wenn wir wissen, welcher RGB-Code die Farbe repr√§sentiert, die wir uns w√ºnschen. Da wir jetzt mehr √ºber die Farbmischung wissen, k√∂nnen wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:\n\nbtn.set_color(255, 0, 255)\n\nGem√§√ü der Theorie der additiven Farbmischung m√ºsste Rot und Blau Magenta ergeben. Probiert es aus!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#schleifen",
    "href": "colors.html#schleifen",
    "title": "1¬† Farben",
    "section": "1.7 Schleifen",
    "text": "1.7 Schleifen\nDas Ziel unseres ersten Experiments ist es, einen Regenbogebenfarbverlauf zu erzeugen. Dazu m√ºssen wir die Farbe der LED kontinuierlich √§ndern, sodass sie von Rot √ºber Gelb, Gr√ºn, Cyan, Blau und Violett wieder zur√ºck zu Rot wechselt. Das erreichen wir mit einer Schleife. Eine Schleife ist ein Konstrukt in der Programmierung, das es uns erm√∂glicht, einen bestimmten Codeabschnitt mehrfach auszuf√ºhren, ohne ihn jedes Mal neu schreiben zu m√ºssen. Das spart Zeit und macht den Code √ºbersichtlicher.\n\n1.7.1 Abz√§hlbare Wiederholung\nWir beginnen wie immer einfach. Wir n√§hern uns dem Regenbogen schrittweise an. Zun√§chst w√§re es cool, wenn wir die LED einfach Rot pulsieren lassen k√∂nnten. Dazu m√ºssen wir n√§mlich nur den Rot-Kanal und nicht alle drei Kan√§le der LED ansteuern.\nAber was bedeutet es, die LED pulsieren zu lassen? Und was m√ºssen wir daf√ºr tun? Pulsieren bedeutet, dass die LED langsam immer heller wird, kurz in der vollen Helligkeit verweilt, aber dann sofort wieder kontinuierlich dunklert wird. Sobald sie schwarz ist f√§ngt der Zyklus von Vorne an.\n\n\n1.7.2 Bedingte Wiederholung\n\nif .. elif .. else",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#das-fertige-programm",
    "href": "colors.html#das-fertige-programm",
    "title": "1¬† Farben",
    "section": "1.8 Das fertige Programm",
    "text": "1.8 Das fertige Programm\n\n\n\n\nListing¬†1.2: Das fertige Programm, das die LED in einem Regenbogenfarbverlauf leuchten l√§sst.\n\n\nimport keyboard\nimport time\nimport colorsys\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn button of initially\nled.set_rgb_value(0, 0, 0)\n\n# Initialize the hue value\nhue = 1\n\n# Set the duration for one rainbow cycle\nduration_seconds = 4\nduration_seconds_per_step = duration_seconds / 360\n\n# Loop until user presses escape key\nwhile not keyboard.is_pressed('esc'):\n\n    # Calculate RGB from hue\n    r, g, b = colorsys.hsv_to_rgb(hue / 360.0, 1.0, 1.0)\n    r = int(r * 255)\n    g = int(g * 255)\n    b = int(b * 255)\n\n    led.set_rgb_value(r, g, b)\n    \n    # Wait a bit\n    time.sleep(duration_seconds_per_step)\n\n    hue = hue + 1\n    if hue &gt; 360:\n        hue = 1\n\nled.set_rgb_value(0, 0, 0)\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "human_input.html",
    "href": "human_input.html",
    "title": "2¬† Eingaben",
    "section": "",
    "text": "Setup\nWir erweitern unser Setup aus Kapitel 1 und f√ºgen ein Eingabeger√§t hinzu: Einen einfachen Drehknopf (Rotary Encoder Bricklet 2.0). Den schraubt ihr neben die LED, wie auf der Abbildung zu sehen ist.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Eingaben</span>"
    ]
  },
  {
    "objectID": "human_input.html#setup",
    "href": "human_input.html#setup",
    "title": "2¬† Eingaben",
    "section": "",
    "text": "Experiment\n\n\n\n\nRGB LED Button als Eingabeger√§t\nEinf√ºhrung in andere Eingabeger√§te",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Eingaben</span>"
    ]
  },
  {
    "objectID": "human_input.html#das-fertige-programm",
    "href": "human_input.html#das-fertige-programm",
    "title": "2¬† Eingaben",
    "section": "2.1 Das fertige Programm",
    "text": "2.1 Das fertige Programm\n\nimport keyboard\nimport time\nimport colorsys\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn button of initially\nled.set_rgb_value(0, 0, 0)\n\n# Initialize the hue value\nhue = 1\n\n# Set the duration for one rainbow cycle\nduration_seconds = 4\nduration_seconds_per_step = duration_seconds / 360\n\n# Loop until user presses escape key\nwhile not keyboard.is_pressed('esc'):\n\n    # Calculate RGB from hue\n    r, g, b = colorsys.hsv_to_rgb(hue / 360.0, 1.0, 1.0)\n    r = int(r * 255)\n    g = int(g * 255)\n    b = int(b * 255)\n\n    led.set_rgb_value(r, g, b)\n    \n    # Wait a bit\n    time.sleep(duration_seconds_per_step)\n\n    hue = hue + 1\n    if hue &gt; 360:\n        hue = 1\n\nled.set_rgb_value(0, 0, 0)\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Eingaben</span>"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "3¬† Texte",
    "section": "",
    "text": "Setup\nF√ºr dieses Kapitel ben√∂tigen wir die LED (RGB LED Bricklet 2.0) und den Infrarot-Entfernungsmesser Distance IR 4-30cm Bricklet 2.0. Beide Ger√§te schlie√üen wir an den Mikrocontroller (Master Brick 3.2) and und fixieren alle drei auf einer Montageplatte. Wie in der Abbildung gezeigt, soll der Entfernungsmesser dabei nach oben zeigen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#setup",
    "href": "text.html#setup",
    "title": "3¬† Texte",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#texte-ganz-ohne-tastatur",
    "href": "text.html#texte-ganz-ohne-tastatur",
    "title": "3¬† Texte",
    "section": "3.1 Texte ‚Äì ganz ohne Tastatur?",
    "text": "3.1 Texte ‚Äì ganz ohne Tastatur?\nJa, ich gebe zu: Eine Tastatur ist schon richtig praktisch. Schnell tippen wir damit Buchstaben, Zahlen, Satz- und Sonderzeichen (wie neue Zeilen und Leerzeichen) ein. Aber stell dir mal vor: Wie k√∂nnte ich eigentlich dieses Buch schreiben, wenn ich keine Tastatur h√§tte?\nTats√§chlich gibt es spannende Alternativen! Hast du schon mal versucht, Texte zu diktieren? Google Docs oder Microsoft Word bieten mittlerweile ziemlich gute M√∂glichkeiten daf√ºr. Anfangs f√ºhlt sich das ungewohnt an, aber ich kenne Menschen, die darauf schw√∂ren und damit sogar produktiver sind.\nHeute wollen wir aber bewusst einmal einen Schritt zur√ºckgehen und das Tippen absichtlich erschweren. Klingt komisch? Macht aber Sinn! Denn wenn wir das Eingeben von Texten schwieriger gestalten, lernen wir einerseits, unsere Tastaturen wieder richtig zu sch√§tzen. Andererseits verstehen wir dann besser, wie Texte im Hintergrund verarbeitet und gespeichert werden.\nWie w√§re es also mit einer Tastatur, die auf Handgesten basiert? Klingt verr√ºckt? Perfekt ‚Äì genau das machen wir!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "href": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "title": "3¬† Texte",
    "section": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten",
    "text": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten\nStarten wir ganz simpel. Wir bauen zuerst eine Art ‚ÄúKnopf‚Äù oder Button, der auf Handgesten reagiert. Daf√ºr verwenden wir einen der Infrarot-Abstandssensoren ‚Äì oder wie er bei Tinkerforge hei√üt: Distance IR 4-30cm Bricklet 2.0. Wie der Name schon sagt, misst der Sensor Entfernungen von 4 bis maximal 30 cm.\nUm den Sensor in unserem Programm zu nutzen, k√∂nnen wir ganz entspannt den Grundcode (Boilerplate-Code) aus den vorherigen Kapiteln √ºbernehmen. Nur zwei kleine Anpassungen brauchen wir noch speziell f√ºr unseren Sensor:\n\nfrom tinkerforge.ip_connection import IPConnection\n1from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n2ir_sensor = BrickletDistanceIRV2(\"\", ip_con)\n\n\n1\n\nHier importieren wir die Klasse f√ºr den IR-Sensor.\n\n2\n\nHier erzeugen wir eine konkrete Instanz und verbinden uns mit dem angeschlossenen Sensor. Vergiss nicht, deine UID hier einzutragen!\n\n\n\n\nWas kann der Sensor? Eigentlich hat er nur eine Funktion:\n\n1distance = ir_sensor.get_distance()\n2print(f\"Objekt ist {distance/100} cm entfernt\")\n\n\n1\n\nDie Funktion get_distance() fragt den aktuell gemessenen Wert ab.\n\n2\n\nDer Sensor liefert den Wert in Zentimeter * 100 zur√ºck.\n\n\n\n\nAber wie l√§sst sich mit den Entfernungswert ein Button umsetzen? Dazu vergegenw√§rtigen wir uns, was ein herk√∂mmlicher Button eigentlich ist und wie er funktioniert. Ein Button, wie wir ihn auf einer Tastatur finden, kennt zwei Zust√§nde: Gedr√ºckt und nicht gedr√ºckt. An oder aus. Wenn wir eine Taste dr√ºcken, so schlie√üen wir dar√ºber einen Stromkreis, der in einem winzigen Mikroprozessor m√ºndet. Dieser Prozessor erkennt durch laufendes Scannen s√§mtlicher Verbindungen zu den Tasten (die als Matrix angeordnet sind), durch welche Kreise Strom flie√üt und kann so auf die gedr√ºckte Taste schlie√üen. Der Mikroprozessor ermittelt dann anhand der Koordinate in der Matrix einen so gennanten Scan Code, der f√ºr jede Taste anders lautet. Dieser Code wird als bin√§re Folge von Nullen und Einsen √ºber das USB-Kabel an den Computer geschickt und dort von dem aktiven Programm - etwa einer Textverarbeitungssoftware - in ein Codesystem umgewandelt, das Zeichen abbilden kann. So wie etwa das ASCII-Codesystem, das wir weiter unten kennenlernen.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "images.html",
    "href": "images.html",
    "title": "4¬† Bilder",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\n\nEinf√ºhrung in die Idee einer Pixelmatrix aus Farbwerten als Bild\nVerwendung des LCD-Displays zur Veranschaulichung, auch wenn nur schwarz/wei√ü\nVerwendung von Zeichen auf dem LCD, um Pixel-Bitmaps f√ºr Schriftarten hervorzuheben\nStudierende nutzen Bitmap-Sheet, um ein eigenes Logo zu entwerfen und auf dem LCD anzuzeigen\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "codes.html",
    "href": "codes.html",
    "title": "5¬† Codes",
    "section": "",
    "text": "Experiment\n\n\n\nMorse-Code √ºber Piezo Speaker\n\nEinf√ºhrung des Piezo Speaker\nCodesysteme\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Codes</span>"
    ]
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#setup",
    "href": "conversion.html#setup",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Experiment\n\n\n\nMit 4 Kippschaltern und 4 Widerst√§nden bauen wir einen Digital-To-Analog-Converter (DAC). Dazu kommt ein Breadboard und diveser √úberbr√ºckungskabel zum Einsatz. Au√üerdem brauchen wir den Analog In 3.0 von Tinkerforge.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-in-den-computer-hinein",
    "href": "conversion.html#der-weg-in-den-computer-hinein",
    "title": "6¬† Umwandlung",
    "section": "6.1 Der Weg in den Computer hinein",
    "text": "6.1 Der Weg in den Computer hinein",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-aus-dem-computer-heraus",
    "href": "conversion.html#der-weg-aus-dem-computer-heraus",
    "title": "6¬† Umwandlung",
    "section": "6.2 Der Weg aus dem Computer heraus",
    "text": "6.2 Der Weg aus dem Computer heraus\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "information.html",
    "href": "information.html",
    "title": "7¬† Information",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "information.html#setup",
    "href": "information.html#setup",
    "title": "7¬† Information",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "sensors.html",
    "href": "sensors.html",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#setup",
    "href": "sensors.html#setup",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\nAnalog vs.¬†digital\nBaue einen Wasserstandssensor mit einem Widerstand und dem Analog-In-Bricklet.\nOder: Feuchtigkeitssensor in eine Pflanze stecken\nOder: Ber√ºhrungssensor\nOder: Pulssensor (Farbsensor)\nIntegriere die RGB-LED irgendwie\nFarbsensor",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#aufgaben",
    "href": "sensors.html#aufgaben",
    "title": "8¬† Sensoren",
    "section": "Aufgaben",
    "text": "Aufgaben\n\nProgrammiere einen Batteriedoktor mithilfe des Analog In Sensors\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "signals.html",
    "href": "signals.html",
    "title": "9¬† Signale",
    "section": "",
    "text": "Setup\nHast du dich schon einmal gefragt, wie dein Fitness-Tracker deinen Puls messen kann, obwohl du nur einen Finger auflegst? Diese Frage f√ºhrt uns direkt zu einem spannenden Konzept: Signalen. Alles, was wir mit Sensoren messen, sind zun√§chst einmal beliebige Gr√∂√üen. Doch nicht alles, was wir messen, ist f√ºr uns relevant. Wir suchen nach Mustern in diesen Daten ‚Äî eben genau diesen Mustern, die wir als Signale bezeichnen. Alles andere, was uns von diesen Signalen ablenkt, nennen wir Rauschen. Unser Ziel: Wir m√∂chten herausfinden, wie wir Signale effektiv vom Rauschen unterscheiden k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#setup",
    "href": "signals.html#setup",
    "title": "9¬† Signale",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\nMithilfe des Farbsensors bauen wir einen Pulsmesser.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "href": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "title": "9¬† Signale",
    "section": "9.1 Pulsmesser: Dein Finger als Signalquelle",
    "text": "9.1 Pulsmesser: Dein Finger als Signalquelle\nErinnerst du dich noch an den Farbsensor aus Kapitel 8? Er misst nicht nur die Intensit√§t des RGB-Spektrums, sondern auch die allgemeine Lichtintensit√§t, auch Illuminance genannt. Hier kommt die spannende Tatsache ins Spiel: Genau dieses Prinzip steckt hinter den Pulsmessern in Fitnesstrackern. Ja, genau der Sensor, der Licht misst, verr√§t dir, wie schnell dein Herz schl√§gt!\nAber wie genau funktioniert das? Stell dir vor, du legst deinen Zeigefinger direkt auf den Sensor und schaltest die integrierte wei√üe LED an. Das Licht der LED trifft auf deinen Finger und wird reflektiert. Dein Finger sieht f√ºr dich immer gleich aus, aber tats√§chlich sorgt dein Herzschlag daf√ºr, dass dein Finger mal minimal heller und mal dunkler erscheint. Das liegt daran, dass Blut in rhythmischen Sch√ºben durch die Gef√§√üe gepumpt wird. Diese winzigen Ver√§nderungen, die du mit blo√üem Auge nicht sehen kannst, werden vom sensiblen Farbsensor deutlich wahrgenommen.\nSchauen wir uns das einmal genauer an: Wenn du dir die gemessene Lichtintensit√§t √ºber den Zeitverlauf im Brick Viewer ansiehst, kannst du deinen Pulsschlag tats√§chlich erkennen‚Äîer wird sichtbar als kleine, regelm√§√üige Ausschl√§ge oder Peaks. Faszinierend, oder? So kannst du beobachten, wie aus etwas so scheinbar Einfachem wie Licht ein Signal entsteht, das dir Informationen √ºber deinen K√∂rper liefert.\n\n\n\n\n\n\nAbbildung¬†9.1: Dein Puls im Brick Viewer",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#vom-diagramm-zur-zahl",
    "href": "signals.html#vom-diagramm-zur-zahl",
    "title": "9¬† Signale",
    "section": "9.2 Vom Diagramm zur Zahl",
    "text": "9.2 Vom Diagramm zur Zahl\nAuch wenn du das Signal im Liniendiagramm in Abbildung¬†9.1 bereits deutlich sehen kannst, bleibt eine spannende Herausforderung bestehen: Wie schreibst du ein Programm, das aus diesen Daten deinen Puls als konkrete Zahl, zum Beispiel ‚Äú60 Schl√§ge pro Minute‚Äù, berechnet? Genau daf√ºr sind wir ja hier ‚Äì um herauszufinden, wie man solche kniffligen Aufgaben l√∂st. Lass uns gemeinsam starten!\nZun√§chst m√ºssen wir den Farbsensor in unserem Python-Programm auslesen. Den notwendigen Code daf√ºr haben wir im vorherigen Kapitel 8 bereits kennengelernt.\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\n\n\n1\n\nAchtung: Vergiss nicht, hier deine eigene UID einzusetzen. Diese findest du im Brick Viewer.\n\n\n\n\nJetzt haben wir Zugriff auf die Funktionen des Sensors und k√∂nnen etwa die Lichtintensit√§t messen:\n\n1color_sensor.set_light(True)\n2color_sensor.set_configuration(1, 1)\nilluminance = color_sensor.get_illuminance()\n\n\n1\n\nSchaltet die integrierte LED des Sensors an.\n\n2\n\nStellt die Werte f√ºr Gain und Integration Time auf 4x und 24ms. Diese Einstellung scheinen gut zu funktionieren, um den Puls zu messen.\n\n\n\n\nDer zur√ºckgegebene Wert h√§ngt von zwei Einstellungen ab: Gain (Verst√§rkung) und Integration Time (Messzeit). Je l√§nger die Messzeit, desto genauer die Werte ‚Äì allerdings k√∂nnen dann weniger Messungen pro Sekunde durchgef√ºhrt werden. Laut Dokumentation k√∂nnen wir aus dem gemessenen Wert die Lichtintensit√§t in Lux wie folgt berechnen:\n\n1illuminance_lux = illuminance * 700 / 4 / 24\n\n\n1\n\nDer Wert 4 beschreibt ein 4-fache Verst√§rkung (Gain) und die 24 steht f√ºr 24ms Integration Time\n\n\n\n\nUm deinen Puls zu berechnen, m√ºssen wir jetzt mehrere Werte in kurzen Abst√§nden messen. Warum? Weil wir die regelm√§√üigen Tief- und Hochpunkte erkennen wollen. Ein Tiefpunkt entsteht, wenn dein Finger am dunkelsten ist ‚Äì hier ist also gerade besonders viel Blut im Finger. Die Hochpunkte markieren dagegen den Moment, in dem das Blut gr√∂√ütenteils wieder zur√ºckgeflossen ist. Jeder Herzschlag erzeugt genau einen Tief- und einen Hochpunkt. Finden wir diese Punkte, k√∂nnen wir einfach die Zeitabst√§nde messen und daraus die Pulsfrequenz berechnen.\nBeginnen wir damit, unsere Messungen in einer Schleife durchzuf√ºhren. Das ist eine praktische Methode, kontinuierlich Daten zu erfassen:\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n    print(f\"Lichtintensit√§t in Lux: {illuminance_lux}\")\n\nLass uns das Programm einmal ausprobieren. Es sieht aktuell so aus:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\ncolor_sensor.set_light(True)\ncolor_sensor.set_configuration(1, 1)\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n2    print(f\"Lichtintensit√§t in Lux: {illuminance_lux:.2f}  \", end=\"\\r\")\n\n\n1\n\nDenke daran, die UID durch die deines Sensors zu ersetzen.\n\n2\n\nDer Parameter end=\"\\r\" sorgt daf√ºr, dass nicht jede Ausgabe in eine neue Zeile geschrieben wird. Stattdessen wird immer an den Anfang der selben Zeile gesprungen. Das \\r ist das Symbol f√ºr Carriage Return.\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "protocols.html",
    "href": "protocols.html",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "protocols.html#setup",
    "href": "protocols.html#setup",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "encryption.html",
    "href": "encryption.html",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "encryption.html#setup",
    "href": "encryption.html#setup",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "algorithms.html",
    "href": "algorithms.html",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "algorithms.html#setup",
    "href": "algorithms.html#setup",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "compression.html",
    "href": "compression.html",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "compression.html#setup",
    "href": "compression.html#setup",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "computer.html",
    "href": "computer.html",
    "title": "14¬† Computer",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#logik-und-arithmetik",
    "href": "computer.html#logik-und-arithmetik",
    "title": "14¬† Computer",
    "section": "14.1 Logik und Arithmetik",
    "text": "14.1 Logik und Arithmetik\n\nLogikgatter\n8-Bit-Additionsmaschine\nSubtraktion, Division, Multiplikation",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#die-von-neumann-architektur",
    "href": "computer.html#die-von-neumann-architektur",
    "title": "14¬† Computer",
    "section": "14.2 Die von-Neumann-Architektur",
    "text": "14.2 Die von-Neumann-Architektur",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "href": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "title": "14¬† Computer",
    "section": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers",
    "text": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers\n\nx = 10\nprint(f\"Adresse im Speicher der Variable 'x': {hex(id(x))}\")\nx= 20\nprint(f\"Neue Adresse im Speicher der Variable 'x': {hex(id(x))}\")\n\nAdresse im Speicher der Variable 'x': 0x7ffe21637448\nNeue Adresse im Speicher der Variable 'x': 0x7ffe21637588\n\n\n\nnames = [\"Max\", \"Kim\", \"Hildegard\"]\nprint(f\"Adresse im Speicher der Variable 'names': {hex(id(names))}\")\nnames.append(\"Heinrich\")\nprint(f\"Die Adresse im Speicher der Variable 'names' bleibt identisch: {hex(id(names))}\")\n\nAdresse im Speicher der Variable 'names': 0x16f213b0500\nDie Adresse im Speicher der Variable 'names' bleibt identisch: 0x16f213b0500\n\n\n\n\n\n\n\n\nLeseempfehlung\n\n\n\nUm tiefer in die Themen dieses Kapitels einzusteigen, empfehle ich euch Petzold (2022) zu lesen . Es lohnt sich, das Buch von Vorne nach Hinten zu verschlingen.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "problems.html",
    "href": "problems.html",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "problems.html#setup",
    "href": "problems.html#setup",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Adami, Christoph. 2016. ‚ÄúWhat Is Information?‚Äù\nPhilosophical Transactions of the Royal Society A: Mathematical,\nPhysical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, and Dennis Brylow. 2020. Computer Science: An\nOverview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer\nHardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, and John Horton Conway. 2004. How to Solve It: A New\nAspect of Mathematical Method. Expanded Princeton Science Library\ned. Princeton Science Library. Princeton [N.J.]: Princeton University\nPress.\n\n\nScott, John C. 2009. But How Do It Know?: The Basic Principles of\nComputers for Everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]