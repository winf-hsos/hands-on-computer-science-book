[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Computer Science",
    "section": "",
    "text": "Vorwort\nGl√ºckwunsch ‚Äì du bist angekommen! Wie auch immer dein Weg hierher aussah, du hast es geschafft, dieses Buch zu √∂ffnen. Vielleicht bist du Student oder Studentin an der Hochschule Osnabr√ºck und wurdest (zu deinem Gl√ºck) gezwungen, oder du bist ganz bewusst hier gelandet und freust dich darauf, etwas Neues zu lernen ‚Äì genau wie ich.\nDieses Buch entstand urspr√ºnglich, um meinen Veranstaltungen an der Hochschule Osnabr√ºck eine verst√§ndliche und praxisnahe Grundlage zu geben. Es dient als Hauptlekt√ºre f√ºr meine Vorlesungen, aber auch als Nachschlagewerk f√ºr alle, die vielleicht mal eine Sitzung verpasst haben oder Themen eigenst√§ndig vertiefen wollen. Besonders willkommen sind dabei Quereinsteiger, Wiederholer oder einfach neugierige Menschen, die bisher noch gar keinen Kontakt mit der Hochschule Osnabr√ºck hatten.\nHier bekommst du keine trockene Theorie pr√§sentiert, sondern eine spannende, praxisnahe Einf√ºhrung in die Grundlagen moderner Computer und unserer digitalen Welt. Das Fach, das sich dahinter verbirgt, hei√üt auf Deutsch Informatik, international auch bekannt als Computer Science. Der Titel Hands-On Computer Science verr√§t bereits: Hier wird es praktisch ‚Äì und zwar von Anfang an.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#was-macht-dieses-buch-besonders",
    "href": "index.html#was-macht-dieses-buch-besonders",
    "title": "Hands-On Computer Science",
    "section": "Was macht dieses Buch besonders?",
    "text": "Was macht dieses Buch besonders?\nLehrb√ºcher zur Informatik gibt es reichlich. Viele davon sind gro√üartig, aber kaum eines passt perfekt zu dem, was ich mit meinen Studierenden vorhabe. Woran liegt das?\nViele klassische Informatikb√ºcher versuchen, das gesamte Fachgebiet m√∂glichst umfassend abzubilden. Das ist sinnvoll f√ºr angehende Informatiker, aber meine Zielgruppe bist du: Studierende in Studieng√§ngen wie Management nachhaltiger Ern√§hrungssysteme, Lebensmittelproduktion oder kAgrarsystemtechnologien ‚Äì oder vielleicht bist du nicht mal Student oder Studentin, sondern einfach interessiert daran, endlich Zugang zur digitalen Welt zu finden.\nKurz gesagt: Dieses Buch ist f√ºr jeden gedacht, der Lust hat, in die digitale Welt einzutauchen, ohne sich gleich mit komplizierten Details zu √ºberfordern. Daf√ºr brauchst du kein allumfassendes Nachschlagewerk, sondern einen klaren roten Faden, der dich Schritt f√ºr Schritt an die grundlegenden Konzepte heranf√ºhrt.\nViele B√ºcher versprechen Praxisn√§he, doch oft endet diese in n√ºchternen √úbungsaufgaben am Kapitelende. Genau hier setzt Hands-On Computer Science an und macht zwei Dinge anders:\n\nDu lernst informatische Konzepte direkt anhand spannender Projekte mit Hardware wie Microcontrollern, Sensoren, Buttons, LEDs und Displays kennen.\nDu arbeitest kontinuierlich am LiFi-Projekt, das dich durch alle Kapitel begleitet und dabei immer weiter w√§chst.\nTheorie und Praxis sind nicht getrennt, sondern eng miteinander verbunden ‚Äì Programmieren und informatische Grundlagen lernst du gleichzeitig.\n\nSchon ab Kapitel 1 beginnst du zu programmieren und zwar nicht abstrakt, sondern konkret mit Bauteilen wie Buttons. Im Laufe des Buches lernst du Schritt f√ºr Schritt neue Hardware-Komponenten kennen, die immer direkt mit relevanten informatischen Konzepten verkn√ºpft sind. So schlie√üt du am Ende nicht nur das LiFi-Projekt erfolgreich ab, sondern verf√ºgst fast nebenbei √ºber ein solides Fundament in der Informatik. Wenn alles gut l√§uft, merkst du kaum, wie schnell du gelernt hast.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#tipps-f√ºr-die-lekt√ºre",
    "href": "index.html#tipps-f√ºr-die-lekt√ºre",
    "title": "Hands-On Computer Science",
    "section": "Tipps f√ºr die Lekt√ºre",
    "text": "Tipps f√ºr die Lekt√ºre\nWeil es in diesem Buch viel ums Programmieren geht, findest du nat√ºrlich viele Codebl√∂cke. Als Einstiegssprache verwenden wir Python. Warum ausgerechnet Python? Das erf√§hrst du sp√§ter genauer.\nCodebl√∂cke sind deutlich sichtbar vom √ºbrigen Text abgehoben, meist grau hinterlegt und in einer Schreibmaschinenschrift dargestellt, etwa Courier New oder Consolas. Hier ein kleines Beispiel:\n1led.set_rgb_value(0, 0, 0)\n2led.set_rgb_value(255, 255, 255)\n\nprint(\"Diese Zeile hat keine Annotation\")\n\n3# Lasse die LED blau aufleuchten\nled.set_rgb_value(0, 0, 255)\n\n1\n\nSchaltet die LED aus, weil der RGB-Code (0,0,0) schwarz erzeugt.\n\n2\n\nSchaltet die LED auf wei√ües Licht, weil drei Mal die 255 die Farbe Wei√ü ergibt.\n\n3\n\nAuch Kommentare sind f√ºr kurze Erl√§uterungen n√ºtzlich.\n\n\nKommentare sind mit einer kleinen Zahl versehen. Wenn du die Online-Version nutzt und mit der Maus √ºber diese Zahl f√§hrst, erscheint ein Tooltip, der die Codezeile erkl√§rt. Das funktioniert nur online, nicht in PDF oder Druckversion.\nNoch ein kleiner Tipp: Wenn du mit der Maus √ºber den Codeblock f√§hrst, siehst du rechts oben ein Clipboard-Symbol. Ein Klick darauf kopiert den Code direkt in deine Zwischenablage, und du kannst ihn problemlos in dein ge√∂ffnetes Visual Studio Code oder eine andere IDE einf√ºgen und ausprobieren.\nAlle Codebeispiele findest du au√üerdem im GitHub-Repository, das zu diesem Buch geh√∂rt.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "experiments.html",
    "href": "experiments.html",
    "title": "Experimente",
    "section": "",
    "text": "Hands-On Programmieren lernen\nHast du dich schon einmal gefragt, wie man Informationen √ºber Licht √ºbertragen kann? Oder wie man mit Licht den Puls messen kann? Oder wie man mit zwei einfachen Kabeln einen Wasserstandssensor baut? Das alles klingt vielleicht weit hergeholt, ist aber tats√§chlich machbar ‚Äì und wie genau, das wollen wir in diesem Buch herausfinden! Dabei werden wir nicht nur die digitale Welt der Computer und Programmierung kennenlernen, sondern auch mit spannenden Ger√§ten in der analogen Welt arbeiten. In jedem Kapitel arbeiten wir mit anderen Ger√§ten, die dir unterschiedliche Facetten der digitalen Welt n√§herbringen und gleichzeitig erm√∂glichen, das Programmieren spielerisch zu erlernen.\nHier ein √úberblick √ºber die Ger√§te, mit denen wir gemeinsam experimentieren werden. Zusammengefasst kosten alle Komponenten 249 ‚Ç¨. Aber keine Sorge: Wenn du das Buch im Rahmen meines Moduls ‚ÄûDigitalisierung und Programmierung‚Äú an der Hochschule Osnabr√ºck liest, erh√§ltst du f√ºr das gesamte Semester ein komplettes Hardware-Kit.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#hands-on-programmieren-lernen",
    "href": "experiments.html#hands-on-programmieren-lernen",
    "title": "Experimente",
    "section": "",
    "text": "Abbildung¬†1: Tinkerforge Workbench mit vielen Ger√§ten\n\n\n\n\n\n\n\nWas?\nBauteil\nAnzahl\nPreis pro St√ºck\n\n\n\n\nBunte LED\nRGB LED Bricklet 2.0\n1\n8 ‚Ç¨\n\n\nButton mit integrierter, bunter LED\nRGB LED Button Bricklet\n1\n15 ‚Ç¨\n\n\nLicht- und Farbsensor\nColor Bricklet 2.0\n1\n17 ‚Ç¨\n\n\nLCD Touchdisplay\nLCD 128x64 Bricklet\n1\n33 ‚Ç¨\n\n\nPiezo Lautsprecher\nPiezo Speaker Bricklet 2.0\n1\n19 ‚Ç¨\n\n\nInfrarot-Entfernungsmesser\nDistance IR 4-30cm Bricklet 2.0\n1\n20 ‚Ç¨\n\n\nAnaloger Spannungssensor\nAnalog In Bricklet 3.0\n1\n14 ‚Ç¨\n\n\nSchalldruckpegelsenor\nSound Pressure Level Bricklet\n1\n35 ‚Ç¨\n\n\nMikrocontroller\nMaster Brick 3.2\n2\n35 ‚Ç¨\n\n\nAnschlusskabel 15 cm\nBricklet Kabel 15cm (7p-7p)\n8\n1 ‚Ç¨\n\n\nUSB-A- auf USB-C Kabel\nUSB-A auf USB-C Kabel 100 cm\n1\n6 ‚Ç¨\n\n\nMontageplatte\nMontageplatte 22x22 (12x12cm)\n2\n7 ‚Ç¨\n\n\nSchrauben, Abstandshalter und Muttern\nBefestigungskit 12mm\n4\n2 ‚Ç¨",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#spannende-experimente",
    "href": "experiments.html#spannende-experimente",
    "title": "Experimente",
    "section": "Spannende Experimente",
    "text": "Spannende Experimente\nKapitel f√ºr Kapitel werden wir an unterschiedlichen Experimenten arbeiten. Dabei lernst du nicht nur, wie man Hardware-Komponenten miteinander verbindet, sondern vor allem auch, wie man Computer ‚Äì diese universellen Probleml√∂sungsmaschinen ‚Äì f√ºr eigene Ideen und L√∂sungen programmieren kann. Hier ist der √úberblick, was dich in diesem Buch erwartet:\n\n\n\n\n\n\n\nKapitel\nExperiment(e)\n\n\n\n\n1¬† Farben üåà\nWir lassen eine LED einen Regenbogenfarbverlauf √ºber die Zeit erzeugen.\n\n\n3¬† Texte\nWir lernen, wie man Texte umst√§ndlich und ohne Tastatur eingeben kann ‚Äì √ºber Handgesten.\n\n\n4¬† Bilder\nWir verbinden Tabellenkalkulation mit Bildern und Touchdisplays ü§Ø\n\n\n5¬† Codes\nWir lernen Morse-Code und wie wir diesen √ºber einen Lautsprecher ausgeben k√∂nnen.\n\n\n6¬† Umwandlung\nWir verwenden einfache Kippschalter, um analoge Werte in digitale Werte umzuwandeln.\n\n\n7¬† Information\n\n\n\n8¬† Sensoren\nWir bauen einen Wasserstandssensor mit einem analogen Spannungssensor.\n\n\n9¬† Signale\nWir basteln einen Pulsmesser aus einem Farbsensor üíì\n\n\n10¬† Protokolle\nWir √ºbertragen Nachrichten √ºber Lichtsignale üî¶\n\n\n11¬† Verschl√ºsselung\nWir verstecken geheime Botschaften in harmlosen Nachrichten üïµÔ∏è‚Äç‚ôÄÔ∏è\n\n\n12¬† Algorithmen\n\n\n\n13¬† Kompression\nWir entwickeln ein Verfahren, um Information zu komprimieren.\n\n\n14¬† Computer\nWir entwickeln eine Rechenmaschine, die zwei Bytes addieren kann, mit nur einem einem Bauteil.\n\n\n15¬† Probleme",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "href": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "title": "Experimente",
    "section": "Frust ist dein Freund ‚Äì zumindest ein bisschen",
    "text": "Frust ist dein Freund ‚Äì zumindest ein bisschen\nEins m√∂chte ich gleich vorwegnehmen: Beim Programmierenlernen ist eine gewisse Portion Frust unvermeidbar. Klingt unangenehm? Ist es auch! Aber es ist zugleich Teil eines enorm wertvollen Lernprozesses. Jeder Fehler, den du machst, ist eine Gelegenheit, um zu verstehen, wie Computer wirklich funktionieren ‚Äì n√§mlich absolut pr√§zise und ohne jede Toleranz f√ºr Fehler.\nComputer sind gnadenlose Lehrer. Sie zeigen dir sofort und unerbittlich, wenn etwas nicht stimmt ‚Äì sei es ein vergessener Punkt, ein falscher Buchstabe oder ein simpler Zahlendreher. Das kann frustrieren, aber genau dieses direkte und sofortige Feedback hilft dir auch, schnell und effektiv zu lernen. Sobald du verstehst, wie du aus Fehlermeldungen sinnvolle Schl√ºsse ziehst und deine Programme entsprechend korrigierst, wirst du belohnt ‚Äì mit Erfolgserlebnissen und einer steilen Lernkurve.\n\n\n\n\n\n\nAbbildung¬†2: Ein frustrierter Frosch\n\n\n\nAlso, wenn mal etwas nicht klappt: Nimm es nicht pers√∂nlich, sondern sieh es als Herausforderung. Atme tief durch, mach dir klar, dass Fehler unvermeidbar und sogar wichtig sind, und probier es noch einmal. Ich verspreche dir: Es lohnt sich!\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "colors.html",
    "href": "colors.html",
    "title": "1¬† Farben üåà",
    "section": "",
    "text": "Setup\nBereit f√ºr dein erstes Hardware-Experiment? Perfekt! Du brauchst daf√ºr eine LED (RGB LED Bricklet 2.0) und einen Mikrocontroller (Master Brick 3.2). Befestige beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in Abbildung¬†1.1 gezeigt. Zwei Schrauben pro Ger√§t reichen v√∂llig. Denk an die kleinen, wei√üen Unterlegscheiben aus Kunststoff. Sie sch√ºtzen deine Platinen vor Druckstellen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#setup",
    "href": "colors.html#setup",
    "title": "1¬† Farben üåà",
    "section": "",
    "text": "(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Nahaufnahme der LED.\n\n\n\n\n\n\n\n\n\n\n\n(c) Montageplatte mit allen Komponenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Untenansicht.\n\n\n\n\n\n\n\n\n\n\n\n(e) Ansicht der vier Steckpl√§tze.\n\n\n\n\n\n\n\nAbbildung¬†1.1: Einfaches Setup mit einem Mikrocontroller und einer LED.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#erste-schritte-mit-dem-brick-viewer",
    "href": "colors.html#erste-schritte-mit-dem-brick-viewer",
    "title": "1¬† Farben üåà",
    "section": "1.1 Erste Schritte mit dem Brick Viewer",
    "text": "1.1 Erste Schritte mit dem Brick Viewer\nIm ersten Schritt wollen wir die LED und ihre Funktionen testen! Das geht ganz leicht mit dem Brick Viewer. Schlie√üe zuerst den Master Brick √ºber das USB-Kabel an deinen Computer an und √∂ffne den Brick Viewer. Klicke dann auf den Connect-Button.\n\n\n\n\n\n\nAbbildung¬†1.2: √úber den Connect-Button verbindet sich der Brick Viewer mit dem angeschlossenen Master Brick.\n\n\n\nWenn alles geklappt hat, zeigt dir der Brick Viewer alle angeschlossenen Ger√§te in Tabs an. Schau dir Abbildung¬†1.3 an ‚Äì so etwa sollte es aussehen.\n\n\n\n\n\n\nAbbildung¬†1.3: Der Brick Viewer nachdem ihr mit dem Master Brick verbunden seid.\n\n\n\nWechsle nun zum Tab der RGB LED. Hier kannst du √ºber unterschiedliche Wege die Farbe der LED einstellen. Mehr kann eine LED nicht!\nMit den drei Schiebereglern steuerst du die einzelnen Farbkan√§le ‚Äì Rot, Gr√ºn, Blau. Der Wertebereich: 0 bis 255. Warum gerade diese die Farben und Zahlen? Gute Frage. Die Antwort kommt weiter unten.\n\n\n\n\n\n\nAbbildung¬†1.4: Die Ansicht f√ºr den RGB LED Button im Brick Viewer, in der alle Funktionen per Klick im Zugriff sind.\n\n\n\nFazit: Der Brick Viewer ist top zum Rumprobieren. Aber wenn du echte Projekte umsetzen willst, musst du programmieren lernen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#unser-erstes-programm",
    "href": "colors.html#unser-erstes-programm",
    "title": "1¬† Farben üåà",
    "section": "1.2 Unser erstes Programm",
    "text": "1.2 Unser erstes Programm\nWie verbinden wir uns √ºber Programm mit der LED und setzen ihre Farbe? Die Antwort darauf findest du im folgenden kurzen Codebeispiel.\n\n\n\n\nListing¬†1.1: Der Boilerplate-Code f√ºr die Verbindung mit den Ger√§ten am Beispiel des Buttons.\n\n\n1from tinkerforge.ip_connection import IPConnection\n2from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\n3ipcon = IPConnection()\n4ipcon.connect(\"localhost\", 4223)\n5led = BrickletRGBLEDV2(\"ZEP\", ipcon)\n\n\n\n\n\n1\n\nHier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.\n\n2\n\nHier importieren wir ein weietres Objekt, das wir zur Darstellung der LED als Python-Objekt ben√∂tigen.\n\n3\n\nDie Verbindung erfolgt √ºber eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.\n\n4\n\nMit connect stellen wir eine Verbindung zum angeschlossenen Master Brick her.\n\n5\n\nSchlie√ülich holen wir uns eine virtuelle Instanz des RGB LED Bricklets, indem wir die UID nennen und sagen, welche Verbindung (ipcon) genutzt werden soll.\n\n\n\n\n\n1.2.1 Programme\nZun√§chst kl√§ren wir den Begriff Programm. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausf√ºhrt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm sp√§ter daf√ºr zust√§ndig, mit der LED zu interagieren und sie in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns erm√∂glichen, dem Computer pr√§zise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut f√ºr Einsteiger eignet und gleichzeitig m√§chtig genug ist, um komplexe Aufgaben zu l√∂sen.\nWenn wir ein Programm ausf√ºhren, arbeitet der Computer die Anweisungen Schritt f√ºr Schritt von oben nach unten ab. Die Nummerierung der Zeilen verdeutlicht das sehr sch√∂n. Der Computer beginnt bei Zeile 1 und arbeitet die Befehle Zeile f√ºr Zeile bis nach unten ab.\nEs gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir sp√§ter kennen.\n\n\n1.2.2 Boilerplate Code\nDer Codeauschnitt in Listing¬†1.1 wird uns im Verlauf dieses Buches immer wieder begegnen. Wir ben√∂tigen ihn, um uns am Anfang des Programms mit den Ger√§ten zu verbinden, die wir f√ºr unsere Anwendung ben√∂tigen. In der Informatik nennen wir solchen Code, den wir h√§ufig in der gleichen Form ben√∂tigen und fast eins zu eins kopieren k√∂nnen, auch Boilerplate-Code. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.\n\n\n1.2.3 Bibliotheken\nBeginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr √§hnliche Befehle, die mit dem Schl√ºsselwort from beginnen. Nach dem Schl√ºsselwort from folgt der Name einer Bibliothek, aus der wir ein f√ºr unser Programm ben√∂tigtes Objekte importieren. Die Kombination der Schl√ºsselw√∂rter from ...import l√§sst sich also w√∂rtlich √ºbersetzen: ‚ÄúAus der Bibliothek X importiere das Objekt Y‚Äù.\nEine Bibliothek in einer Programmiersprache ist die B√ºndelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek kannst du dir vorstellen wie einen Werkzeugkasten: Sie enth√§lt fertige Werkzeuge (Funktionen und Klassen), damit du nicht alles von Grund auf selbst programmiern musst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Ger√§ten loslegen k√∂nnen. F√ºr jedes Ger√§t gibt es in der Tinkerforge-Bibliothek eine eigene Klasse, √ºber die wir auf die Funktionen jedes Ger√§ts zugreifen k√∂nnen.\n\n\n1.2.4 Klassen und Objekte\nMit from ... import importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit importieren ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge sp√§ter wirklich nutzen steht auf einem anderen Blatt.\nIn dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ank√ºndigen. Die erste Klasse heisst IPConnection und die zweite BrickletRGBLEDButton. Der Begriff Klasse ist hier analog zum Begriff Kategorie zu verstehen. Wir k√∂nnen zu einer Klasse geh√∂rige Objekte erzeugen, und alle Objekte der selben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.\nStellt euch vor, ihr habt eine Klasse namens Auto. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa fahren(), bremsen() oder tanken(). Diese Dinge sollen f√ºr jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Du kannst also sagen: ‚ÄúMein Auto ist ein Objekt der Klasse Auto.‚Äù Jedes Auto hat neben den Funktionen die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte f√ºr diese Eigenschaftan haben.\nGenauso verh√§lt es sich mit den Klassen, die Tinkerforge f√ºr uns bereitgestellt hat. Die Klasse IPConnection beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen k√∂nnen, und die Klasse BrickletRGBLEDV2 beschreibt, wie wir mit der LED interagieren k√∂nnen. Wenn wir ein Objekt dieser Klasse erstellen, k√∂nnen wir alle Funktionen nutzen, die in der Klasse definiert sind. Eine LED muss nicht fahren oder bremsen wie ein Auto. Daf√ºr hat sie andere Funktionen, wie etwa set_color(), die uns erlaubt, die Farbe der LED zu √§ndern. Eine Eigenschaft jeder LED ist ihre UID, die eindeutig ist und uns hilft, sie im System zu identifizieren.\n\n\n1.2.5 Schl√ºsselw√∂rter\nSoeben haben wir mit from und import unsere ersten beiden Schl√ºsselw√∂rter in Python kennengelernt! Aber was bedeutet das genau? Ein Schl√ºsselwort, das wir im Englischen auch keyword oder reserved keyword nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch h√§ufig Namen vergeben m√ºssen, etwa f√ºr Variablen oder Funktionen. Diese Namen d√ºrfen nicht wie ein Schl√ºsselwort lauten, ansonsten funktioniert unser Programm nicht wie gew√ºnscht. Welche Schl√ºsselw√∂rter es in Python gibt, k√∂nnt ihr hier nachschauen.\nIm Codeausschnitt oben laden wir zuerst das Objekt f√ºr die Verbindung zum angeschlossenen Mikrocontroller, die √ºber eine IP-Verbindung hergestellt wird. Was das genau ist? Sp√§ter mehr dazu. Zus√§tzlich zur IPConnection laden wir anschlie√üend noch die ben√∂tigen Klassen f√ºr die Ger√§te, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur die LED, in sp√§teren Experimenten werden es auch mal mehrere Ger√§te sein.\n\n\n1.2.6 Objekte erzeugen\nIn Listing¬†1.1 in Zeile 4 erzeugen wir ein Objekt der Klasse IPConnection. Die fertige Instanz - so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde - speichern wir auf einer Variable mit dem Namen ipcon. Diesen Namen haben wir uns selbst ausgedacht, damit wir sp√§ter darauf zugreifen k√∂nnen. Wir h√§tten auch einen anderen Namen w√§hlen k√∂nnen.Eine Variable ist also ein Platzhalter f√ºr einen Wert, den wir sp√§ter im Programm verwenden wollen. In diesem Fall ist ipcon der Platzhalter f√ºr die Verbindung zu unserem Mikrocontroller. Was eine Variable technisch ist, lernen wir sp√§ter noch genauer kennen.\n\n\n1.2.7 Methoden\n√úber das Objekt ipcon k√∂nnen wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode connect(). Eine Methode ist eine Funktion, die zu einem Objekt geh√∂rt. Wie etwa fahren() oder bremsen() in unserem Auto-Beispiel.\nWir k√∂nnen Methoden aufrufen, um eine bestimmte Aktion auszuf√ºhren. In diesem Fall stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, √ºber den die Verbindung hergestellt werden soll. In unserem Fall ist das ‚Äúlocalhost‚Äù, was f√ºr die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standarm√§√üig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt . nach dem Objekt, gefolgt vom Namen der Methode und den Klammern (), in denen wir eventuell ben√∂tigte Parameter angeben.\nEine Methode ist letztlich eine Funktion, die zu einem Objekt geh√∂rt. Zu einem sp√§teren Zeitpunkt schreiben wir unsere eigenen Funktionen und lernen dann noch viel mehr dar√ºber.\n\n\n1.2.8 Ein Objekt f√ºr die LED\nIn Zeile 6 erzeugen wir schlie√ülich ein Objekt der Klasse BrickletRGBLEDV2. Dieses Objekt repr√§sentiert unsere LED und erm√∂glicht es uns, mit ihr zu interagieren. Wir nennen das Objekt led, was kurz und klar ist. Auch hier haben wir uns den Namen selbst ausgedacht, um sp√§ter darauf zugreifen zu k√∂nnen. Auch wenn wir grunds√§tzlich Variablennamen frei w√§hlen k√∂nnen, sollten sie immer so gew√§hlt werden, dass sie den Inhalt der Variable beschreiben. Das macht es sp√§ter einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten m√ºssen. Dazu geh√∂ren etwa, dass Variablennamen nicht mit einer Zahl beginnen d√ºrfen und keine Leerzeichen enthalten d√ºrfen. Eine ausf√ºhrliche Liste der Regeln findest du hier.\n\n\n1.2.9 Zusammenfassung unseres ersten Programms\nDamit haben wir unser erstes Programm von oben nach unten erl√§utert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:\n\n\n\n\n\n\n\nProgramme\nAbfolge von Anweisungen, die nacheinander ausgef√ºhrt werden.\n\n\nBoilerplate Code\nStandard-Code, den man immer wieder braucht.\n\n\nImportieren von Bibliotheken\nSammlung von fertigen Code-Elementen.\n\n\nSchl√ºsselw√∂rter\nReservierte Begriffe der Programmiersprache.\n\n\nKlassen und Objekte\nKategorien und deren konkrete Instanzen.\n\n\nMethoden und Funktionen\nFunktionen, die zu einem Objekt geh√∂ren.\n\n\nVariablen\nPlatzhalter f√ºr Werte.\n\n\n\n\n\n1.2.10 Und jetzt?\nWir haben nun eine digitale Repr√§sentation unserer LED in Python. Wir k√∂nnen die LED jetzt zum Leuchten bringen, indem wir eine Methode der Klasse BrickletRGBLEDV2, die set_color() hei√üt, verwenden. Diese Methode erwartet drei Parameter: Rot, Gr√ºn und Blau. Mit diesen Parametern k√∂nnen wir die Farbe der LED einstellen.\n\n1led.set_color(0, 255, 0)\n\n\n1\n\nSetzt die LED auf gr√ºn. R = 0, G = 255, B = 0. Logisch, oder?\n\n\n\n\nMoment mal ‚Ä¶ Wo steht hier eigentlich gr√ºn? Steht da gar nicht. Stattdessen drei Zahlen. Willkommen bei der RGB-Farbkodierung. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Gr√ºn, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Wei√ü. Nur Gr√ºn auf 255? Na klar: gr√ºn.\nAber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie √ºbersetzen wir die Welt in etwas, das ein Computer versteht?\nWarum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit drei Zahlen? Warum √ºberhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?\nVorher m√ºssen wir aber kurz zur√ºck in die Schule.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#farben-und-licht",
    "href": "colors.html#farben-und-licht",
    "title": "1¬† Farben üåà",
    "section": "1.3 Farben und Licht",
    "text": "1.3 Farben und Licht\nPhysik ist vielleicht schon eine Weile her. Erinnern wir uns dennoch kurz, was Licht ist und wie Farben damit zusammenh√§ngen. Licht ist elektromagnetische Strahlung. Das bedeutet, es handelt sich um gekoppelte Schwingungen elektrischer und magnetischer Felder, die sich mit Lichtgeschwindigkeit ausbreiten. Vereinfacht k√∂nnen wir uns Licht als Wellen vorstellen, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenl√§ngen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen √ºber Infrarotstrahlung bis hin zu R√∂ntgenstrahlen und Gammastrahlen reicht.\nBei Wellen unterscheiden wir zwischen der Frequenz (wie oft die Welle pro Sekunde schwingt) und der Wellenl√§nge (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenl√§nge sind umgekehrt proportional: Je h√∂her die Frequenz, desto k√ºrzer die Wellenl√§nge und umgekehrt.\nFrequenzen messen wir in Hertz (Hz), wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenl√§ngen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) f√ºr violettes Licht und etwa 700 nm f√ºr rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abst√§nde zwischen den Wellenl√§ngen des sichtbaren Lichts sind also extrem klein.\nWas bedeutet das nun f√ºr eine LED? Eine LED (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchflie√üt. Die Farbe des Lichts h√§ngt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenl√§ngen, was zu verschiedenen Farben f√ºhrt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenl√§nge von etwa 620-750 nm, w√§hrend eine gr√ºne LED Licht mit einer Wellenl√§nge von etwa 495-570 nm emittiert.\n\n\n\n\n\n\nAbbildung¬†1.5: Das elektromagnetische Spektrum, wovon das sichtbare Licht ein kleiner Teil ist. (Quelle: Wikipedia)\n\n\n\nDie RGB LEDs, die in unserem Button verbaut ist, besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer gr√ºnen und einer blauen. Jede dieser LEDs kann unabh√§ngig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Spannung bedeutet mehr Intensit√§t der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Gr√ºn und Blau in unterschiedlichen Intensit√§ten k√∂nnen wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensit√§t leuchten lassen, erhalten wir Wei√ü. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LED sind dann alle aus.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#farben-im-computer",
    "href": "colors.html#farben-im-computer",
    "title": "1¬† Farben üåà",
    "section": "1.4 Farben im Computer",
    "text": "1.4 Farben im Computer\nNun wissen wir, warum die Methode set_color() drei Parameter erwartet: Rot, Gr√ºn und Blau. Diese Parameter sind die Intensit√§ten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 k√∂nnen wir jede Farbe im sichtbaren Spektrum erzeugen.\nWie kommt es aber zu der merkw√ºrdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grunds√§tzlich Werte speichert und wie dieser Speicher organisiert ist. Kurz gesagt: Der Wertebereich 0 bis 255 passt genau in ein sogenanntes Byte. Ein Byte ist eine Speichereinheit, die aus 8 Bits besteht. Ein Bit kann entweder 0 oder 1 sein. Mit 8 Bits k√∂nnen wir also \\(2^8 = 256\\) verschiedene Werte darstellen, von 0 bis 255. Das ist genau der Bereich, den wir f√ºr die RGB-Farbkodierung verwenden. Dazu lernen wir sp√§ter noch mehr.\nWir halten also fest, dass sich ein Farbwert im Computer aus drei Zahlen zusammensetzt, die jeweils zwischen 0 und 255 liegen. Das gilt f√ºr unsere LED, aber auch f√ºr Pixel in TVs, Smartphones, digitalen Foto oder Monitoren. All diese Dinge beleuchten wir sp√§ter noch genauer.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#farben-mischen",
    "href": "colors.html#farben-mischen",
    "title": "1¬† Farben üåà",
    "section": "1.5 Farben mischen",
    "text": "1.5 Farben mischen\nKlingt alles theoretisch sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus und mischen zwei Farben mit voller Intensit√§t!\n\nbtn.set_color(255, 255, 0)\n\nWas macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!\n\n1.5.1 Additive Farbmischung\nIhr solltet alle euren Button in Gelb aufleuchten sehen. In der additiven Farbmischung mischen wir Rot und Gr√ºn und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Gr√ºn, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensit√§t leuchten lassen, erhalten wir eine neue Farbe, die stest heller ist als die Ursprungsfarben. Wir f√ºgen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensit√§t mischen erhalten wir schlie√ülich Wei√ü.\n\nled.set_color(255, 255, 255)\n\nAm anderen Ende des Spektrums erzeugen drei Nullen die Farbe Schwarz:\n\nled.set_color(0, 0, 0)\n\n\n\n1.5.2 Subtraktive Farbmischung\nIhr k√∂nnt euch merken, dass wir im Kontext von Computern oft von additiver Farbmischung sprechen, weil Bildschirme Licht erzeugen. Durch das Mischen der drei Farbkan√§le entstehen neue Farben gem√§√ü der additiven Farbmischung, also stets heller als ihre Grundfarben. Daneben gibt es aber noch die subtraktive Farbmischung. Sie funktioniert anders, n√§mlich genau umgekehrt. Statt beim Mischen Licht hinzuzuf√ºgen, nehmen wir Licht weg.\nErinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbenkasten die Mischung aus Rot und Gr√ºn ergeben? Sicher nicht Gelb - eher Braun. Eine dunklere Farbe. Das liegt daran, dass wir es hier nicht mit additiver, sondern mit subtraktiver Farbmischung zu tun haben. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht absorbieren und reflektieren. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtsprektrums werden nicht mehr refklektiert, sondern absorbiert und sind damit nicht mehr sichtbar. Das Ergebnis einer Mischung zweier Farben ergibt in der subtraktiven Farbmischung also stets eine dunklere Farbe. Genau umgekehrt zur additiven Farbmischung.\nWas passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, n√§mlich W√§rme. Deshalb wird eine schwarze Oberfl√§che auch besonders hei√ü, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspekturm und wandelt es in W√§re um. Dagegen wirken wei√üe Oberfl√§chen fast wie Klimaanlagen. Es ist kein Zufall, dass wir in sonnigen Erdteilen viele wei√üe Fassaden sehen.\nWenn wir alle Farben mischen ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zur√ºck. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen kombinieren, um neue Farben zu erhalten.\n\n\n\n\n\n\n\n\n\n\n\n(a) Additive Farbmischung\n\n\n\n\n\n\n\n\n\n\n\n(b) Subtraktive Farbmischung\n\n\n\n\n\n\n\nAbbildung¬†1.6: Additive und subtraktive Farbmischung.\n\n\n\nIn Abbildung¬†1.6 sehen wir die beiden Farbmischungsarten im Vergleich. In Abbildung¬†1.6 (b) sehen wir die drei Grundfarben, die wir bei der subtraktiven Variante ben√∂tigen, um daraus alle weiteren Farben zu erhalten. Das sind Cyan, Magenta sowie Gelb. Im Englischen ist die Abk√ºrzung CMY, wo das ‚ÄúY‚Äù f√ºr Yellow steht. In der additiven Farbmischung sind es, wie oben schon gesehen, Rot, Gr√ºn und Blau. Wenn ihr Abbildung¬†1.6 (a) betrachtet dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der additiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?\nIn der additiven Farbmischung entsteht Gelb durch das Mischen von Rot und Gr√ºn, wobei Blau fehlt. Im Umkehrschluss bedeutet das: Gelbes Licht enth√§lt keine blaue Komponente, es reflektiert also kein Blau. In der subtraktiven Farbmischung (wie beim Farbkasten) wird Gelb erzeugt, indem Blau aus wei√üem Licht herausgefiltert wird ‚Äì Gelb reflektiert also kein Blau, sondern absorbiert es. Gelb kann also auch als Blaufilter gesehen werden. Das erkl√§rt, warum ein gelber Gegenstand unter blauem Licht dunkel erscheint: Er kann das blaue Licht nicht reflektieren.\nJetzt k√∂nnen wir auch erkl√§ren, warum Farbdrucker vier unterschiedliche Kartuschen ben√∂tigen (Abbildung¬†1.7). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb k√∂nnen wir jede beliebige Farbe mischen. Zus√§tzlich haben Drucker eine Kartusche f√ºr Schwarz, um erstens ein sattes Schwarz drucken zu k√∂nnen und zweitens die Farbkartuschen zu schonen. Denn schlie√ülich m√ºssen alle drei Farben gemmischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen schwarz enthalten (oder sogar ausschlie√ülich) ist eine schwarze Kartusche einfach effizienter. Die Farbe Schwarz wird bei Druckerkartuschen als Key bezeichnet und mit ‚ÄúK‚Äù abgek√ºrzt. Wir sprechen daher auch von CMYK.\n\n\n\n\n\n\nAbbildung¬†1.7: Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.\n\n\n\nFarben spielen eine so wichtige Rolle bei der Arbeit mit Computern. Deshalb lohnt es sich, ein wenig √ºber die Hintergr√ºnde von Farben und deren Mischung zu verstehen. Wir werden sp√§ter noch lernen, wie Bildschirme Farben darstellen. Sp√§testens dann wird uns das Thema der Farbmischung wieder begegnen.\nAb jetzt wollen wir weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, praxisnah verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED √ºber die Methode set_color() ver√§ndern k√∂nnen, wenn wir wissen, welcher RGB-Code unsere gew√ºnschte Farbe repr√§sentier. Da wir jetzt mehr √ºber die Farbmischung wissen, k√∂nnen wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:\n\nbtn.set_color(255, 0, 255)\n\nGem√§√ü der Theorie der additiven Farbmischung (Abbildung¬†1.6 (a)) m√ºsste Rot und Blau Magenta ergeben. Probiert es aus!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#schleifen",
    "href": "colors.html#schleifen",
    "title": "1¬† Farben üåà",
    "section": "1.6 Schleifen",
    "text": "1.6 Schleifen\nDas deklarierte Ziel unseres ersten Experiments ist es, einen Regenbogebenfarbverlauf zu erzeugen. Dazu m√ºssen wir die Farbe der LED kontinuierlich √§ndern, sodass sie von Rot √ºber Gelb, Gr√ºn, Cyan, Blau und Violett wieder zur√ºck zu Rot wechselt. Das erreichen wir mit einer Schleife. Eine Schleife ist ein Konstrukt in der Programmierung, das es uns erm√∂glicht, einen bestimmten Codeabschnitt mehrfach auszuf√ºhren, ohne ihn jedes Mal neu schreiben zu m√ºssen. Das spart Zeit und macht den Code √ºbersichtlicher.\n\n1.6.1 Abz√§hlbare Wiederholungen\nWir beginnen wie immer einfach und n√§hern uns dem Regenbogen schrittweise an. Zun√§chst w√§re es sch√∂n, wenn wir die LED einfach Rot pulsieren lassen k√∂nnten. Dazu m√ºssen wir n√§mlich nur den Rot-Kanal und nicht alle drei Kan√§le der LED ansteuern. Gleichzeitig lernen wir schon hier ein Problem kennen, das mit Schleifen gel√∂st werden kann.\nWas bedeutet es, die LED pulsieren zu lassen? Und was m√ºssen wir daf√ºr tun? Pulsieren bedeutet, dass die LED langsam immer heller wird, kurz in der vollen Helligkeit verweilt, aber dann sofort wieder kontinuierlich dunklert wird. Sobald sie schwarz ist f√§ngt der Zyklus von Vorne an.\nDen Ausdruck immer heller werden k√∂nnen wir bezogen auf die LED so √ºbersetzen, dass wir den Anteil des Rot-Kanals schrittweise erh√∂hen. Wenn die LED zu Beginn aus ist, also alle Kan√§le auf 0 stehen, k√∂nnen wir den Rot-Kanal von 0 auf 255 erh√∂hen und so die LED immer heller in Rot aufleuchten lassen.\nWir beginnen also mit einer schwarzen LED:\n\nbtn.set_color(0, 0, 0)\n\nAnschlie√üend setzen wir den Wert f√ºr Rot auf 1:\n\nbtn.set_color(1, 0, 0)\n\nUnd erh√∂hen ihn schrittweise:\n\nbtn.set_color(2, 0, 0)\nbtn.set_color(3, 0, 0)\nbtn.set_color(4, 0, 0)\n# ...\n\nWenn wir nach diesem Muster fortfahren, h√§tten wir bis zum vollen Rot 255 Zeilen Code geschrieben, eine f√ºr Zeile jeden Erh√∂hungschritt. Und anschlie√üend das gleiche nochmal r√ºckw√§rts, damit wir wieder zu Schwarz kommen. Mit 510 Zeilen Code h√§tten wir dann eine Pulsierungszykls durchlaufen. Wollen wir die LED √∂fters pulsieren lassen vervielfacht sich unser Code entsprechend. Das kann doch nicht die L√∂sung f√ºr ein so einfaches Problem sein.\nUnd tats√§chlich gibt es in der Programmierung eine bessere M√∂glichkeit, um sich wiederholende Abl√§ufe abzubilden: die Schleife. In einem Fall, bei dem wir genau wissen, wie oft wir etwas wiederholen wollen, bietet sich eine Z√§hlerschleife an:\n\nfor r in range(256):\n    btn.set_color(r, 0, 0)\n\nVoil√°! Unsere 510 Zeilen Code k√∂nnen wir mit einer Schleife auf zwei Zeilen reduzieren! Dazu m√ºssen wir im Kopf der Schleife (for ... in ...) festlegen, wie oft der einger√ºckte Codeblock nach dem Doppelpunkt ausgef√ºhrt werden soll. In Python funktioniert das √ºber die Angabe einer Menge, f√ºr die jedes Element einmal durchlaufen wird. Das aktuelle Element ist in der Schleife als r verf√ºgbar. Und r nimmt nacheinander jeden Wert der Menge an, die nach dem Schl√ºsselwort in folgt. Diese Menge erzeugt hier die Funktion range(256), die, wie der Name preisgibt, eine Zahlenspanne von 0 bis zum angegebenen Wert minus eins erzeugt. In unserem Fall also von 0 bis 255.\nUm das besser nachvollziehen zu k√∂nnen, geben wir den Wert f√ºr r einfach mal aus:\n\nfor r in range(256):\n    btn.set_color(r, 0, 0)\n1    print(r)\n\n\n1\n\nMit print() geben wir einen Wert auf der Konsole aus.\n\n\n\n\nJetzt wird es deutlich: mit jedem Durchlauf der Schleife wird ein neuer Wert f√ºr r gesetzt und ausgegeben. Und zwar jeweils um eins erh√∂ht. Die Funktion range(256) erzeugt genau gesagt eine sortierte Reihe mit den Zahlen von 0 b is 255. Das sieht in Python dann so aus:\n\nlist_of_numbers = range(256)\n1print(list(list_of_numbers))\n\n\n1\n\nMit der list()-Funktion wandeln wir die von range() erzeugte Menge in eine Liste um, die wir dann ausgeben k√∂nnen.\n\n\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]\n\n\nR√ºckw√§rts erreichen wir das gleiche Ergebnis mit einer weiteren Schleife, deren Menge wir umkehren, so dass sie von 255 bis 0 geht:\n\nfor r in range(255, -1, -1):\n    btn.set_color(r, 0, 0)\n\nWarum hat range() auf einmal drei Argumente? Ganz einfach: Standardm√§√üig erstellt die Funktion eine Menge von 0 bis zur angegebenen Zahl minus eins. Wir k√∂nnen die Menge aber beeinflussen, indem wir einen Startwert und einen Schrittwert angeben. In unserem Fall oben beginnen wir bei 255 (erster Parameter) und gehen bis -1 (zweiter Parameter), wobei wir in jedem Schritt um -1 verringern (dritter Parameter). Warum z√§hlen wir bis -1, wo wir doch eigentlich die 0 als kleinste Zahl ben√∂tigen? Das liegt daran, dass die Menge von range() immer bis zum zweiten Parameter minus eins geht. Wenn wir also 0 als kleinste Zahl ben√∂tigen, m√ºssen wir bis -1 z√§hlen.\nFassen wir unsere Erkenntnis zusammen und lassen die LED pulsieren:\n\nimport time\n\n# Increase red step by step\nfor r in range(256):\n    btn.set_color(r, 0, 0)\n    time.sleep(0.001)\n\n# Stay at full brightness for a bit\ntime.sleep(0.25)\n\n# Decrease red step by step\nfor r in range(255, -1, -1):\n    btn.set_color(r, 0, 0)\n    time.sleep(0.001)\n\nSoweit bekannt? Fast, eine kleine Neuerung habe ich gerade eingebaut, n√§mlich mit der Funktion time.sleep(). Diese Funktion pausiert das Programm f√ºr die angegebene Zeit in Sekunden. In unserem Fall pausieren wir f√ºr 0,001 Sekunden, also 1 Millisekunde. Dadurch wird die LED langsamer heller und dunkler, was den Pulsationseffekt verst√§rkt. Ohne diese Pause w√ºrde die LED so schnell aufleuchten, dass es f√ºr das menschliche Auge nicht mehr wahrnehmbar w√§re. Tats√§chlich w√ºrden wir auch die Hardware √ºberfordern, weil die LED gar nicht so schnell dei Farbe wechseln kann. Das Programm w√ºrde abst√ºrzen.\nAuf dem H√∂hepunkt warten wir erneut, dieses Mal eine Viertelsekunde, bevor wir die LED langsam ausgehen lassen und den Rotanteil schrittweise wieder auf Null setzen. Dann endet unser Programm, leider viel zu fr√ºh. Die LED soll doch eigentlich weiter pulsieren, bis‚Ä¶ ja bis wann √ºberhaupt?\n\n\n1.6.2 Bedingte Wiederholungen\nBeim L√∂sen von Problemen sto√üen wir h√§ufig auf Situationen, in denen wir bestimmte Schritte wiederholt ausf√ºhren m√∂chten, aber nur unter bestimmten Bedingungen. Hier kommen bedingte Wiederholungen ins Spiel, die es uns erm√∂glichen, Schleifen zu erstellen, die nur dann fortgesetzt werden, wenn eine bestimmte Bedingung noch erf√ºllt ist.\nDas k√∂nnen wir auf unsere pulsierende LED anwenden. Sie soll ihren Pulsierzyklus Dunkel-Hell-Dunkel wiederholen, solange der Benutzer nicht unterbricht. Das ist zumindest ein pragmatisches Abbruchkriterium f√ºr unseren Fall. Wir definieren also hier keine feste Anzahl Widerholungen, wie bei der for ... in-Schleife, sondern wir wollen festlegen, unter welcher Bedingung die Schleife fortgesetzt wird. Wir k√∂nnten also sagen: solange die Bedingung X erf√ºllt ist, wiederhole die aufgef√ºhrten Schritte. Und weil Programmiersprachen f√ºr Menschen gemacht sind, klingt es im echten Programm auch so √§hnlich:\n\nwhile 1==1:\n    print(\"The condition is always true\")\n    time.sleep(1)\n\nDas Schl√ºsselwort while f√ºhrt eine bedingte Schleife ein, gefolgt von der Bedingung, die die Schleife steuert. Die Bedingung wird vor jedem neuen Schleifendurchlauf gepr√ºft (auch vor dem ersten) und sollte sie falsch (false) sein, wird die Schleife beendet.\nWann wird die Schleife oben also beendet? Richtig - niemals. Die Bedingung 1==1 ist immer wahr, die Schleife l√§uft somit endlos. Wir sprechen auch von einer Endlosschleife, die wir in der Programmierung unbedingt vermeiden wollen, es sei denn, sie ist explizit gewollt und nicht versehentlich entstanden. Das kurze Programm oben schreibt also in Abst√§nden von einer Sekunde den Text ‚ÄúThe condition is always true‚Äù auf die Konsole.\nEine Bedingung ist in Python und anderen Programmiersprache ein wichtiges Konzept, das es uns erm√∂glicht, Entscheidungen zu treffen und den Programmfluss zu steuern. In unserem Fall k√∂nnte die Bedingung lauten: solange der Benutzer nicht stoppt, wiederhole den Pulsierzyklus. Eine Bedingung hat die Eigenschaft, dass sie jederzeit evaluiert werden kann und entweder den Wert wahr (true) oder falsch (false) annimt. Wie aber dr√ºcken wir das in Python aus?\n\nimport keyboard\n\nwhile not keyboard.is_pressed('esc'):\n    print(\"Nobody pressed ESC yet\")\n    time.sleep(1)\n\nF√ºr Ereignisse, die die Tastatur betreffen, k√∂nnen wir uns der Bibliothek keyboard bedienen, die es uns erm√∂glicht, Tasteneingaben einfach zu √ºberwachen. Der Ausdruck oder die Bedingung not keyboard.is_pressed('esc') pr√ºft, ob die ESC-Taste gedr√ºckt ist. Wegen des not wird die Schleife fortgesetzt, solange die ESC-Taste nicht gedr√ºckt ist. Das Schl√ºsselwort verneint das Ergebnis einer Bedingung. Aus True wird False, und umgekehrt.\nDie Bibliothek keyboard ist eine so genannte externe Bibliothek und muss vor der Vewendung installiert werden. Das k√∂nnt ihr √ºber den Paketmanager pip bewerkstelligen, der mit jeder Python-Installation mitgeliefert wird. Gebt auf der Kommandozeile dazu den folgenden Befehl ein:\npip install keyboard\nAnschlie√üend ist die Bibliothek in eurer Python-Umgebung vorhanden und sollte mit dem import-Befehl erfolgreich geladen werden k√∂nnen.\nWenn wir jetzt unseren f√ºr einen Pulsierzyklus von Oben in die neue bedingte Schleife einf√ºgen, sind wir schon am Ziel. Der Pulsierzyklus wird wiederholt, solange der Benutzer nicht die Taste Escape dr√ºckt.\n\nimport keyboard\n\nwhile not keyboard.is_pressed('esc'):\n\n    # Increase red step by step\n    for r in range(256):\n        btn.set_color(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, -1, -1):\n        btn.set_color(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)\n\nF√ºr die Vollst√§ndigkeit das Ganze inklusive des Boilerplate-Codes f√ºr die Verbindung zu den Tinkerforge-Ger√§ten:\n\n\n\n\nListing¬†1.2: Das fertige Programm, das die LED rot pulsieren l√§sst.\n\n\nimport time\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn LED off initially\nled.set_rgb_value(0, 0, 0)\n\nwhile not keyboard.is_pressed('esc'):\n\n    # Increase red step by step\n    for r in range(255):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, 0, -1):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#kontrollstrukturen",
    "href": "colors.html#kontrollstrukturen",
    "title": "1¬† Farben üåà",
    "section": "1.7 Kontrollstrukturen",
    "text": "1.7 Kontrollstrukturen\n\nif .. elif .. else",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "colors.html#hue",
    "href": "colors.html#hue",
    "title": "1¬† Farben üåà",
    "section": "1.8 Hue",
    "text": "1.8 Hue\n\n\n\n\nListing¬†1.3: Das fertige Programm, das die LED in einem Regenbogenfarbverlauf leuchten l√§sst.\n\n\nimport keyboard\nimport time\nimport colorsys\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn button of initially\nled.set_rgb_value(0, 0, 0)\n\n# Initialize the hue value\nhue = 1\n\n# Set the duration for one rainbow cycle\nduration_seconds = 4\nduration_seconds_per_step = duration_seconds / 360\n\n# Loop until user presses escape key\nwhile not keyboard.is_pressed('esc'):\n\n    # Calculate RGB from hue\n    r, g, b = colorsys.hsv_to_rgb(hue / 360.0, 1.0, 1.0)\n    r = int(r * 255)\n    g = int(g * 255)\n    b = int(b * 255)\n\n    led.set_rgb_value(r, g, b)\n    \n    # Wait a bit\n    time.sleep(duration_seconds_per_step)\n\n    hue = hue + 1\n    if hue &gt; 360:\n        hue = 1\n\nled.set_rgb_value(0, 0, 0)\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben üåà</span>"
    ]
  },
  {
    "objectID": "human_input.html",
    "href": "human_input.html",
    "title": "2¬† Eingaben",
    "section": "",
    "text": "Setup\nWir erweitern unser Setup aus Kapitel 1 und f√ºgen ein Eingabeger√§t hinzu: Einen einfachen Drehknopf (Rotary Encoder Bricklet 2.0). Den schraubt ihr neben die LED, wie auf der Abbildung zu sehen ist.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Eingaben</span>"
    ]
  },
  {
    "objectID": "human_input.html#setup",
    "href": "human_input.html#setup",
    "title": "2¬† Eingaben",
    "section": "",
    "text": "Experiment\n\n\n\n\nRGB LED Button als Eingabeger√§t\nEinf√ºhrung in andere Eingabeger√§te",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Eingaben</span>"
    ]
  },
  {
    "objectID": "human_input.html#das-fertige-programm",
    "href": "human_input.html#das-fertige-programm",
    "title": "2¬† Eingaben",
    "section": "2.1 Das fertige Programm",
    "text": "2.1 Das fertige Programm\n\nimport keyboard\nimport time\nimport colorsys\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn button of initially\nled.set_rgb_value(0, 0, 0)\n\n# Initialize the hue value\nhue = 1\n\n# Set the duration for one rainbow cycle\nduration_seconds = 4\nduration_seconds_per_step = duration_seconds / 360\n\n# Loop until user presses escape key\nwhile not keyboard.is_pressed('esc'):\n\n    # Calculate RGB from hue\n    r, g, b = colorsys.hsv_to_rgb(hue / 360.0, 1.0, 1.0)\n    r = int(r * 255)\n    g = int(g * 255)\n    b = int(b * 255)\n\n    led.set_rgb_value(r, g, b)\n    \n    # Wait a bit\n    time.sleep(duration_seconds_per_step)\n\n    hue = hue + 1\n    if hue &gt; 360:\n        hue = 1\n\nled.set_rgb_value(0, 0, 0)\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Eingaben</span>"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "3¬† Texte",
    "section": "",
    "text": "Setup\nF√ºr dieses Kapitel ben√∂tigen wir die LED (RGB LED Bricklet 2.0) und den Infrarot-Entfernungsmesser Distance IR 4-30cm Bricklet 2.0. Beide Ger√§te schlie√üen wir an den Mikrocontroller (Master Brick 3.2) and und fixieren alle drei auf einer Montageplatte. Wie in der Abbildung gezeigt, soll der Entfernungsmesser dabei nach oben zeigen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#setup",
    "href": "text.html#setup",
    "title": "3¬† Texte",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#texte-ganz-ohne-tastatur",
    "href": "text.html#texte-ganz-ohne-tastatur",
    "title": "3¬† Texte",
    "section": "3.1 Texte ‚Äì ganz ohne Tastatur?",
    "text": "3.1 Texte ‚Äì ganz ohne Tastatur?\nJa, ich gebe zu: Eine Tastatur ist schon richtig praktisch. Schnell tippen wir damit Buchstaben, Zahlen, Satz- und Sonderzeichen (wie neue Zeilen und Leerzeichen) ein. Aber stell dir mal vor: Wie k√∂nnte ich eigentlich dieses Buch schreiben, wenn ich keine Tastatur h√§tte?\nTats√§chlich gibt es spannende Alternativen! Hast du schon mal versucht, Texte zu diktieren? Google Docs oder Microsoft Word bieten mittlerweile ziemlich gute M√∂glichkeiten daf√ºr. Anfangs f√ºhlt sich das ungewohnt an, aber ich kenne Menschen, die darauf schw√∂ren und damit sogar produktiver sind.\nHeute wollen wir aber bewusst einmal einen Schritt zur√ºckgehen und das Tippen absichtlich erschweren. Klingt komisch? Macht aber Sinn! Denn wenn wir das Eingeben von Texten schwieriger gestalten, lernen wir einerseits, unsere Tastaturen wieder richtig zu sch√§tzen. Andererseits verstehen wir dann besser, wie Texte im Hintergrund verarbeitet und gespeichert werden.\nWie w√§re es also mit einer Tastatur, die auf Handgesten basiert? Klingt verr√ºckt? Perfekt ‚Äì genau das machen wir!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "href": "text.html#klein-anfangen-ein-einfacher-button-mit-handgesten",
    "title": "3¬† Texte",
    "section": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten",
    "text": "3.2 Klein anfangen: Ein einfacher Button mit Handgesten\nStarten wir ganz simpel. Wir bauen zuerst eine Art ‚ÄúKnopf‚Äù oder Button, der auf Handgesten reagiert. Daf√ºr verwenden wir einen der Infrarot-Abstandssensoren ‚Äì oder wie er bei Tinkerforge hei√üt: Distance IR 4-30cm Bricklet 2.0. Wie der Name schon sagt, misst der Sensor Entfernungen von 4 bis maximal 30 cm.\nUm den Sensor in unserem Programm zu nutzen, k√∂nnen wir ganz entspannt den Grundcode (Boilerplate-Code) aus den vorherigen Kapiteln √ºbernehmen. Nur zwei kleine Anpassungen brauchen wir noch speziell f√ºr unseren Sensor:\n\nfrom tinkerforge.ip_connection import IPConnection\n1from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n2ir_sensor = BrickletDistanceIRV2(\"\", ip_con)\n\n\n1\n\nHier importieren wir die Klasse f√ºr den IR-Sensor.\n\n2\n\nHier erzeugen wir eine konkrete Instanz und verbinden uns mit dem angeschlossenen Sensor. Vergiss nicht, deine UID hier einzutragen!\n\n\n\n\nWas kann der Sensor? Eigentlich hat er nur eine Funktion:\n\n1distance = ir_sensor.get_distance()\n2print(f\"Objekt ist {distance/100} cm entfernt\")\n\n\n1\n\nDie Funktion get_distance() fragt den aktuell gemessenen Wert ab.\n\n2\n\nDer Sensor liefert den Wert in Zentimeter * 100 zur√ºck.\n\n\n\n\nAber wie l√§sst sich mit den Entfernungswert ein Button umsetzen? Dazu vergegenw√§rtigen wir uns, was ein herk√∂mmlicher Button eigentlich ist und wie er funktioniert. Ein Button, wie wir ihn auf einer Tastatur finden, kennt zwei Zust√§nde: Gedr√ºckt und nicht gedr√ºckt. An oder aus. Wenn wir eine Taste dr√ºcken, so schlie√üen wir dar√ºber einen Stromkreis, der in einem winzigen Mikroprozessor m√ºndet. Dieser Prozessor erkennt durch laufendes Scannen s√§mtlicher Verbindungen zu den Tasten (die als Matrix angeordnet sind), durch welche Kreise Strom flie√üt und kann so auf die gedr√ºckte Taste schlie√üen. Der Mikroprozessor ermittelt dann anhand der Koordinate in der Matrix einen so gennanten Scan Code, der f√ºr jede Taste anders lautet. Dieser Code wird als bin√§re Folge von Nullen und Einsen √ºber das USB-Kabel an den Computer geschickt und dort von dem aktiven Programm - etwa einer Textverarbeitungssoftware - in ein Codesystem umgewandelt, das Zeichen abbilden kann. So wie etwa das ASCII-Codesystem, das wir weiter unten kennenlernen.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "images.html",
    "href": "images.html",
    "title": "4¬† Bilder",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\n\nEinf√ºhrung in die Idee einer Pixelmatrix aus Farbwerten als Bild\nVerwendung des LCD-Displays zur Veranschaulichung, auch wenn nur schwarz/wei√ü\nVerwendung von Zeichen auf dem LCD, um Pixel-Bitmaps f√ºr Schriftarten hervorzuheben\nStudierende nutzen Bitmap-Sheet, um ein eigenes Logo zu entwerfen und auf dem LCD anzuzeigen\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "codes.html",
    "href": "codes.html",
    "title": "5¬† Codes",
    "section": "",
    "text": "Experiment\n\n\n\nMorse-Code √ºber Piezo Speaker\n\nEinf√ºhrung des Piezo Speaker\nCodesysteme\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Codes</span>"
    ]
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#setup",
    "href": "conversion.html#setup",
    "title": "6¬† Umwandlung",
    "section": "",
    "text": "Experiment\n\n\n\nMit 4 Kippschaltern und 4 Widerst√§nden bauen wir einen Digital-To-Analog-Converter (DAC). Dazu kommt ein Breadboard und diveser √úberbr√ºckungskabel zum Einsatz. Au√üerdem brauchen wir den Analog In 3.0 von Tinkerforge.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-in-den-computer-hinein",
    "href": "conversion.html#der-weg-in-den-computer-hinein",
    "title": "6¬† Umwandlung",
    "section": "6.1 Der Weg in den Computer hinein",
    "text": "6.1 Der Weg in den Computer hinein",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "conversion.html#der-weg-aus-dem-computer-heraus",
    "href": "conversion.html#der-weg-aus-dem-computer-heraus",
    "title": "6¬† Umwandlung",
    "section": "6.2 Der Weg aus dem Computer heraus",
    "text": "6.2 Der Weg aus dem Computer heraus\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Umwandlung</span>"
    ]
  },
  {
    "objectID": "information.html",
    "href": "information.html",
    "title": "7¬† Information",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "information.html#setup",
    "href": "information.html#setup",
    "title": "7¬† Information",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Information</span>"
    ]
  },
  {
    "objectID": "sensors.html",
    "href": "sensors.html",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#setup",
    "href": "sensors.html#setup",
    "title": "8¬† Sensoren",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\nAnalog vs.¬†digital\nBaue einen Wasserstandssensor mit einem Widerstand und dem Analog-In-Bricklet.\nOder: Feuchtigkeitssensor in eine Pflanze stecken\nOder: Ber√ºhrungssensor\nOder: Pulssensor (Farbsensor)\nIntegriere die RGB-LED irgendwie\nFarbsensor",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "sensors.html#aufgaben",
    "href": "sensors.html#aufgaben",
    "title": "8¬† Sensoren",
    "section": "Aufgaben",
    "text": "Aufgaben\n\nProgrammiere einen Batteriedoktor mithilfe des Analog In Sensors\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Sensoren</span>"
    ]
  },
  {
    "objectID": "signals.html",
    "href": "signals.html",
    "title": "9¬† Signale",
    "section": "",
    "text": "Setup\nHast du dich schon einmal gefragt, wie dein Fitness-Tracker deinen Puls messen kann, obwohl du nur einen Finger auflegst? Diese Frage f√ºhrt uns direkt zu einem spannenden Konzept: Signalen. Alles, was wir mit Sensoren messen, sind zun√§chst einmal beliebige Gr√∂√üen. Doch nicht alles, was wir messen, ist f√ºr uns relevant. Wir suchen nach Mustern in diesen Daten ‚Äî eben genau diesen Mustern, die wir als Signale bezeichnen. Alles andere, was uns von diesen Signalen ablenkt, nennen wir Rauschen. Unser Ziel: Wir m√∂chten herausfinden, wie wir Signale effektiv vom Rauschen unterscheiden k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#setup",
    "href": "signals.html#setup",
    "title": "9¬† Signale",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\n\n\nExperiment\n\n\n\nMithilfe des Farbsensors bauen wir einen Pulsmesser.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "href": "signals.html#pulsmesser-dein-finger-als-signalquelle",
    "title": "9¬† Signale",
    "section": "9.1 Pulsmesser: Dein Finger als Signalquelle",
    "text": "9.1 Pulsmesser: Dein Finger als Signalquelle\nErinnerst du dich noch an den Farbsensor aus Kapitel 8? Er misst nicht nur die Intensit√§t des RGB-Spektrums, sondern auch die allgemeine Lichtintensit√§t, auch Illuminance genannt. Hier kommt die spannende Tatsache ins Spiel: Genau dieses Prinzip steckt hinter den Pulsmessern in Fitnesstrackern. Ja, genau der Sensor, der Licht misst, verr√§t dir, wie schnell dein Herz schl√§gt!\nAber wie genau funktioniert das? Stell dir vor, du legst deinen Zeigefinger direkt auf den Sensor und schaltest die integrierte wei√üe LED an. Das Licht der LED trifft auf deinen Finger und wird reflektiert. Dein Finger sieht f√ºr dich immer gleich aus, aber tats√§chlich sorgt dein Herzschlag daf√ºr, dass dein Finger mal minimal heller und mal dunkler erscheint. Das liegt daran, dass Blut in rhythmischen Sch√ºben durch die Gef√§√üe gepumpt wird. Diese winzigen Ver√§nderungen, die du mit blo√üem Auge nicht sehen kannst, werden vom sensiblen Farbsensor deutlich wahrgenommen.\nSchauen wir uns das einmal genauer an: Wenn du dir die gemessene Lichtintensit√§t √ºber den Zeitverlauf im Brick Viewer ansiehst, kannst du deinen Pulsschlag tats√§chlich erkennen‚Äîer wird sichtbar als kleine, regelm√§√üige Ausschl√§ge oder Peaks. Faszinierend, oder? So kannst du beobachten, wie aus etwas so scheinbar Einfachem wie Licht ein Signal entsteht, das dir Informationen √ºber deinen K√∂rper liefert.\n\n\n\n\n\n\nAbbildung¬†9.1: Dein Puls im Brick Viewer",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "signals.html#vom-diagramm-zur-zahl",
    "href": "signals.html#vom-diagramm-zur-zahl",
    "title": "9¬† Signale",
    "section": "9.2 Vom Diagramm zur Zahl",
    "text": "9.2 Vom Diagramm zur Zahl\nAuch wenn du das Signal im Liniendiagramm in Abbildung¬†9.1 bereits deutlich sehen kannst, bleibt eine spannende Herausforderung bestehen: Wie schreibst du ein Programm, das aus diesen Daten deinen Puls als konkrete Zahl, zum Beispiel ‚Äú60 Schl√§ge pro Minute‚Äù, berechnet? Genau daf√ºr sind wir ja hier ‚Äì um herauszufinden, wie man solche kniffligen Aufgaben l√∂st. Lass uns gemeinsam starten!\nZun√§chst m√ºssen wir den Farbsensor in unserem Python-Programm auslesen. Den notwendigen Code daf√ºr haben wir im vorherigen Kapitel 8 bereits kennengelernt.\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\n\n\n1\n\nAchtung: Vergiss nicht, hier deine eigene UID einzusetzen. Diese findest du im Brick Viewer.\n\n\n\n\nJetzt haben wir Zugriff auf die Funktionen des Sensors und k√∂nnen etwa die Lichtintensit√§t messen:\n\n1color_sensor.set_light(True)\n2color_sensor.set_configuration(1, 1)\nilluminance = color_sensor.get_illuminance()\n\n\n1\n\nSchaltet die integrierte LED des Sensors an.\n\n2\n\nStellt die Werte f√ºr Gain und Integration Time auf 4x und 24ms. Diese Einstellung scheinen gut zu funktionieren, um den Puls zu messen.\n\n\n\n\nDer zur√ºckgegebene Wert h√§ngt von zwei Einstellungen ab: Gain (Verst√§rkung) und Integration Time (Messzeit). Je l√§nger die Messzeit, desto genauer die Werte ‚Äì allerdings k√∂nnen dann weniger Messungen pro Sekunde durchgef√ºhrt werden. Laut Dokumentation k√∂nnen wir aus dem gemessenen Wert die Lichtintensit√§t in Lux wie folgt berechnen:\n\n1illuminance_lux = illuminance * 700 / 4 / 24\n\n\n1\n\nDer Wert 4 beschreibt ein 4-fache Verst√§rkung (Gain) und die 24 steht f√ºr 24ms Integration Time\n\n\n\n\nUm deinen Puls zu berechnen, m√ºssen wir jetzt mehrere Werte in kurzen Abst√§nden messen. Warum? Weil wir die regelm√§√üigen Tief- und Hochpunkte erkennen wollen. Ein Tiefpunkt entsteht, wenn dein Finger am dunkelsten ist ‚Äì hier ist also gerade besonders viel Blut im Finger. Die Hochpunkte markieren dagegen den Moment, in dem das Blut gr√∂√ütenteils wieder zur√ºckgeflossen ist. Jeder Herzschlag erzeugt genau einen Tief- und einen Hochpunkt. Finden wir diese Punkte, k√∂nnen wir einfach die Zeitabst√§nde messen und daraus die Pulsfrequenz berechnen.\nBeginnen wir damit, unsere Messungen in einer Schleife durchzuf√ºhren. Das ist eine praktische Methode, kontinuierlich Daten zu erfassen:\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n    print(f\"Lichtintensit√§t in Lux: {illuminance_lux}\")\n\nLass uns das Programm einmal ausprobieren. Es sieht aktuell so aus:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_color_v2 import BrickletColorV2\n\nip_con = IPConnection()\nip_con.connect(\"localhost\", 4223)\n\n1color_sensor = BrickletColorV2(\"Wgn\", ip_con)\ncolor_sensor.set_light(True)\ncolor_sensor.set_configuration(1, 1)\n\nwhile True:\n    illuminance = color_sensor.get_illuminance()\n    illuminance_lux = illuminance * 700 / 4 / 24\n2    print(f\"Lichtintensit√§t in Lux: {illuminance_lux:.2f}  \", end=\"\\r\")\n\n\n1\n\nDenke daran, die UID durch die deines Sensors zu ersetzen.\n\n2\n\nDer Parameter end=\"\\r\" sorgt daf√ºr, dass nicht jede Ausgabe in eine neue Zeile geschrieben wird. Stattdessen wird immer an den Anfang der selben Zeile gesprungen. Das \\r ist das Symbol f√ºr Carriage Return.\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Signale</span>"
    ]
  },
  {
    "objectID": "protocols.html",
    "href": "protocols.html",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "protocols.html#setup",
    "href": "protocols.html#setup",
    "title": "10¬† Protokolle",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Protokolle</span>"
    ]
  },
  {
    "objectID": "encryption.html",
    "href": "encryption.html",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "encryption.html#setup",
    "href": "encryption.html#setup",
    "title": "11¬† Verschl√ºsselung",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>Verschl√ºsselung</span>"
    ]
  },
  {
    "objectID": "algorithms.html",
    "href": "algorithms.html",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "algorithms.html#setup",
    "href": "algorithms.html#setup",
    "title": "12¬† Algorithmen",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>Algorithmen</span>"
    ]
  },
  {
    "objectID": "compression.html",
    "href": "compression.html",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "compression.html#setup",
    "href": "compression.html#setup",
    "title": "13¬† Kompression",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>13</span>¬† <span class='chapter-title'>Kompression</span>"
    ]
  },
  {
    "objectID": "computer.html",
    "href": "computer.html",
    "title": "14¬† Computer",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#logik-und-arithmetik",
    "href": "computer.html#logik-und-arithmetik",
    "title": "14¬† Computer",
    "section": "14.1 Logik und Arithmetik",
    "text": "14.1 Logik und Arithmetik\n\nLogikgatter\n8-Bit-Additionsmaschine\nSubtraktion, Division, Multiplikation",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#die-von-neumann-architektur",
    "href": "computer.html#die-von-neumann-architektur",
    "title": "14¬† Computer",
    "section": "14.2 Die von-Neumann-Architektur",
    "text": "14.2 Die von-Neumann-Architektur",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "href": "computer.html#der-arbeitsspeicher-oder-das-kurzzeitged√§chtnis-des-computers",
    "title": "14¬† Computer",
    "section": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers",
    "text": "14.3 Der Arbeitsspeicher oder das Kurzzeitged√§chtnis des Computers\n\nx = 10\nprint(f\"Adresse im Speicher der Variable 'x': {hex(id(x))}\")\nx= 20\nprint(f\"Neue Adresse im Speicher der Variable 'x': {hex(id(x))}\")\n\nAdresse im Speicher der Variable 'x': 0x7ffb03a17448\nNeue Adresse im Speicher der Variable 'x': 0x7ffb03a17588\n\n\n\nnames = [\"Max\", \"Kim\", \"Hildegard\"]\nprint(f\"Adresse im Speicher der Variable 'names': {hex(id(names))}\")\nnames.append(\"Heinrich\")\nprint(f\"Die Adresse im Speicher der Variable 'names' bleibt identisch: {hex(id(names))}\")\n\nAdresse im Speicher der Variable 'names': 0x24f1db11580\nDie Adresse im Speicher der Variable 'names' bleibt identisch: 0x24f1db11580\n\n\n\n\n\n\n\n\nLeseempfehlung\n\n\n\nUm tiefer in die Themen dieses Kapitels einzusteigen, empfehle ich euch Petzold (2022) zu lesen . Es lohnt sich, das Buch von Vorne nach Hinten zu verschlingen.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>14</span>¬† <span class='chapter-title'>Computer</span>"
    ]
  },
  {
    "objectID": "problems.html",
    "href": "problems.html",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Setup",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "problems.html#setup",
    "href": "problems.html#setup",
    "title": "15¬† Probleme",
    "section": "",
    "text": "Kommt bald\n\n\n\nDieses Kapitel ist in Arbeit und wird in K√ºrze fertiggestellt.\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>15</span>¬† <span class='chapter-title'>Probleme</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Adami, Christoph. 2016. ‚ÄúWhat Is Information?‚Äù\nPhilosophical Transactions of the Royal Society A: Mathematical,\nPhysical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, and Dennis Brylow. 2020. Computer Science: An\nOverview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer\nHardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, and John Horton Conway. 2004. How to Solve It: A New\nAspect of Mathematical Method. Expanded Princeton Science Library\ned. Princeton Science Library. Princeton [N.J.]: Princeton University\nPress.\n\n\nScott, John C. 2009. But How Do It Know?: The Basic Principles of\nComputers for Everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]