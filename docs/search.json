[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-On Computer Science",
    "section": "",
    "text": "Vorwort\nGl√ºckwunsch, ihr seid angekommen! Egal, wie euer Weg hierher aussah: Ihr habt dieses Buch ge√∂ffnet. Vielleicht studiert ihr an der Hochschule Osnabr√ºck und wurdet (zu eurem Gl√ºck) dazu verpflichtet, oder ihr seid ganz bewusst hier gelandet und freut euch darauf, etwas Neues zu lernen ‚Äì genau wie ich.\nDieses Buch entstand urspr√ºnglich, um meinen Veranstaltungen an der Hochschule Osnabr√ºck eine verst√§ndliche und praxisnahe Grundlage zu geben. Es dient als Hauptlekt√ºre f√ºr meine Vorlesungen und als Nachschlagewerk f√ºr alle, die eine Sitzung verpasst haben oder Themen eigenst√§ndig vertiefen m√∂chten. Besonders willkommen sind Quereinsteiger, Wiederholer und neugierige Menschen, die bisher noch gar keinen Kontakt mit der Hochschule Osnabr√ºck hatten.\nHier bekommt ihr keine trockene Theorie, sondern eine praxisnahe Einf√ºhrung in die Grundlagen moderner Computer und unserer digitalen Welt. Das Fach dahinter hei√üt auf Deutsch Informatik, international Computer Science. Der Titel Hands-On Computer Science verr√§t bereits, worum es geht: Es wird praktisch, und zwar von Anfang an.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#was-macht-dieses-buch-besonders",
    "href": "index.html#was-macht-dieses-buch-besonders",
    "title": "Hands-On Computer Science",
    "section": "Was macht dieses Buch besonders?",
    "text": "Was macht dieses Buch besonders?\nLehrb√ºcher zur Informatik gibt es reichlich. Viele sind gro√üartig, aber kaum eines passt genau zu dem, was ich mit meinen Studierenden vorhabe. Woran liegt das?\nViele klassische Informatikb√ºcher versuchen, das gesamte Fach m√∂glichst umfassend abzubilden. Das ist sinnvoll f√ºr angehende Informatikerinnen und Informatiker, aber meine Zielgruppe seid ihr: Studierende in Studieng√§ngen wie Management nachhaltiger Ern√§hrungssysteme, Lebensmittelproduktion oder Agrarsystemtechnologien ‚Äì oder ihr seid gar nicht an der Hochschule, sondern wollt euch einfach einen besseren Zugang zur digitalen Welt erarbeiten.\nKurz gesagt: Dieses Buch ist f√ºr alle gedacht, die in die digitale Welt eintauchen wollen, ohne sich mit komplizierten Details zu √ºberfordern. Daf√ºr braucht ihr kein allumfassendes Nachschlagewerk, sondern einen klaren roten Faden, der euch Schritt f√ºr Schritt an die grundlegenden Konzepte heranf√ºhrt.\nViele B√ºcher versprechen Praxisn√§he, doch oft endet sie in n√ºchternen √úbungsaufgaben am Kapitelende. Genau hier setzt Hands-On Computer Science an und macht drei Dinge anders:\n\nIhr lernt informatische Konzepte anhand spannender Experimente mit Microcontrollern, Sensoren, Buttons, LEDs und Displays.\nWir f√ºhren wichtige Konzepte fr√ºh ein, gehen aber erst nach und nach ins Detail und wiederholen sie regelm√§√üig.\nTheorie und Praxis sind nicht getrennt, sondern eng miteinander verbunden ‚Äì Programmieren und informatische Grundlagen lernt ihr gleichzeitig.\n\nSchon ab Kapitel 1 beginnt ihr zu programmieren, und zwar nicht abstrakt, sondern konkret mit Hardware-Bauteilen wie einer LED. Im Laufe des Buches lernt ihr Schritt f√ºr Schritt neue Hardwarekomponenten kennen, die direkt mit relevanten informatischen Konzepten verkn√ºpft sind. So schlie√üt ihr nicht nur eine Reihe Experimente erfolgreich ab, sondern baut fast nebenbei ein solides Fundament in Informatik und Programmierung auf. Wenn alles gut l√§uft, merkt ihr kaum, wie schnell ihr gelernt habt.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "index.html#tipps-f√ºr-die-lekt√ºre",
    "href": "index.html#tipps-f√ºr-die-lekt√ºre",
    "title": "Hands-On Computer Science",
    "section": "Tipps f√ºr die Lekt√ºre",
    "text": "Tipps f√ºr die Lekt√ºre\nWeil es in diesem Buch viel ums Programmieren geht, findet ihr viele Codebl√∂cke und Code-Snippets. Als Einstiegssprache verwenden wir Python. Warum ausgerechnet Python? Das erfahrt ihr sp√§ter.\nCodebl√∂cke sind deutlich vom √ºbrigen Text abgehoben, grau hinterlegt und in einer Schreibmaschinenschrift dargestellt, etwa Courier New oder Consolas. Hier ein kleines Beispiel:\n\n1led.set_rgb_value(0, 0, 0)\n2led.set_rgb_value(255, 255, 255)\n\nprint(\"Diese Zeile hat keine Annotation\")\n\n3# Lasse die LED blau aufleuchten\nled.set_rgb_value(0, 0, 255)\n\n\n1\n\nSchaltet die LED aus, weil der RGB-Code (0, 0, 0) die Farbe Schwarz ergibt.\n\n2\n\nSchaltet die LED auf wei√ües Licht, weil dreimal 255 die Farbe Wei√ü ergibt.\n\n3\n\nAuch Kommentare sind f√ºr kurze Erl√§uterungen n√ºtzlich.\n\n\n\n\nDie Annotationen sind mit einer kleinen Zahl versehen. Wenn ihr das Buch online lest und mit der Maus √ºber diese Zahl fahrt, erscheint ein Tooltip, der die jeweilige Codezeile erkl√§rt. Das funktioniert nur online, nicht in der PDF- oder Druckversion. Dort sind die Erl√§uterungen unter dem Codeblock aufgef√ºhrt.\nWeil wir in jedem Kapitel ein Programm Schritt f√ºr Schritt entwickeln und es dadurch immer l√§nger wird, lasse ich gelegentlich Stellen im Code weg, um den Fokus auf neu hinzugekommene Zeilen zu legen. Diese Auslassungen markiere ich in den Codebl√∂cken mit drei Punkten (...). Keine Sorge: Den gesamten Code findet ihr stets am Ende eines Abschnitts. Au√üerdem liegt jedes Programm im zu diesem Buch geh√∂rigen GitHub-Repository unter:\nhttps://github.com/winf-hsos/hands-on-computer-science-code\nNoch ein Tipp: Wenn ihr mit der Maus √ºber einen Codeblock fahrt, erscheint rechts oben ein Clipboard-Symbol. Ein Klick darauf kopiert den Code direkt in eure Zwischenablage, und ihr k√∂nnt ihn anschlie√üend in euer ge√∂ffnetes Visual Studio Code oder eine andere IDE einf√ºgen und ausprobieren. In der Online-Version lassen sich manche Codebl√∂cke einklappen, damit ihr weniger scrollen m√ºsst.\nAlles klar? Dann schauen wir uns an, was uns in diesem Buch erwartet!\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Vorwort"
    ]
  },
  {
    "objectID": "experiments.html",
    "href": "experiments.html",
    "title": "Experimente",
    "section": "",
    "text": "Hands-On Programmieren lernen\nHast du dich schon einmal gefragt, wie man Informationen √ºber Licht √ºbertragen kann? Oder wie man mit Licht den Puls messen kann? Oder wie man mit zwei einfachen Kabeln einen Wasserstandssensor baut? Das alles klingt vielleicht weit hergeholt, ist aber tats√§chlich machbar ‚Äì und wie genau, das wollen wir in diesem Buch herausfinden! Dabei werden wir nicht nur die digitale Welt der Computer und Programmierung kennenlernen, sondern auch mit spannenden Ger√§ten in der analogen Welt arbeiten. In jedem Kapitel arbeiten wir mit anderen Ger√§ten, die dir unterschiedliche Facetten der digitalen Welt n√§herbringen und gleichzeitig erm√∂glichen, das Programmieren spielerisch zu erlernen.\nHier ein √úberblick √ºber die Ger√§te, mit denen wir gemeinsam experimentieren werden. Zusammengefasst kosten alle Komponenten 249 ‚Ç¨. Aber keine Sorge: Wenn du das Buch im Rahmen meines Moduls ‚ÄûDigitalisierung und Programmierung‚Äú an der Hochschule Osnabr√ºck liest, erh√§ltst du f√ºr das gesamte Semester ein komplettes Hardware-Kit.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#hands-on-programmieren-lernen",
    "href": "experiments.html#hands-on-programmieren-lernen",
    "title": "Experimente",
    "section": "",
    "text": "Abbildung¬†1: Tinkerforge Workbench mit vielen Ger√§ten\n\n\n\n\n\n\n\nWas?\nBauteil\nAnzahl\nPreis pro St√ºck\n\n\n\n\nBunte LED\nRGB LED Bricklet 2.0\n1\n8 ‚Ç¨\n\n\nButton mit integrierter, bunter LED\nRGB LED Button Bricklet\n1\n15 ‚Ç¨\n\n\nLicht- und Farbsensor\nColor Bricklet 2.0\n1\n17 ‚Ç¨\n\n\nLCD Touchdisplay\nLCD 128x64 Bricklet\n1\n33 ‚Ç¨\n\n\nPiezo Lautsprecher\nPiezo Speaker Bricklet 2.0\n1\n19 ‚Ç¨\n\n\nInfrarot-Entfernungsmesser\nDistance IR 4-30cm Bricklet 2.0\n1\n20 ‚Ç¨\n\n\nAnaloger Spannungssensor\nAnalog In Bricklet 3.0\n1\n14 ‚Ç¨\n\n\nSchalldruckpegelsenor\nSound Pressure Level Bricklet\n1\n35 ‚Ç¨\n\n\nMikrocontroller\nMaster Brick 3.2\n2\n35 ‚Ç¨\n\n\nAnschlusskabel 15 cm\nBricklet Kabel 15cm (7p-7p)\n8\n1 ‚Ç¨\n\n\nUSB-A- auf USB-C Kabel\nUSB-A auf USB-C Kabel 100 cm\n1\n6 ‚Ç¨\n\n\nMontageplatte\nMontageplatte 22x22 (12x12cm)\n2\n7 ‚Ç¨\n\n\nSchrauben, Abstandshalter und Muttern\nBefestigungskit 12mm\n4\n2 ‚Ç¨",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#spannende-experimente",
    "href": "experiments.html#spannende-experimente",
    "title": "Experimente",
    "section": "Spannende Experimente",
    "text": "Spannende Experimente\nKapitel f√ºr Kapitel werden wir an unterschiedlichen Experimenten arbeiten. Dabei lernst du nicht nur, wie man Hardware-Komponenten miteinander verbindet, sondern vor allem auch, wie man Computer ‚Äì diese universellen Probleml√∂sungsmaschinen ‚Äì f√ºr eigene Ideen und L√∂sungen programmieren kann. Hier ist der √úberblick, was dich in diesem Buch erwartet:\n\n\n\n\n\n\n\nKapitel\nExperiment(e)\n\n\n\n\n1¬† Farben\nWir lassen eine LED einen Regenbogenfarbverlauf √ºber die Zeit erzeugen.\n\n\n3¬† Texte\nWir lernen, wie man Texte umst√§ndlich und ohne Tastatur eingeben kann ‚Äì √ºber Handgesten.\n\n\n4¬† Bilder\nWir verbinden Tabellenkalkulation mit Bildern und Touchdisplays ü§Ø\n\n\n?sec-codes\nWir lernen Morse-Code und wie wir diesen √ºber einen Lautsprecher ausgeben k√∂nnen.\n\n\n?sec-conversion\nWir verwenden einfache Kippschalter, um analoge Werte in digitale Werte umzuwandeln.\n\n\n?sec-information\n\n\n\n?sec-sensors\nWir bauen einen Wasserstandssensor mit einem analogen Spannungssensor.\n\n\n?sec-signals\nWir basteln einen Pulsmesser aus einem Farbsensor üíì\n\n\n?sec-protocols\nWir √ºbertragen Nachrichten √ºber Lichtsignale üî¶\n\n\n?sec-encryption\nWir verstecken geheime Botschaften in harmlosen Nachrichten üïµÔ∏è‚Äç‚ôÄÔ∏è\n\n\n?sec-algorithms\n\n\n\n?sec-compression\nWir entwickeln ein Verfahren, um Information zu komprimieren.\n\n\n?sec-computer\nWir entwickeln eine Rechenmaschine, die zwei Bytes addieren kann, mit nur einem einem Bauteil.\n\n\n?sec-problems",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "href": "experiments.html#frust-ist-dein-freund-zumindest-ein-bisschen",
    "title": "Experimente",
    "section": "Frust ist dein Freund ‚Äì zumindest ein bisschen",
    "text": "Frust ist dein Freund ‚Äì zumindest ein bisschen\nEins m√∂chte ich gleich vorwegnehmen: Beim Programmierenlernen ist eine gewisse Portion Frust unvermeidbar. Klingt unangenehm? Ist es auch! Aber es ist zugleich Teil eines enorm wertvollen Lernprozesses. Jeder Fehler, den du machst, ist eine Gelegenheit, um zu verstehen, wie Computer wirklich funktionieren ‚Äì n√§mlich absolut pr√§zise und ohne jede Toleranz f√ºr Fehler.\nComputer sind gnadenlose Lehrer. Sie zeigen dir sofort und unerbittlich, wenn etwas nicht stimmt ‚Äì sei es ein vergessener Punkt, ein falscher Buchstabe oder ein simpler Zahlendreher. Das kann frustrieren, aber genau dieses direkte und sofortige Feedback hilft dir auch, schnell und effektiv zu lernen. Sobald du verstehst, wie du aus Fehlermeldungen sinnvolle Schl√ºsse ziehst und deine Programme entsprechend korrigierst, wirst du belohnt ‚Äì mit Erfolgserlebnissen und einer steilen Lernkurve.\n\n\n\n\n\n\nAbbildung¬†2: Ein frustrierter Frosch\n\n\n\nAlso, wenn mal etwas nicht klappt: Nimm es nicht pers√∂nlich, sondern sieh es als Herausforderung. Atme tief durch, mach dir klar, dass Fehler unvermeidbar und sogar wichtig sind, und probier es noch einmal. Ich verspreche dir: Es lohnt sich!\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Experimente"
    ]
  },
  {
    "objectID": "prerequisites.html",
    "href": "prerequisites.html",
    "title": "Voraussetzungen",
    "section": "",
    "text": "Visual Studio Code\nUm die Experimente in diesem Buch durchf√ºhren zu k√∂nnen, ben√∂tigt ihr die folgende Software auf eurem Computer:\nEine beliebte Entwicklungsumgebung, die ihr kostenlos herunterladen k√∂nnt. Hier geht‚Äôs zur Download-Seite.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "prerequisites.html#python",
    "href": "prerequisites.html#python",
    "title": "Voraussetzungen",
    "section": "Python",
    "text": "Python\nEine Programmiersprache, die f√ºr die Experimente verwendet wird. Ihr k√∂nnt Python von der offiziellen Website herunterladen: Python Download.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "prerequisites.html#software-von-tinkerforge",
    "href": "prerequisites.html#software-von-tinkerforge",
    "title": "Voraussetzungen",
    "section": "Software von Tinkerforge",
    "text": "Software von Tinkerforge\n\nTinkerforge-Bibliothek f√ºr Python\nEine Sammlung von Funktionen, die die Programmierung der Tinkerforge-Hardware erleichtern. Ihr k√∂nnt die Bibliothek mit dem folgenden Befehl installieren: pip install tinkerforge.\n\n\nBrick Daemon\nEin Hintergrundprozess, der die Kommunikation mit der Tinkerforge-Hardware erm√∂glicht. Ihr k√∂nnt den Brick Daemon von der Tinkerforge-Website herunterladen: Brick Daemon Download.\n\n\nBrick Viewer\nEin Tool, das eine grafische Benutzeroberfl√§che f√ºr die Interaktion mit der Tinkerforge-Hardware bietet. Ihr k√∂nnt den Brick Viewer von der Tinkerforge-Website herunterladen: Brick Viewer Download.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Voraussetzungen"
    ]
  },
  {
    "objectID": "colors.html",
    "href": "colors.html",
    "title": "1¬† Farben",
    "section": "",
    "text": "Zusammenfassung\nIm ersten Kapitel steigen wir gleich voll ein und schreiben unser erstes Programm. Unser Ziel ist es, eine LED nacheinander in allen Farben des Regenbogens leuchten zu lassen. Um dahin zu kommen, lernen wir in Abschnitt 1.1 zuerst, wie man √ºberhaupt eine LED aus einem Programm heraus steuern kann. In Abschnitt 1.2 werfen wir einen kurzen Blick auf Farben im allgemeinen und wie diese im Computer erzeugt werden. Dabei unterscheiden wir die additive von der subtraktiven Farbmischung. Danach bereiten wir uns in Abschnitt 1.3 auf den Regenbogenfarbverlauf vor, indem wir zuerst eine pulsierende LED programmieren. Wir lernen dann in Abschnitt 1.4, wie man mittels RGB-Farbcode √ºberhaupt einen Regenbogen erzeugen kann und warum das f√ºr uns Menschen n√ºtzlich ist. Am Ende in Abschnitt 1.5 schreiben wir schlie√ülich das Programm, das die LED in allen Farben des Regenbogens leuchten l√§sst.\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#zusammenfassung",
    "href": "colors.html#zusammenfassung",
    "title": "1¬† Farben",
    "section": "",
    "text": "Wir verstehen, wie Farben im Computer funktionieren und beschrieben werden.\nWir entwickeln unser erstes Programm am Beispiel einer LED-Steuerung.\nWir lernen Schleifen als wichtiges Konzept in der Programmierung kennen.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#experimentaufbau",
    "href": "colors.html#experimentaufbau",
    "title": "1¬† Farben",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\nBereit f√ºr euer erstes Hardware-Experiment? Perfekt! Ihr braucht daf√ºr eine LED (RGB LED Bricklet 2.0) und einen Mikrocontroller (Master Brick 3.2). Befestigt beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in Abbildung¬†1.1 gezeigt. Zwei Schrauben pro Ger√§t reichen v√∂llig. Denkt an die kleinen, wei√üen Unterlegscheiben aus Kunststoff. Sie sch√ºtzen eure Platinen vor Druckstellen.\nNeben der Hardware ben√∂tigt ihr auch die passende Software. Diese solltet ihr bereits installiert haben. Falls nicht, schaut im Abschnitt zu den Voraussetzungen vorbei. Dort ist alles genau beschrieben. Im Folgenden gehe ich davon aus, dass ihr alles am Laufen habt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Nahaufnahme der LED.\n\n\n\n\n\n\n\n\n\n\n\n(c) Montageplatte mit allen Komponenten.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Untenansicht.\n\n\n\n\n\n\n\n\n\n\n\n(e) Ansicht der vier Steckpl√§tze.\n\n\n\n\n\n\n\nAbbildung¬†1.1: Einfaches Setup mit einem Mikrocontroller und einer LED.\n\n\n\n\n\nErste Schritte\nIm ersten Schritt wollen wir die LED und ihre Funktionen testen! Das geht ganz leicht mit dem Brick Viewer. Schlie√üt zuerst den Master Brick √ºber das USB-Kabel an euren Computer an und √∂ffnet den Brick Viewer. Klickt dann auf den Connect-Button.\n\n\n\n\n\n\nAbbildung¬†1.2: √úber den Connect-Button verbindet ihr den Brick Viewer mit dem angeschlossenen Master Brick.\n\n\n\nWenn alles geklappt hat, zeigt euch der Brick Viewer alle angeschlossenen Ger√§te in Tabs an. Schaut euch Abbildung¬†1.3 an ‚Äì so etwa sollte es aussehen.\n\n\n\n\n\n\nAbbildung¬†1.3: Der Brick Viewer, nachdem ihr mit dem Master Brick verbunden seid.\n\n\n\nWechselt nun zum Tab der RGB LED. Hier k√∂nnt ihr auf unterschiedlichen Wegen die Farbe der LED einstellen. Mehr kann eine LED nicht!\nMit den drei Schiebereglern steuert ihr die einzelnen Farbkan√§le ‚Äì Rot, Gr√ºn, Blau. Der Wertebereich: 0 bis 255. Warum gerade diese Farben und diese Zahlen? Gute Frage. Die Antwort kommt weiter unten.\n\n\n\n\n\n\nAbbildung¬†1.4: Die Ansicht f√ºr die RGB LED im Brick Viewer, in der ihr alle Funktionen per Klick im Zugriff habt.\n\n\n\nFazit: Der Brick Viewer ist ideal zum Ausprobieren. Aber wenn ihr echte Projekte umsetzen wollt, m√ºsst ihr programmieren lernen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-control-led",
    "href": "colors.html#sec-colors-control-led",
    "title": "1¬† Farben",
    "section": "1.1 Erstes Programm: LED ansteuern",
    "text": "1.1 Erstes Programm: LED ansteuern\nWie verbinden wir uns √ºber ein Programm mit der LED und setzen ihre Farbe? Die Antwort darauf findet ihr im folgenden kurzen Codebeispiel.\n\n\n\n\nListing¬†1.1: Der Boilerplate-Code f√ºr die Verbindung mit den Ger√§ten am Beispiel der RGB LED.\n\n\n1from tinkerforge.ip_connection import IPConnection\n2from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\n3ipcon = IPConnection()\n4ipcon.connect(\"localhost\", 4223)\n5led = BrickletRGBLEDV2(\"ZEP\", ipcon)\n\n\n\n\n\n1\n\nHier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.\n\n2\n\nHier importieren wir ein weiteres Objekt, das wir zur Darstellung der LED als Python-Objekt ben√∂tigen.\n\n3\n\nDie Verbindung erfolgt √ºber eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.\n\n4\n\nMit connect stellen wir eine Verbindung zum angeschlossenen Master Brick her.\n\n5\n\nSchlie√ülich holen wir uns eine virtuelle Instanz des RGB LED Bricklets, indem wir die UID nennen und sagen, welche Verbindung (ipcon) genutzt werden soll.\n\n\n\n\n\n1.1.1 Programme\nZun√§chst kl√§ren wir den Begriff Programm. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausf√ºhrt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm sp√§ter daf√ºr zust√§ndig, mit der LED zu interagieren und sie in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns erm√∂glichen, dem Computer pr√§zise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut f√ºr Einsteiger eignet und gleichzeitig m√§chtig genug ist, um komplexe Aufgaben zu l√∂sen.\nWenn wir ein Programm ausf√ºhren, arbeitet der Computer die Anweisungen Schritt f√ºr Schritt von oben nach unten ab. Die Nummerierung der Zeilen verdeutlicht das sehr sch√∂n. Der Computer beginnt bei Zeile 1 und arbeitet die Befehle Zeile f√ºr Zeile bis nach unten ab.\nEs gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir sp√§ter kennen.\n\n\n1.1.2 Boilerplate Code\nDer Codeausschnitt in Listing¬†1.1 wird uns im Verlauf dieses Buches immer wieder begegnen. Wir ben√∂tigen ihn, um uns am Anfang des Programms mit den Ger√§ten zu verbinden, die wir f√ºr unsere Anwendung ben√∂tigen. In der Informatik nennen wir solchen Code, den wir h√§ufig in der gleichen Form ben√∂tigen und fast eins zu eins kopieren k√∂nnen, auch Boilerplate-Code. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.\n\n\n1.1.3 Bibliotheken\nBeginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr √§hnliche Befehle, die mit dem Schl√ºsselwort from beginnen. Nach dem Schl√ºsselwort from folgt der Name einer Bibliothek, aus der wir ein f√ºr unser Programm ben√∂tigtes Objekt importieren. Die Kombination der Schl√ºsselw√∂rter from ... import l√§sst sich also w√∂rtlich √ºbersetzen: ‚ÄúAus der Bibliothek X importiere das Objekt Y‚Äù.\nEine Bibliothek in einer Programmiersprache ist die B√ºndelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek k√∂nnt ihr euch vorstellen wie einen Werkzeugkasten: Sie enth√§lt fertige Werkzeuge (Funktionen und Klassen), damit ihr nicht alles von Grund auf selbst programmieren m√ºsst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Ger√§ten loslegen k√∂nnen. F√ºr jedes Ger√§t gibt es in der Tinkerforge-Bibliothek eine eigene Klasse, √ºber die wir auf die Funktionen jedes Ger√§ts zugreifen k√∂nnen.\n\n\n1.1.4 Klassen und Objekte\nMit from ... import importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit importieren ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge sp√§ter wirklich nutzen, steht auf einem anderen Blatt.\nIn dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ank√ºndigen. Die erste Klasse hei√üt IPConnection und die zweite BrickletRGBLEDV2. Der Begriff Klasse ist hier analog zum Begriff Kategorie zu verstehen. Wir k√∂nnen zu einer Klasse geh√∂rige Objekte erzeugen, und alle Objekte derselben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.\nStellt euch vor, ihr habt eine Klasse namens Auto. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa fahren(), bremsen() oder tanken(). Diese Dinge sollen f√ºr jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Wir k√∂nnen also sagen: ‚ÄúMein Auto ist ein Objekt der Klasse Auto.‚Äù Jedes Auto hat neben den Funktionen die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte f√ºr diese Eigenschaften haben.\nGenauso verh√§lt es sich mit den Klassen, die Tinkerforge f√ºr uns bereitgestellt hat. Die Klasse IPConnection beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen k√∂nnen, und die Klasse BrickletRGBLEDV2 beschreibt, wie wir mit der LED interagieren k√∂nnen. Wenn wir ein Objekt dieser Klasse erstellen, k√∂nnen wir alle Funktionen nutzen, die in der Klasse definiert sind. Eine LED muss nicht fahren oder bremsen wie ein Auto. Daf√ºr hat sie andere Funktionen, wie etwa set_rgb_value(), die uns erlaubt, die Farbe der LED zu √§ndern. Eine Eigenschaft jeder LED ist ihre UID, die eindeutig ist und uns hilft, sie im System zu identifizieren.\n\n\n1.1.5 Schl√ºsselw√∂rter\nSoeben haben wir mit from und import unsere ersten beiden Schl√ºsselw√∂rter in Python kennengelernt! Aber was bedeutet das genau? Ein Schl√ºsselwort, das wir im Englischen auch keyword oder reserved keyword nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch h√§ufig Namen vergeben m√ºssen, etwa f√ºr Variablen oder Funktionen. Diese Namen d√ºrfen nicht wie ein Schl√ºsselwort lauten, ansonsten funktioniert unser Programm nicht wie gew√ºnscht. Welche Schl√ºsselw√∂rter es in Python gibt, k√∂nnt ihr hier nachschauen.\nIm Codeausschnitt oben laden wir zuerst das Objekt f√ºr die Verbindung zum angeschlossenen Mikrocontroller, die √ºber eine IP-Verbindung hergestellt wird. Was das genau ist? Sp√§ter mehr dazu. Zus√§tzlich zur IPConnection laden wir anschlie√üend noch die ben√∂tigten Klassen f√ºr die Ger√§te, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur die LED, in sp√§teren Experimenten werden es auch mal mehrere Ger√§te sein.\n\n\n1.1.6 Objekte erzeugen\nIn Listing¬†1.1 in Zeile 4 erzeugen wir ein Objekt der Klasse IPConnection. Die fertige Instanz ‚Äì so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde ‚Äì speichern wir auf einer Variable mit dem Namen ipcon. Diesen Namen haben wir uns selbst ausgedacht, damit wir sp√§ter darauf zugreifen k√∂nnen. Wir h√§tten auch einen anderen Namen w√§hlen k√∂nnen. Eine Variable ist also ein Platzhalter f√ºr einen Wert, den wir sp√§ter im Programm verwenden wollen. In diesem Fall ist ipcon der Platzhalter f√ºr die Verbindung zu unserem Mikrocontroller. Was eine Variable technisch ist, lernen wir sp√§ter noch genauer kennen.\n\n\n1.1.7 Methoden\n√úber das Objekt ipcon k√∂nnen wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode connect(). Eine Methode ist eine Funktion, die zu einem Objekt geh√∂rt ‚Äì wie etwa fahren() oder bremsen() in unserem Auto-Beispiel.\nWir k√∂nnen Methoden aufrufen, um eine bestimmte Aktion auszuf√ºhren. In diesem case stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, √ºber den die Verbindung hergestellt werden soll. In unserem Fall ist das ‚Äúlocalhost‚Äù, was f√ºr die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standardm√§√üig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt . nach dem Objekt, gefolgt vom Namen der Methode und den Klammern (), in denen wir eventuell ben√∂tigte Parameter angeben.\nEine Methode ist letztlich eine Funktion, die zu einem Objekt geh√∂rt. Zu einem sp√§teren Zeitpunkt schreiben wir unsere eigenen Funktionen und lernen dann noch viel mehr dar√ºber.\n\n\n1.1.8 Ein Objekt f√ºr die LED\nIn Zeile 6 erzeugen wir schlie√ülich ein Objekt der Klasse BrickletRGBLEDV2. Dieses Objekt repr√§sentiert unsere LED und erm√∂glicht es uns, mit ihr zu interagieren. Wir nennen das Objekt led, was kurz und klar ist. Auch hier haben wir uns den Namen selbst ausgedacht, um sp√§ter darauf zugreifen zu k√∂nnen. Auch wenn wir grunds√§tzlich Variablennamen frei w√§hlen k√∂nnen, sollten sie immer so gew√§hlt werden, dass sie den Inhalt der Variable beschreiben. Das macht es sp√§ter einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten m√ºssen. Dazu geh√∂ren etwa, dass Variablennamen nicht mit einer Zahl beginnen d√ºrfen und keine Leerzeichen enthalten d√ºrfen. Eine ausf√ºhrliche Liste der Regeln findet ihr hier.\n\n\n1.1.9 Zusammenfassung unseres ersten Programms\nDamit haben wir unser erstes Programm von oben nach unten erl√§utert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:\n\n\n\n\n\n\n\nProgramme\nAbfolge von Anweisungen, die nacheinander ausgef√ºhrt werden.\n\n\nBoilerplate Code\nStandard-Code, den man immer wieder braucht.\n\n\nImportieren von Bibliotheken\nSammlung von fertigen Code-Elementen.\n\n\nSchl√ºsselw√∂rter\nReservierte Begriffe der Programmiersprache.\n\n\nKlassen und Objekte\nKategorien und deren konkrete Instanzen.\n\n\nMethoden und Funktionen\nFunktionen, die zu einem Objekt geh√∂ren.\n\n\nVariablen\nPlatzhalter f√ºr Werte.\n\n\n\n\n\n1.1.10 Und jetzt?\nWir haben nun eine digitale Repr√§sentation unserer LED in Python. Wir k√∂nnen die LED jetzt zum Leuchten bringen, indem wir eine Methode der Klasse BrickletRGBLEDV2, die set_rgb_value() hei√üt, verwenden. Diese Methode erwartet drei Parameter: Rot, Gr√ºn und Blau. Mit diesen Parametern k√∂nnen wir die Farbe der LED einstellen.\n\n1led.set_rgb_value(0, 255, 0)\n\n\n1\n\nSetzt die LED auf gr√ºn. R = 0, G = 255, B = 0. Logisch, oder?\n\n\n\n\nMoment mal ‚Ä¶ Wo steht hier eigentlich gr√ºn? Steht da gar nicht. Stattdessen drei Zahlen. Willkommen bei der RGB-Farbkodierung. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Gr√ºn, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Wei√ü. Nur Gr√ºn auf 255? Na klar: gr√ºn.\nAber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie √ºbersetzen wir die Welt in etwas, das ein Computer versteht?\nWarum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit drei Zahlen? Warum √ºberhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?\nVorher m√ºssen wir aber kurz zur√ºck in die Schule.\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-light-and-colors",
    "href": "colors.html#sec-colors-light-and-colors",
    "title": "1¬† Farben",
    "section": "1.2 Licht und Farben",
    "text": "1.2 Licht und Farben\n\n1.2.1 Blick auf die Physik\nPhysik ist vielleicht schon eine Weile her. Erinnern wir uns dennoch kurz, was Licht ist und wie Farben damit zusammenh√§ngen. Licht ist elektromagnetische Strahlung. Das bedeutet, es handelt sich um gekoppelte Schwingungen elektrischer und magnetischer Felder, die sich mit Lichtgeschwindigkeit ausbreiten. Vereinfacht k√∂nnen wir uns Licht als Wellen vorstellen, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenl√§ngen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen √ºber Infrarotstrahlung bis hin zu R√∂ntgenstrahlen und Gammastrahlen reicht.\nBei Wellen unterscheiden wir zwischen der Frequenz (wie oft die Welle pro Sekunde schwingt) und der Wellenl√§nge (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenl√§nge sind umgekehrt proportional: Je h√∂her die Frequenz, desto k√ºrzer die Wellenl√§nge und umgekehrt.\nFrequenzen messen wir in Hertz (Hz), wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenl√§ngen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) f√ºr violettes Licht und etwa 700 nm f√ºr rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abst√§nde zwischen den Wellenl√§ngen des sichtbaren Lichts sind also extrem klein.\nWas bedeutet das nun f√ºr eine LED? Eine LED (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchflie√üt. Die Farbe des Lichts h√§ngt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenl√§ngen, was zu verschiedenen Farben f√ºhrt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenl√§nge von etwa 620‚Äì750 nm, w√§hrend eine gr√ºne LED Licht mit einer Wellenl√§nge von etwa 495‚Äì570 nm emittiert.\n\n\n\n\n\n\nAbbildung¬†1.5: Das elektromagnetische Spektrum, von dem das sichtbare Licht ein kleiner Teil ist. (Quelle: Wikipedia)\n\n\n\nDie RGB LED besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer gr√ºnen und einer blauen. Jede dieser LEDs kann unabh√§ngig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Stromst√§rke bedeutet mehr Intensit√§t der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Gr√ºn und Blau in unterschiedlichen Intensit√§ten k√∂nnen wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensit√§t leuchten lassen, erhalten wir Wei√ü. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LEDs sind dann alle aus.\nJetzt wissen wir, warum die Methode set_rgb_value() drei Parameter erwartet: Rot, Gr√ºn und Blau. Diese Parameter sind die Intensit√§ten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 k√∂nnen wir jede Farbe im sichtbaren Spektrum erzeugen.\nEin Farbwert im Computer besteht also aus drei Zahlen besteht, die jeweils zwischen 0 und 255 liegen. Das gilt f√ºr unsere LED, aber auch f√ºr Pixel in TVs, Smartphones, digitalen Fotos oder Monitoren. Wie kommt es aber zu der merkw√ºrdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grunds√§tzlich Werte speichert und wie dieser Speicher organisiert ist. Genaueres erfahren wir schon in Kapitel 2.\nKlingt alles theoretisch sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus und mischen zwei Farben mit voller Intensit√§t!\n\nled.set_rgb_value(255, 255, 0)\n\nWas macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!\n\n\n1.2.2 Additive Farbmischung\nIhr solltet alle eure LEDs in Gelb aufleuchten sehen. In der additiven Farbmischung mischen wir Rot und Gr√ºn und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Gr√ºn, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensit√§t leuchten lassen, erhalten wir eine neue Farbe, die stets heller ist als die Ursprungsfarben. Wir f√ºgen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensit√§t mischen, erhalten wir schlie√ülich Wei√ü.\n\nled.set_rgb_value(255, 255, 255)\n\nAm anderen Ende des Spektrums erzeugen drei Nullen die Farbe Schwarz:\n\nled.set_rgb_value(0, 0, 0)\n\n\n\n1.2.3 Subtraktive Farbmischung\nIhr k√∂nnt euch merken, dass wir im Kontext von Computern oft von additiver Farbmischung sprechen, weil Bildschirme Licht erzeugen. Durch das Mischen der drei Farbkan√§le entstehen neue Farben gem√§√ü der additiven Farbmischung, also stets heller als ihre Grundfarben. Daneben gibt es aber noch die subtraktive Farbmischung. Sie funktioniert anders, n√§mlich genau umgekehrt. Statt beim Mischen Licht hinzuzuf√ºgen, nehmen wir Licht weg.\nErinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbkasten die Mischung aus Rot und Gr√ºn ergeben? Sicher nicht Gelb ‚Äì eher Braun. Eine dunklere Farbe. Das liegt daran, dass wir es hier nicht mit additiver, sondern mit subtraktiver Farbmischung zu tun haben. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht absorbieren und reflektieren. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtspektrums werden nicht mehr reflektiert, sondern absorbiert und sind damit nicht mehr sichtbar. Das Ergebnis einer Mischung zweier Farben ergibt in der subtraktiven Farbmischung also stets eine dunklere Farbe ‚Äì genau umgekehrt zur additiven Farbmischung.\nWas passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, n√§mlich W√§rme. Deshalb wird eine schwarze Oberfl√§che auch besonders hei√ü, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspektrum und wandelt es in W√§rme um. Dagegen wirken wei√üe Oberfl√§chen fast wie Klimaanlagen. Es ist kein Zufall, dass wir in sonnigen Erdteilen viele wei√üe Fassaden sehen.\nWenn wir alle Farben mischen, ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zur√ºck. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen kombinieren, um neue Farben zu erhalten.\n\n\n\n\n\n\n\n\n\n\n\n(a) Additive Farbmischung\n\n\n\n\n\n\n\n\n\n\n\n(b) Subtraktive Farbmischung\n\n\n\n\n\n\n\nAbbildung¬†1.6: Additive und subtraktive Farbmischung.\n\n\n\nIn Abbildung¬†1.6 sehen wir die beiden Farbmischungsarten im Vergleich. In Abbildung¬†1.6 (b) sehen wir die drei Grundfarben, die wir bei der subtraktiven Variante ben√∂tigen, um daraus alle weiteren Farben zu erhalten. Das sind Cyan, Magenta und Gelb. Im Englischen ist die Abk√ºrzung CMY, wo das ‚ÄúY‚Äù f√ºr Yellow steht. In der additiven Farbmischung sind es, wie oben schon gesehen, Rot, Gr√ºn und Blau. Wenn ihr Abbildung¬†1.6 (a) betrachtet, dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der additiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?\nIn der additiven Farbmischung entsteht Gelb durch das Mischen von Rot und Gr√ºn, wobei Blau fehlt. Im Umkehrschluss bedeutet das: Gelbes Licht enth√§lt keine blaue Komponente, es reflektiert also kein Blau. In der subtraktiven Farbmischung (wie beim Farbkasten) wird Gelb erzeugt, indem Blau aus wei√üem Licht herausgefiltert wird ‚Äì Gelb reflektiert also kein Blau, sondern absorbiert es. Gelb kann also auch als Blaufilter gesehen werden. Das erkl√§rt, warum ein gelber Gegenstand unter blauem Licht dunkel erscheint: Er kann das blaue Licht nicht reflektieren.\nJetzt k√∂nnen wir auch erkl√§ren, warum Farbdrucker vier unterschiedliche Kartuschen ben√∂tigen (Abbildung¬†1.7). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb k√∂nnen wir jede beliebige Farbe mischen. Zus√§tzlich haben Drucker eine Kartusche f√ºr Schwarz, um erstens ein sattes Schwarz drucken zu k√∂nnen und zweitens die Farbkartuschen zu schonen. Denn schlie√ülich m√ºssen alle drei Farben gemischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen Schwarz enthalten (oder sogar ausschlie√ülich), ist eine schwarze Kartusche einfach effizienter. Die Farbe Schwarz wird bei Druckerkartuschen als Key bezeichnet und mit ‚ÄúK‚Äù abgek√ºrzt. Wir sprechen daher auch von CMYK.\n\n\n\n\n\n\nAbbildung¬†1.7: Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.\n\n\n\nFarben spielen eine so wichtige Rolle bei der Arbeit mit Computern. Deshalb lohnt es sich, ein wenig √ºber die Hintergr√ºnde von Farben und deren Mischung zu verstehen. Wir werden sp√§ter noch lernen, wie Bildschirme Farben darstellen. Sp√§testens dann wird uns das Thema der Farbmischung wieder begegnen.\nAb jetzt wollen wir weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, praxisnah verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED √ºber die Methode set_rgb_value() ver√§ndern k√∂nnen, wenn wir wissen, welcher RGB-Code unsere gew√ºnschte Farbe repr√§sentiert. Da wir jetzt mehr √ºber die Farbmischung wissen, k√∂nnen wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:\n\nled.set_rgb_value(255, 0, 255)\n\nGem√§√ü der Theorie der additiven Farbmischung (Abbildung¬†1.6 (a)) m√ºssten Rot und Blau Magenta ergeben. Probiert es aus!",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-pulsating-led",
    "href": "colors.html#sec-colors-pulsating-led",
    "title": "1¬† Farben",
    "section": "1.3 Pulsierende LED",
    "text": "1.3 Pulsierende LED\nDas deklarierte Ziel unseres ersten Experiments ist es, einen Regenbogenfarbverlauf zu erzeugen. Dazu m√ºssen wir die Farbe der LED kontinuierlich √§ndern, sodass sie von Rot √ºber Gelb, Gr√ºn, Cyan, Blau und Violett wieder zur√ºck zu Rot wechselt.\nLasst uns aber m√∂glichst einfach anfangen und uns dem Regenbogen schrittweise ann√§hern. Zun√§chst w√§re es sch√∂n, wenn wir die LED einfach Rot pulsieren lassen k√∂nnten. Dazu m√ºssen wir n√§mlich nur den Rot-Kanal und nicht alle drei Kan√§le der LED ansteuern. Gleichzeitig lernen wir schon hier ein Problem kennen, das uns in der Programmierung h√§ufig begegnet und f√ºr das es eine elegante L√∂sung gibt.\n\n1.3.1 Abz√§hlbare Wiederholungen\nWas bedeutet es, die LED pulsieren zu lassen? Und was m√ºssen wir daf√ºr tun? Pulsieren bedeutet, dass die LED √ºber einen kurzen Zeitraum immer heller wird, kurz in der vollen Helligkeit verweilt und dann sofort wieder kontinuierlich dunkler wird. Sobald sie schwarz ist, f√§ngt der Zyklus von vorne an.\nDen Ausdruck immer heller werden k√∂nnen wir bezogen auf die LED so √ºbersetzen, dass wir den Anteil des Rot-Kanals schrittweise erh√∂hen. Wenn die LED zu Beginn aus ist, also alle Kan√§le auf 0 stehen, k√∂nnen wir den Rot-Kanal von 0 auf 255 erh√∂hen und so die LED immer heller in Rot aufleuchten lassen.\nWir beginnen also mit einer schwarzen LED:\n\nled.set_rgb_value(0, 0, 0)\n\nAnschlie√üend setzen wir den Wert f√ºr Rot auf 1:\n\nled.set_rgb_value(1, 0, 0)\n\nUnd erh√∂hen ihn schrittweise:\n\nled.set_rgb_value(2, 0, 0)\nled.set_rgb_value(3, 0, 0)\nled.set_rgb_value(4, 0, 0)\n# ...\n\nWenn wir nach diesem Muster fortfahren, h√§tten wir bis zum vollen Rot 255 Zeilen Code geschrieben, eine Zeile f√ºr jeden Erh√∂hungsschritt. Und anschlie√üend das Gleiche nochmal r√ºckw√§rts, damit wir wieder zu Schwarz kommen. Mit 510 Zeilen Code h√§tten wir dann einen Pulsierungszyklus durchlaufen. Wollen wir die LED √∂fter pulsieren lassen, vervielfacht sich unser Code entsprechend. Das kann nicht die L√∂sung f√ºr ein so einfaches Problem sein.\nUnd tats√§chlich gibt es in der Programmierung eine bessere M√∂glichkeit, um sich wiederholende Abl√§ufe abzubilden: die Schleife. In einem Fall, bei dem wir genau wissen, wie oft wir etwas wiederholen wollen, bietet sich eine Z√§hlerschleife an:\n\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n\nVoil√†! Unsere 510 Zeilen Code k√∂nnen wir mit einer Schleife auf zwei Zeilen reduzieren! Dazu m√ºssen wir im Kopf der Schleife (for ... in ...) festlegen, wie oft der einger√ºckte Codeblock nach dem Doppelpunkt ausgef√ºhrt werden soll. In Python funktioniert das √ºber die Angabe einer Folge, f√ºr die jedes Element einmal durchlaufen wird. Das aktuelle Element ist in der Schleife als r verf√ºgbar. Und r nimmt nacheinander jeden Wert der Folge an, die nach dem Schl√ºsselwort in folgt. Diese Folge erzeugt hier die Funktion range(256), die ‚Äì wie der Name preisgibt ‚Äì eine Zahlenfolge von 0 bis zum angegebenen Wert minus eins erzeugt. In unserem Fall also von 0 bis 255.\nUm das besser nachvollziehen zu k√∂nnen, geben wir den Wert f√ºr r einfach mal aus:\n\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n1    print(r)\n\n\n1\n\nMit print() geben wir einen Wert auf der Konsole aus.\n\n\n\n\nJetzt wird es deutlich: Mit jedem Durchlauf der Schleife wird ein neuer Wert f√ºr r gesetzt und ausgegeben. Und zwar jeweils um eins erh√∂ht. Die Funktion range(256) erzeugt genau gesagt eine sortierte Reihe mit den Zahlen von 0 bis 255. Das sieht in Python dann so aus:\n\nlist_of_numbers = range(256)\n1print(list(list_of_numbers))\n\n\n1\n\nMit der list()-Funktion wandeln wir die von range() erzeugte Folge in eine Liste um, die wir dann ausgeben k√∂nnen.\n\n\n\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]\n\n\nR√ºckw√§rts erreichen wir das gleiche Ergebnis mit einer weiteren Schleife, deren Folge wir umkehren, sodass sie von 255 bis 0 geht:\n\nfor r in range(255, -1, -1):\n    led.set_rgb_value(r, 0, 0)\n\nWarum hat range() auf einmal drei Argumente? Ganz einfach: Standardm√§√üig erstellt die Funktion eine Folge von 0 bis zur angegebenen Zahl minus eins. Wir k√∂nnen die Folge aber beeinflussen, indem wir einen Startwert und einen Schrittwert angeben. In unserem Fall oben beginnen wir bei 255 (erster Parameter) und gehen bis -1 (zweiter Parameter), wobei wir in jedem Schritt um -1 verringern (dritter Parameter). Warum z√§hlen wir bis -1, wo wir doch eigentlich die 0 als kleinste Zahl ben√∂tigen? Das liegt daran, dass die Folge von range() immer bis zum zweiten Parameter minus eins geht. Wenn wir also 0 als kleinste Zahl ben√∂tigen, m√ºssen wir bis -1 z√§hlen.\nFassen wir unsere Erkenntnis zusammen und lassen die LED pulsieren:\n\nimport time\n\n# Increase red step by step\nfor r in range(256):\n    led.set_rgb_value(r, 0, 0)\n    time.sleep(0.001)\n\n# Stay at full brightness for a bit\ntime.sleep(0.25)\n\n# Decrease red step by step\nfor r in range(255, -1, -1):\n    led.set_rgb_value(r, 0, 0)\n    time.sleep(0.001)\n\nSoweit bekannt? Fast ‚Äì eine kleine Neuerung habe ich gerade eingebaut, n√§mlich die Funktion time.sleep(). Diese Funktion pausiert das Programm f√ºr die angegebene Zeit in Sekunden. In unserem Fall pausieren wir f√ºr 0,001 Sekunden, also 1 Millisekunde. Dadurch wird die LED langsamer heller und dunkler, was den Puls-Effekt verst√§rkt. Ohne diese Pause w√ºrde die LED so schnell aufleuchten, dass es f√ºr das menschliche Auge nicht mehr wahrnehmbar w√§re. Tats√§chlich w√ºrden wir auch die Hardware √ºberfordern, weil die LED gar nicht so schnell die Farbe wechseln kann. Das Programm w√ºrde abst√ºrzen.\nAm H√∂hepunkt warten wir erneut ‚Äì dieses Mal eine Viertelsekunde ‚Äì, bevor wir die LED langsam ausgehen lassen und den Rotanteil schrittweise wieder auf Null setzen. Dann endet unser Programm, leider viel zu fr√ºh. Die LED soll doch eigentlich weiter pulsieren, bis ‚Ä¶ ja, bis wann √ºberhaupt?\n\n\n1.3.2 Bedingte Wiederholungen\nBeim L√∂sen von Problemen sto√üen wir h√§ufig auf Situationen, in denen wir bestimmte Schritte wiederholt ausf√ºhren m√∂chten, aber nur unter bestimmten Bedingungen. Hier kommen bedingte Wiederholungen ins Spiel, die es uns erm√∂glichen, Schleifen zu erstellen, die nur dann fortgesetzt werden, wenn eine bestimmte Bedingung noch erf√ºllt ist.\nDas k√∂nnen wir auf unsere pulsierende LED anwenden. Sie soll ihren Pulsierzyklus Dunkel‚ÄìHell‚ÄìDunkel wiederholen, solange der Benutzer nicht unterbricht. Das ist zumindest ein pragmatisches Abbruchkriterium f√ºr unseren Fall. Wir definieren also hier keine feste Anzahl Wiederholungen wie bei der for ... in-Schleife, sondern wir wollen festlegen, unter welcher Bedingung die Schleife fortgesetzt wird. Wir k√∂nnten also sagen: solange die Bedingung X erf√ºllt ist, wiederhole die aufgef√ºhrten Schritte. Und weil Programmiersprachen f√ºr Menschen gemacht sind, klingt es im echten Programm auch so √§hnlich:\n\nwhile 1==1:\n    print(\"This condition is always true\")\n    time.sleep(1)\n\nDas Schl√ºsselwort while f√ºhrt eine bedingte Schleife ein, gefolgt von der Bedingung, die die Schleife steuert. Die Bedingung wird vor jedem neuen Schleifendurchlauf gepr√ºft (auch vor dem ersten) und sollte sie falsch (false) sein, wird die Schleife beendet.\nWann wird die Schleife oben also beendet? Richtig ‚Äì niemals. Die Bedingung 1==1 ist immer wahr, die Schleife l√§uft somit endlos. Wir sprechen auch von einer Endlosschleife, die wir in der Programmierung unbedingt vermeiden wollen, es sei denn, sie ist explizit gewollt und nicht versehentlich entstanden. Das kurze Programm oben schreibt also in Abst√§nden von einer Sekunde den Text ‚ÄúThis condition is always true‚Äù auf die Konsole.\nEine Bedingung ist in Python und anderen Programmiersprachen ein wichtiges Konzept, das es uns erm√∂glicht, Entscheidungen zu treffen und den Programmfluss zu steuern. In unserem Fall k√∂nnte die Bedingung lauten: solange der Benutzer nicht stoppt, wiederhole den Pulsierzyklus. Eine Bedingung hat die Eigenschaft, dass sie jederzeit ausgewertet werden kann und entweder den Wert wahr (true) oder falsch (false) annimmt. Wie aber dr√ºcken wir das in Python aus?\n\nwhile True:\n    print(\"I will loop forever\")\n    time.sleep(1)\n\nDie einfachste M√∂glichkeit ist es, das Ergebnis der Evaluation direkt hinzuschreiben. Die obige Schleife pr√ºft in jedem Durchgang, ob der Wert True wahr ist - was er nat√ºrlich ist. Das ist also so √§hnlich wie bei der Schleife weiter oben, die die Bedingung 1==1 gepr√ºft hat. Die ist ebenfalls immer True oder wahr.\nWir lernen im Laufe des Buches noch viele echte Bedingungen kennen, deren Ergebnis nicht von Vornherein bekannt ist. F√ºr unsere pulsierende LED reicht es aber aus, wenn wir eine gewollte Endlosschleife verwenden. Denn auch eine Endlosschleife k√∂nnen wir jederzeit verlassen, indem wir das Programm mit der Tastenkombination Strg+C abbrechen.\nWenn wir jetzt unseren Pulsierzyklus von oben in die neue bedingte while-Schleife einf√ºgen, sind wir schon am Ziel. Der Pulsierzyklus wird wiederholt, solange das Programm nicht abgebrochen wird:\n\nwhile True:\n\n    # Increase red step by step\n    for r in range(256):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, -1, -1):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)\n\nDer Vollst√§ndigkeit halber das Ganze inklusive des Boilerplate-Codes f√ºr die Verbindung zu den Tinkerforge-Ger√§ten:\n\n\n\n\nListing¬†1.2: Das fertige Programm, das die LED rot pulsieren l√§sst.\n\n\nimport time\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn LED off initially\nled.set_rgb_value(0, 0, 0)\n\nwhile True:\n\n    # Increase red step by step\n    for r in range(256):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full brightness for a bit\n    time.sleep(0.25)\n\n    # Decrease red step by step\n    for r in range(255, -1, -1):\n        led.set_rgb_value(r, 0, 0)\n        time.sleep(0.001)\n\n    # Stay at full dark for a bit\n    time.sleep(0.25)\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-hue-circle",
    "href": "colors.html#sec-colors-hue-circle",
    "title": "1¬† Farben",
    "section": "1.4 Farbkreise",
    "text": "1.4 Farbkreise\nDas RGB-Farbschema ist f√ºr Computer optimal, weil sich damit mit nur drei Zahlen jede beliebige Farbe kodieren l√§sst. Zahlen sind schlie√ülich die Sprache, mit der Computer am besten umgehen k√∂nnen. F√ºr uns Menschen ist dieses Schema jedoch weniger intuitiv. Oder k√∂nntet ihr auf Anhieb sagen, welche Farbe hinter der Kombination (67, 201, 182) steckt?\nUm Farben f√ºr uns leichter w√§hlbar zu machen, wurde der sogenannte Hue-Farbkreis entwickelt. Er ordnet die Farben auf einer Skala von 0 bis 360 Grad an ‚Äì √§hnlich wie die Winkel auf einem Kreis. Neben dem Farbton (Hue) lassen sich zus√§tzlich die S√§ttigung und die Helligkeit einstellen: Der Farbton bestimmt die eigentliche Farbe, die S√§ttigung, wie kr√§ftig oder blass sie wirkt, und die Helligkeit, wie hell oder dunkel sie erscheint.\n\n\n\n\n\n\nAbbildung¬†1.8: Die Farbauswahl in Google Slides funktioniert √ºber den Hue-Farbkreis.\n\n\n\nIn Abbildung¬†1.8 seht ihr, wie die Farbauswahl in Google Slides funktioniert. Mit dem Slider in der Mitte bestimmt ihr den Farbton. Habt ihr einen passenden Ton gefunden, k√∂nnt ihr im Rechteck dar√ºber durch Verschieben des kleinen Kreises die S√§ttigung und Helligkeit anpassen.\nBeobachtet ihr dabei die RGB-Werte, erkennt ihr die Systematik der Farbton-Skala: Ausgehend von reinem Rot wird Schritt f√ºr Schritt Gr√ºn hinzugef√ºgt ‚Äì so entstehen Orange und Gelb. Danach nimmt der Rotanteil ab, w√§hrend Blau hinzukommt. √úber Cyan gelangen wir zu reinem Blau. Schlie√ülich wird wieder Rot beigemischt, wodurch Violett bis Pink entstehen. Auf diese Weise bildet der Kreis den gesamten Regenbogen ab.\nDa die Skala am Ende wieder bei Rot ankommt, l√§sst sich der Farbverlauf nahtlos wiederholen ‚Äì ohne harte √úberg√§nge. Genau deshalb wird der Hue-Verlauf meist als Kreis dargestellt.\n\n\n\n\n\n\nAbbildung¬†1.9: Der Hue-Farbkreis mit HSV-Werten.\n\n\n\nAbbildung¬†1.9 zeigt den Hue-Farbkreis im HSV-Modell. HSV steht f√ºr Hue, Saturation, Value (Farbton, S√§ttigung, Helligkeit). Der Wert Value gibt die Helligkeit auf einer Skala von 0 bis 100‚ÄØ% an. Im Bild ist die Helligkeit konstant bei 100‚ÄØ%, w√§hrend die S√§ttigung von innen nach au√üen zunimmt. In der Mitte sehen wir deshalb Wei√ü, w√§hrend am √§u√üeren Rand die Farben ihre volle Intensit√§t haben.\nWenn wir ein Programm schreiben, das die gesamte Hue-Farbskala durchl√§uft und die LED jeweils in der passenden Farbe aufleuchten l√§sst, erhalten wir unser Regenbogenprogramm. Da die LED RGB-Werte ben√∂tigt, m√ºssen wir den Verlauf des Hue-Farbkreises in RGB umsetzen. Ein Blick auf die Animation in Abbildung¬†1.8 hilft: Der Farbverlauf l√§sst sich in sechs Phasen unterteilen, wie Abbildung¬†1.10 zeigt:\n\nRot = 255, Blau = 0, Gr√ºn steigt linear\nRot sinkt linear, Gr√ºn = 255, Blau = 0\nRot = 0, Gr√ºn = 255, Blau steigt linear\nRot = 0, Gr√ºn sinkt linear, Blau = 255\nRot steigt linear, Gr√ºn = 0, Blau = 255\nRot = 255, Gr√ºn = 0, Blau sinkt linear\n\nDann beginnt der Zyklus von vorn.\n\n\n\n\n\n\nAbbildung¬†1.10: Der Hue-Farbverlauf mit den Ver√§nderungen der RGB-Werte (Quelle: Ronja‚Äôs Tutorials).",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "colors.html#sec-colors-rainbow-led",
    "href": "colors.html#sec-colors-rainbow-led",
    "title": "1¬† Farben",
    "section": "1.5 Regenbogen-LED",
    "text": "1.5 Regenbogen-LED\nMit dem Wissen k√∂nnen wir uns an das erkl√§rte Ziel unseres Experiments machen: die LED nacheinander in allen Farben des Regenbogens aufleuchten zu lassen. Beginnen wir mit der ersten Phase und schreiben daf√ºr ein Python-Programm:\n\nfor green in range(256):\n    led.set_rgb_value(255, green, 0)\n    time.sleep(0.01)\n\nWeil wir genau wissen, wie oft wir die Schleife durchlaufen wollen, verwenden wir eine for-Schleife. Innerhalb der Schleife erh√∂hen wir die Variable green jeweils um 1, was effektiv den Gr√ºnanteil unseres RGB-Wertes erh√∂ht. Mit jedem Durchlauf f√ºgen wir somit mehr Gr√ºn hinzu, w√§hrend Rot und Blau konstant bleiben. Phase 1 ist damit abgeschlossen ‚Äì machen wir weiter mit Phase 2:\n\nfor red in range(255, -1, -1):\n    led.set_rgb_value(red, 255, 0)\n    time.sleep(0.01)\n\nWie wir mit einer for-Schleife r√ºckw√§rts z√§hlen, haben wir schon weiter oben kennengelernt. In Phase 2 verringern wir schrittweise den Rotanteil, w√§hrend die anderen beiden Farben konstant bleiben. Damit kommen wir zu Phase 3:\n\nfor blue in range(256):\n    led.set_rgb_value(0, 255, blue)\n    time.sleep(0.01)\n\nIch glaube, ihr habt das Prinzip verstanden. Indem wir die sechs Phasen jeweils in einer eigenen Schleife abarbeiten, erhalten wir das vollst√§ndige Regenbogenprogramm:\n\n# phase 1\nfor green in range(256):\n    led.set_rgb_value(255, green, 0)\n    time.sleep(0.01)\n\n# phase 2\nfor red in range(255, -1, -1):\n    led.set_rgb_value(red, 255, 0)\n    time.sleep(0.01)\n\n# phase 3\nfor blue in range(256):\n    led.set_rgb_value(0, 255, blue)\n    time.sleep(0.01)\n\n# phase 4\nfor green in range(255, -1, -1):\n    led.set_rgb_value(0, green, 255)\n    time.sleep(0.01)\n\n# phase 5\nfor red in range(256):\n    led.set_rgb_value(red, 0, 255)\n    time.sleep(0.01)\n\n# phase 6\nfor blue in range(255, -1, -1):\n    led.set_rgb_value(255, 0, blue)\n    time.sleep(0.01)\n\nWie sch√∂n üåà Eine Sache fehlt aber noch.\n\n1.5.1 Runde f√ºr Runde\nDer Regenbogen soll am Ende wieder von vorne beginnen. Wie schon beim Pulsieren der Farben k√∂nnen wir auch hier eine while-Schleife verwenden und die Phasen kontinuierlich abspielen ‚Äì solange, bis der Benutzer die Escape-Taste dr√ºckt:\n\nwhile True:\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(0.01)\n\n    # phase 2\n    for red in range(255, -1, -1):\n        led.set_rgb_value(red, 255, 0)\n        time.sleep(0.01)\n\n    # phase 3\n    for blue in range(256):\n        led.set_rgb_value(0, 255, blue)\n        time.sleep(0.01)\n\n    # phase 4\n    for green in range(255, -1, -1):\n        led.set_rgb_value(0, green, 255)\n        time.sleep(0.01)\n\n    # phase 5\n    for red in range(256):\n        led.set_rgb_value(red, 0, 255)\n        time.sleep(0.01)\n\n    # phase 6\n    for blue in range(255, -1, -1):\n        led.set_rgb_value(255, 0, blue)\n        time.sleep(0.01)\n\nWir haben es fast geschafft! Eine Kleinigkeit wollen wir an unserem Programm noch verbessern.\n\n\n1.5.2 Geschwindigkeit steuern\nVielleicht habt ihr gemerkt, dass die Geschwindigkeit, mit der unsere LED den gesamten Regenbogen einmal durchl√§uft, nicht sehr hoch ist. Ich w√ºrde das gerne beschleunigen. Die Zeit steuern wir √ºber die time.sleep()-Funktion, sodass wir einfach den Wert in jedem Funktionsaufruf verringern k√∂nnten. Das w√§re aber nicht sehr effizient, weil wir ihn an sechs Stellen anpassen m√ºssen. Wenn wir danach merken, dass es zu schnell ist, m√ºssten wir den Wert erneut √ºberall editieren. Das geht einfacher!\nDer Trick liegt darin, den Wert f√ºr die Wartedauer als Variable zu definieren und nur an einer Stelle zu √§ndern.\n\npause_duration = 0.01\nwhile not keyboard.is_pressed('esc'):\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # etc.\n\nSchon besser! Wir gehen aber noch einen Schritt weiter. Statt dieses kleinteiligen Werts f√ºr eine Pause zwischen zwei kleinen Farbver√§nderungen m√∂chte ich die Gesamtdauer f√ºr den Durchlauf eines Regenbogens angeben. Der Wert pause_duration soll dann auf dieser Basis errechnet werden. Dazu m√ºssen wir nur die Anzahl der Pausen insgesamt kennen; in jeder der sechs Phasen sind es 256. Macht also:\n\\[\n6 \\times 256 = 1536\n\\]\nIm Programm setzen wir die Pausendauer also auf die Gesamtdauer in Sekunden geteilt durch 1536:\n\nrainbow_duration = 5\npause_duration = rainbow_duration / 1536\n\nwhile not keyboard.is_pressed('esc'):\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # etc.\n\nUnd schon k√∂nnen wir unseren Regenbogen beliebig zeitlich steuern. Damit sind wir am Ende des Kapitels angekommen. Wir schlie√üen es mit dem vollst√§ndigen Code f√ºr unseren Regenbogenverlauf in Listing¬†1.3 ab. Vergesst nicht, den Wert f√ºr die UID eurer LED anzupassen, damit es auch bei euch funktioniert:\n\n\n\n\nListing¬†1.3: Das fertige Regenbogenprogramm.\n\n\nimport time\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223) \nled = BrickletRGBLEDV2('ZEP', ipcon)\n\n# Turn LED off initially\nled.set_rgb_value(0, 0, 0)\n\nrainbow_duration = 5\npause_duration = rainbow_duration / 1536\n\nwhile True:\n\n    # phase 1\n    for green in range(256):\n        led.set_rgb_value(255, green, 0)\n        time.sleep(pause_duration)\n\n    # phase 2\n    for red in range(255, -1, -1):\n        led.set_rgb_value(red, 255, 0)\n        time.sleep(pause_duration)\n\n    # phase 3\n    for blue in range(256):\n        led.set_rgb_value(0, 255, blue)\n        time.sleep(pause_duration)\n\n    # phase 4\n    for green in range(255, -1, -1):\n        led.set_rgb_value(0, green, 255)\n        time.sleep(pause_duration)\n\n    # phase 5\n    for red in range(256):\n        led.set_rgb_value(red, 0, 255)\n        time.sleep(pause_duration)\n\n    # phase 6\n    for blue in range(255, -1, -1):\n        led.set_rgb_value(255, 0, blue)\n        time.sleep(pause_duration)\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.\n\n\nSeid ihr bereit f√ºr das n√§chste Experiment?\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Farben</span>"
    ]
  },
  {
    "objectID": "numbers.html",
    "href": "numbers.html",
    "title": "2¬† Zahlen",
    "section": "",
    "text": "Zusammenfassung\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#zusammenfassung",
    "href": "numbers.html#zusammenfassung",
    "title": "2¬† Zahlen",
    "section": "",
    "text": "Wir verstehen wie ein Computer Zahlen darstellt und speichert.\nWir f√ºhren das Bit als zentrale Informationseinheit im Computer ein.\nWir lernen Kontrollstrukturen kennen, mit denen wir unser Programm steuern k√∂nnen.\nWir f√ºgen Funktionen zu unserem Werkzeugkasten hinzu, um besseren Code zu schreiben.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#experimentaufbau",
    "href": "numbers.html#experimentaufbau",
    "title": "2¬† Zahlen",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\nDas erste Experiment in Kapitel 1 war ein guter Einstieg! In diesem Kapitel legen wir noch eine Schippe drauf: Unsere Hardware bekommt ein neues Bauteil ‚Äì einen Drehknopf (Rotary Encoder Bricklet 2.0). Das montiert ihr einfach neben der LED, wie in Abbildung¬†2.1 gezeigt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Draufsicht.\n\n\n\n\n\n\n\n\n\n\n\n(c) Nahaufnahme des Rotary Encoders.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n(e) Untenansicht.\n\n\n\n\n\n\n\nAbbildung¬†2.1: Einfaches Setup mit einem Mikrocontroller, LED und einem Drehknopf.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-first-steps",
    "href": "numbers.html#sec-numbers-first-steps",
    "title": "2¬† Zahlen",
    "section": "2.1 Erste Schritte mit dem Drehknopf",
    "text": "2.1 Erste Schritte mit dem Drehknopf\nWie bei der LED werfen wir zuerst einen Blick auf den neuen Drehknopf im Brick Viewer. Schlie√üt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Setup-Tab sollte nun neben der LED auch der Rotary Encoder auftauchen. Denkt daran: Dort findet ihr auch die UID eurer Ger√§te ‚Äì die braucht ihr gleich f√ºr euer Programm.\n\n\n\n\n\n\nAbbildung¬†2.2: Der Brick Viewer nach dem Connect.\n\n\n\nWechselt nun in den Tab f√ºr den Drehknopf, wo ihr ihn direkt testen k√∂nnt: Ihr seht den aktuellen Z√§hlwert. Der kann positiv oder negativ sein ‚Äì je nachdem, wie oft und in welche Richtung ihr gedreht habt. Daneben zeigt ein Diagramm die zeitliche Entwicklung.\nDoch der Knopf kann mehr als nur z√§hlen: Ihr k√∂nnt ihn auch dr√ºcken. Achtet mal auf den kleinen Kreis im Brick Viewer. Wird er gedr√ºckt, leuchtet er rot. Noch l√∂st das Dr√ºcken keine Aktion aus, aber wir √ºberlegen sp√§ter, welche Funktion wir damit verbinden wollen.\nUnd zuletzt: der Button Reset Count. Damit setzt ihr den Z√§hler zur√ºck ‚Äì eine praktische Funktion, die wir sp√§ter ebenfalls ins Programm einbauen k√∂nnen.\n\n\n\n\n\n\n\n\nDas Diagramm zeigt den aktuellen Wert an.\n\n\n\n\n\n\n\n\n\n\n(a) Der Button wird rot, wenn er gedr√ºckt ist.\n\n\n\n\n\n\n\nAbbildung¬†2.3: Die Funktionen des Rotary Encoders im Brick Viewer.\n\n\n\nFassen wir zusammen, was unser Drehknopf (Rotary Encoder) draufhat:\n\nEr z√§hlt ‚Äì vorw√§rts und r√ºckw√§rts\nEr merkt, wenn ihr ihn dr√ºckt\nEr kann seinen Z√§hler zur√ºcksetzen\n\nZeit also, das Ganze in Python auszuprobieren und zu sehen, welche coolen Anwendungen wir damit bauen k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#z√§hler-auslesen",
    "href": "numbers.html#z√§hler-auslesen",
    "title": "2¬† Zahlen",
    "section": "2.2 Z√§hler auslesen",
    "text": "2.2 Z√§hler auslesen\nDer Drehknopf funktioniert √§hnlich wie der Lautst√§rkeregler einer Stereoanlage (siehe Abbildung¬†2.4): Dreht ihr nach rechts, wird es lauter ‚Äì nach links, leiser.\n\n\n\n\n\n\nAbbildung¬†2.4: Die gute alte Stereoanlage mit Drehknopf! Wer kennt sie nicht mehr? (Quelle: Wikimedia)\n\n\n\nIm Hintergrund ver√§ndert sich bei jeder Drehung der Wert, den der Knopf sendet ‚Äì mal h√∂her, mal niedriger, je nach Ausgangszustand. Im Brick Viewer habt ihr das schon gesehen. Probieren wir es jetzt in einem Programm aus: Der folgende Code verbindet sich mit dem Drehknopf, liest den aktuellen Wert und gibt ihn in der Konsole aus. Denkt daran, eure eigene UID einzutragen:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\n1knob = BrickletRotaryEncoderV2('WZd', ipcon)\n2count = knob.get_count(reset=False)\nprint(count)\n\n\n1\n\nWir erstellen eine virtuelle Repr√§sentation des Drehknopfs in unserem Programm, um seine Funktionen verwenden zu k√∂nnen.\n\n2\n\n√úber die virtuelle Repr√§sentation des Drehknopfs k√∂nnen wir mittels get_count() den aktuellen Wert abfragen. Der Parameter reset bestimmt, ob der Z√§hler nach dem Auslesen zur√ºckgesetzt werden soll oder nicht.\n\n\n\n\nDie Ausgabe sollte mit dem Wert √ºbereinstimmen, den ihr auch im Brick Viewer seht ‚Äì kein Wunder, beide nutzen dieselbe Programmierschnittstelle. Damit habt ihr die erste Funktion des Drehknopfs erfolgreich aus Python getestet.\nDreht ihr den Knopf und startet das Programm erneut, erscheint nat√ºrlich ein anderer Wert. Klar! Aber jedes Mal neu starten? Das geht besser. Die L√∂sung kennt ihr schon aus Kapitel 1: eine Schleife, die das Programm so lange wiederholt, bis wir es beenden:\n\nwhile True:\n    count = knob.get_count(reset=False)\n    print(count)\n\nZur Erinnerung: while True erzeugt eine Endlosschleife. Normalerweise wollen wir so etwas vermeiden ‚Äì au√üer, wir brauchen es genau daf√ºr. Endlosschleifen sind praktisch, wenn wir kontinuierlich Daten lesen oder auf Ereignisse warten. Und keine Sorge: Mit Strg+C k√∂nnt ihr das Programm jederzeit beenden.\nWenn ihr das Programm ausf√ºhrt, werdet ihr direkt ein Problem erkennen. Die Schleife rennt f√∂rmlich und gibt nacheinander immer wieder denselben Wert aus. Nur wenn wir am Knopf drehen, √§ndert sich der Wert ‚Äì wird aber von der Schleife x-mal auf die Konsole geschrieben. Wie k√∂nnten wir das verbessern?",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-control-structures",
    "href": "numbers.html#sec-numbers-control-structures",
    "title": "2¬† Zahlen",
    "section": "2.3 Kontrollstrukturen",
    "text": "2.3 Kontrollstrukturen\nWie w√§re es hiermit?\n\nlast_count = None\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n        print(last_count)\n\nGehen wir durch, was hier passiert: Zuerst weisen wir der Variable last_count vor dem ersten Schleifendurchlauf den Wert None zu. Anschlie√üend wird in jedem Durchlauf der aktuelle Z√§hlerstand ausgelesen und in der Variable new_count gespeichert. Danach pr√ºfen wir, ob sich der neue Wert im Vergleich zum alten unterscheidet. Da last_count im ersten Durchlauf None ist, wird die Bedingung in Zeile 5 beim Start immer True sein. Somit geben wir den Wert zu Beginn auf jeden Fall aus ‚Äì genau so, wie es f√ºr die Anwendung sinnvoll ist.\nIn den folgenden Schleifendurchl√§ufen wird nur dann etwas ausgegeben, wenn sich der Wert ver√§ndert hat, ihr also tats√§chlich am Drehknopf gedreht habt. Ansonsten bleibt die Ausgabe unver√§ndert.\nDie Pr√ºfung, ob der aktuelle Wert (gespeichert in new_count) sich vom alten Wert unterscheidet, erfolgt in Zeile 5. Hier lernen wir auch ein neues Konzept der Programmierung kennen: die Kontrollstruktur if, gefolgt von einer Bedingung.\nNeu ist hier die Kontrollstruktur if. Sie pr√ºft eine Bedingung, die ‚Äì wie ihr schon aus Kapitel 1 kennt ‚Äì nur True oder False sein kann. Ist sie wahr (True), l√§uft der einger√ºckte Code darunter. Ist sie falsch (False), passiert nichts.\n√úbertragen auf unser Programm hei√üt das: print(last_count) l√§uft nur dann, wenn sich der Wert tats√§chlich ver√§ndert hat. In diesem Fall merken wir uns den neuen Wert und aktualisieren last_count. Beim n√§chsten Schleifendurchlauf pr√ºfen wir wieder, ob sich etwas getan hat. Meistens ist das nicht so ‚Äì und genau deshalb sehen wir nur dann eine Ausgabe, wenn wir wirklich am Knopf drehen. Ziemlich effizient, oder?",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#led-dimmer-1.0",
    "href": "numbers.html#led-dimmer-1.0",
    "title": "2¬† Zahlen",
    "section": "2.4 LED-Dimmer 1.0",
    "text": "2.4 LED-Dimmer 1.0\nWenden wir das Gelernte an und bauen einen praktischen LED-Dimmer. Daf√ºr holen wir unsere LED aus Kapitel 1 mit dazu und kombinieren sie mit dem Drehknopf.\nDie Idee ist simpel: Der Z√§hler des Knopfs steuert die Helligkeit der LED. Dreht ihr nach rechts, wird sie heller, nach links, dunkler. Wie bei der Stereoanlage in Abbildung¬†2.4.\nBevor wir uns an die eigentliche Anwendungslogik machen, brauchen wir Zugriff auf beide Ger√§te ‚Äì LED und Drehknopf. Dazu erweitern wir den bekannten Boilerplate-Code und speichern die Ger√§te in eigenen Variablen:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nknob = BrickletRotaryEncoderV2('WZd', ipcon) \nled = BrickletRGBLEDV2('ZG1', ipcon)\n\nDieser Teil muss immer am Anfang unseres Programms stehen, damit alles funktioniert. In den kommenden Beispielen setzen wir ihn als gegeben voraus und wiederholen ihn nicht jedes Mal.\nAls Startpunkt nehmen wir den Code von oben, der den Z√§hlerwert auf der Konsole ausgibt. Schlie√ülich brauchen wir genau diese Information ‚Äì wann sich der Wert √§ndert und wie er aktuell steht ‚Äì auch, um die LED zu steuern.\nDamit wir die LED von aus bis volle Helligkeit dimmen k√∂nnen, legen wir uns zuerst auf eine Farbe fest. Ich bin zwar kein Fan von wei√üem LED-Licht, aber f√ºr dieses Kapitel ist es am einfachsten: voll aufgedreht leuchtet die LED wei√ü, ausgedreht ist sie schwarz ‚Äì klar! Sp√§ter k√ºmmern wir uns darum, wie wir das Licht w√§rmer machen k√∂nnen.\nErinnern wir uns also: Was bedeuten die Zust√§nde An und Aus im RGB-Farbraum?\n\n# White\nled.set_rgb_value(255, 255, 255)\n\n# Black (off)\nled.set_rgb_value(0, 0, 0)\n\nDamit haben wir die beiden Extremzust√§nde festgelegt. Doch was passiert dazwischen, wenn die LED gedimmt ist? Ganz einfach: Wir lassen die drei RGB-Werte gemeinsam von 1 bis 254 hoch- oder runterlaufen. H√∂here Werte ergeben ein helleres Wei√ü, niedrigere ein dunkleres.\nSetzen wir diese Erkenntnisse in Programmcode um und weisen den Z√§hlerwert den RGB-Werten der LED zu. Spoiler-Alert: Das ist etwas naiv, aber lasst uns mal schauen, was passiert und wo m√∂glicherweise Probleme auftreten:\n\nknob.reset()\nlast_count = 0\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n        print(last_count)\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(last_count, last_count, last_count)\n\nLasst es mal laufen und dreht voll auf oder runter! Beobachtet dabei den Wert f√ºr last_count. Was passiert, wenn er kleiner als Null wird? Oder wenn er gr√∂√üer als 255 wird? Bumm! Das Programm st√ºrzt ab!\nWarum? Auf der Kommandzeile bekommen wir eine lange Fehlermeldung mit der folgenden Aussage ganz am Ende:\n#| code-line-numbers: false\nstruct.error: ubyte format requires 0 &lt;= number &lt;= 255\nWenn man die Fehlermeldung googelt oder ChatGPT befragt, bekommt man Hilfe. Offensichtlich wird f√ºr einen RGB-Wert, den wir der Funktion set_rgb_value() √ºbergeben, ein bestimmter Datentyp erwartet, der ubyte hei√üt. Das steht f√ºr ‚Äúunsigned byte‚Äù und bedeutet, dass der Wert zwischen 0 und 255 liegen muss.\nMoment üßê ‚Äì was hat jetzt das Byte mit 0 bis 255 zu tun? Bisher dachten wir doch, das w√§re wegen des RGB-Codes? Stimmt auch, aber der RGB-Code liegt nicht zuf√§llig im Wertebereich von 0 bis 255.\nUm das zu verstehen, m√ºssen wir das Bin√§rsystem kennen. Also los!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#zahlensysteme",
    "href": "numbers.html#zahlensysteme",
    "title": "2¬† Zahlen",
    "section": "2.5 Zahlensysteme",
    "text": "2.5 Zahlensysteme\nEigentlich ist es schnell erkl√§rt. Das Bin√§rsystem ist wie das Dezimalsystem, mit dem wir allt√§glich unterwegs sind ‚Äì nur nutzt es statt der Basis 10 die Basis 2. Einfach, oder? Wenn nicht, lest weiter ‚Äì das hier soll schlie√ülich ein Einf√ºhrungsbuch sein.\n\n2.5.1 Unser Dezimalsystem\nWir wenden das Dezimalsystem t√§glich intuitiv an. Es fragt sich wahrscheinlich niemand von euch, was die Systematik dahinter ist, oder? Und doch habt ihr es alle einmal in der Schule gelernt, und wir m√ºssen es an dieser Stelle etwas auffrischen. Solltet ihr mit Stellenwertsystemen noch 100 % vertraut sein, k√∂nnt ihr diesen Abschnitt getrost √ºberspringen.\nNehmen wir eine Zahl wie die 123 als Beispiel. Wir haben sofort ein Gef√ºhl f√ºr die Zahl, wir wissen etwa, wie gro√ü sie ist. Und wenn wir es etwas genauer erkl√§ren m√ºssen, k√∂nnen die meisten von euch sicher erl√§utern, wof√ºr ‚Äì also f√ºr welchen Wert ‚Äì jede Ziffer steht. Wir beginnen mit der kleinsten Wertigkeit, also der Ziffer ganz rechts: der 3. Sie steht f√ºr die Einserstelle, und davon haben wir 3. Die n√§chste Stelle steht f√ºr die Zehner, und weil dort eine 2 steht, sind es zwanzig. Also \\(3+20=23\\). Schlie√üen wir auch die dritte und letzte Ziffer in unsere Erl√§uterung ein: Die 1 steht f√ºr die Hunderterstelle, also \\(1*100=100\\). Damit haben wir \\(100+20+3=123\\). Ganz einfach und intuitiv.\n\n\n\n\n\n\n\n\n\n\n\n(a) Im Dezimalsystem hat jede Stelle einen anderen Wert.\n\n\n\n\n\n\n\n\n\n\n\n(b) Durch Ausmultiplizieren errechnen wir den Wert der Zahl.\n\n\n\n\n\n\n\nAbbildung¬†2.5: Das Dezimalsystem ist ein Stellenwertsystem.\n\n\n\nDas Ganze funktioniert nicht nur mit dreistelligen Zahlen, sondern prinzipiell mit beliebig langen Zahlen. Wir wissen, dass die n√§chste Ziffer, die wir links im Beispiel in Abbildung¬†2.6 sehen, f√ºr die Tausenderstelle steht. Die n√§chste Stelle w√ºrde f√ºr die Zehntausenderstelle stehen ‚Äì und so weiter. Warum f√§llt es uns so leicht?\nErstens, weil wir damit jeden Tag umgehen. Das Dezimalsystem ist das System, das wir am h√§ufigsten verwenden, und wir haben es von klein auf gelernt. Es ist intuitiv und einfach zu verstehen. Zweitens aber auch, weil wir die Systematik kennen: Jede Stelle ist 10-mal so viel wert wie die vorherige.\n\n\n\n\n\n\nAbbildung¬†2.6: Jede Stelle steht f√ºr eine h√∂here Potenz der Basis 10.\n\n\n\nWurde uns das Dezimalsystem von Gott gegeben? Vielleicht ‚Äì wenn man an die Sch√∂pfung glaubt1 und daran, dass Gott uns so geschaffen hat, wie wir sind, dann hat er implizit daf√ºr gesorgt, dass wir dezimal denkende Wesen werden. Warum? Eine Theorie besagt, dass die menschliche Anatomie, insbesondere die Anzahl der Finger, einen Einfluss auf unser Zahlensystem hatte. Z√§hlt einfach mal anhand eurer Finger durch.\n\n\n2.5.2 Das Oktalsystem\nNun gibt es auch Wesen mit weniger als zehn Fingern (und auch mit mehr?). Nehmt mal einen Cartoon-Charakter wie Mickey Mouse als Beispiel. In Abbildung¬†2.7 seht ihr, wie hier wahrscheinlich gez√§hlt wird. H√§tte ein Volk von Mickey-M√§usen sich auch f√ºr das Dezimalsystem entschieden?\n\n\n\n\n\n\nAbbildung¬†2.7: Cartoon-Charaktere haben nur acht Finger. Quelle: Erstellt mit ChatGPT nach Petzold (2022)\n\n\n\nVermutlich nicht!\n\n\n\n\n\n\nAbbildung¬†2.8: Das Oktalsystem funktioniert wie das Dezimalsystem. Nur die Basis ist 8 statt 10.\n\n\n\n\n\n2.5.3 Das Bin√§rsystem\nTreiben wir es noch ein wenig weiter auf die Spitze und nehmen ein paar Finger weg ‚Äì sagen wir bis auf zwei. Dann w√§ren wir vielleicht bei einem Delfin mit zwei Flossen, wie ihr ihn in Abbildung¬†2.9 seht. Delfine haben sich vermutlich auf ein System geeinigt, das auch f√ºr unsere heutigen Computer die Grundlage darstellt: das Bin√§rsystem.\n\n\n\n\n\n\nAbbildung¬†2.9: Delfine w√ºrden anders z√§hlen. Eher wie Computer.\n\n\n\nDas Wort ‚Äúbin√§r‚Äù stammt aus dem Lateinischen und bedeutet ‚Äúpaarweise‚Äù oder ‚Äúzu zweit‚Äù. Von diesem Wort stammt auch der Name des Stellenwertsystems mit der Basis 2 ‚Äì und das nicht ohne Grund. Im Bin√§rsystem gibt es f√ºr jede Stelle genau zwei M√∂glichkeiten: 0 oder 1. Ein anderer Begriff ist √ºbrigens Dualsystem, was genau das Gleiche meint. Auch das Wort ‚Äúdual‚Äù kommt von den R√∂mern und hei√üt so viel wie ‚Äúzwei enthaltend‚Äù.\n\n\n\n\n\n\nAbbildung¬†2.10: Eine Bin√§rziffer ist vergleichbar mit einem Lichtschalter, der an oder aus sein kann.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a)\n\n\n\n\n\n\n\n\n\n\n\n(b)\n\n\n\n\n\n\n\nAbbildung¬†2.11: Das Bin√§rsystem funktioniert wie alle anderen Stellenwertsysteme auch.\n\n\n\n\n\n\n2.5.4 Andere Systeme\n\nR√∂mische Zahlen\nTally-Schreibweise",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-bit-and-bytes",
    "href": "numbers.html#sec-numbers-bit-and-bytes",
    "title": "2¬† Zahlen",
    "section": "2.6 Bits & Bytes",
    "text": "2.6 Bits & Bytes\n\n2.6.1 Zwei Zust√§nde\nWarum haben wir uns Zahlensysteme angeschaut, und was hat das mit Computern zu tun? Ganz einfach: Computer denken bin√§r. Das bedeutet, sie kennen nur zwei Zust√§nde: an oder aus, 0 oder 1.\nWir kommen sp√§ter noch einmal ausf√ºhrlich darauf zur√ºck, aber so viel schon vorweg: Eine Bin√§rziffer nennen wir im Englischen ‚Äúbinary digit‚Äù, kurz ‚Äúbit‚Äù. Jetzt klingelt es, oder?\nEin Bit ist eine Informationseinheit. Nicht irgendeine, sondern die kleinste, die es gibt. Die Erkl√§rung, warum das so ist, folgt sp√§ter. Wir wollen uns an dieser Stelle die Frage stellen, was wir mit einem Bit alles anstellen k√∂nnen.\nEin Bit ist alleine ziemlich einsam und eingeschr√§nkt. Wenn sich ein Computer mit einem Bit lediglich merken kann, ob eine Lampe an oder aus ist, dann sind das genau zwei M√∂glichkeiten. Nicht besonders viel. Wir kamen aber von den Farben √ºber Zahlensysteme zu den Bits ‚Äì und unsere urspr√ºngliche Frage war, wie ein Computer mit seinen Mitteln ‚Äì also Nullen und Einsen (oder eben Bits) ‚Äì so viele unterschiedliche Farben abbilden und speichern kann. Zwei w√ºrden gerade einmal f√ºr Schwarz/Wei√ü ausreichen.\nIhr ahnt es vielleicht schon: Wir gesellen zum ersten ein zweites Bit hinzu. Und schon k√∂nnen wir vier unterschiedliche Zust√§nde abbilden: 00, 01, 10 und 11. Damit k√∂nnten wir zum Beispiel die Farben Schwarz, Blau, Gr√ºn und Cyan darstellen. Etwas willk√ºrlich (warum gerade diese Farben), aber denkbar.\nWas passiert, wenn wir ein drittes Bit hinzunehmen? Sind es nun sechs Zust√§nde? Nein, es sind acht: 000, 001, 010, 011, 100, 101, 110 und 111. Damit k√∂nnten wir die Farben Schwarz, Blau, Gr√ºn, Cyan, Rot, Magenta, Gelb und Wei√ü darstellen (oder jede andere Kombination, die wir uns w√ºnschen).\nMit jedem zus√§tzlichen Bit k√∂nnen wir also nicht plus zwei mehr Zust√§nde abbilden, sondern wir verdoppeln unsere M√∂glichkeiten. Also m√ºssen wir mal zwei ‚Äì und nicht plus zwei ‚Äì rechnen. Das ist eine gute Nachricht, denn die Anzahl der Farben, die wir mit jedem zus√§tzlichen Bit darstellen k√∂nnen, verdoppelt sich jedes Mal.\nDas halten wir fest, aber schauen wir zur√ºck auf unsere RGB-Farben und die Fehlermeldung, die wir zuletzt bekommen haben. Der Wert f√ºr eine Farbe aus dem RGB-Farbcode muss zwischen 0 und 255 liegen. Wir haben somit inklusive der Null 256 M√∂glichkeiten f√ºr jede der drei RGB-Grundfarben. Wie viele Bits ben√∂tigen wir daf√ºr? Rechnen wir es aus:\n\\[\n\\begin{aligned}\n2^0 &= 1 \\\\\n2^1 &= 2 \\\\\n2^2 &= 4 \\\\\n2^3 &= 8 \\\\\n2^4 &= 16 \\\\\n2^5 &= 32 \\\\\n2^6 &= 64 \\\\\n2^7 &= 128 \\\\\n2^8 &= 256 \\\\\n\\end{aligned}\n\\]\nStopp! \\(2^8 = 256\\), das gen√ºgt uns v√∂llig. Mit 8 Bits k√∂nnen wir somit 256 Zust√§nde abbilden ‚Äì genau passend f√ºr 256 Rot-, Gr√ºn- oder Blauanteile.\n\n\n2.6.2 Acht Bits macht ein Byte\nUnd das ist kein Zufall: 8 Bits sind f√ºr Computer eine besondere Gr√∂√üe. Wir nennen eine Gruppe von 8 Bits ein Byte. Und jetzt d√ºrfte es erneut klingeln.\n\n\n\n\n\n\nAbbildung¬†2.12: Ein Byte k√∂nnt ihr euch vorstellen wie acht Gl√ºhbirnen nebeneinander.\n\n\n\nIn Abbildung¬†2.12 ist ein Byte als Reihe von acht Gl√ºhbirnen dargestellt. Ihr k√∂nnt euch vorstellen, dass Bits mit dem Wert 1 leuchten und Bits mit dem Wert 0 aus sind. Um den Wert zu ermitteln, den das Byte gerade darstellt, k√∂nnt ihr jeder Gl√ºhbirne von rechts nach links die entsprechenden Wertigkeiten der Stellen aus dem Bin√§rsystem zuweisen und die Werte addieren. Stellen, an denen die Gl√ºhbirne leuchtet, werden addiert, die anderen werden ausgelassen (Abbildung¬†2.13). Das Byte im gezeigten Beispiel steht somit f√ºr:\n\\[\n32 + 8 + 1 = 41\n\\]\nWof√ºr steht das Byte, wenn alle Lampen leuchten? Oder anders gefragt: Was ist die gr√∂√üte Zahl, die wir mit einem Byte darstellen k√∂nnen?\n\\[\n128+64+32+16+8+4+2+1 = 255\n\\]\nDie Antwort √ºberrascht uns nicht, denn schlie√ülich haben wir es ja schon herausgefunden: Ein Byte erlaubt uns, Werte zwischen 0 (alle Gl√ºhbirnen aus) und 255 (alle Gl√ºhbirnen an) darzustellen. Insgesamt also 256 M√∂glichkeiten. Somit k√∂nnen wir mit 8 Gl√ºhbirnen die Intensit√§t einer der drei Grundfarben im RGB-Code darstellen.\n\n\n\n\n\n\nAbbildung¬†2.13: Jede Gl√ºhbirne steht f√ºr eine Stelle aus dem Bin√§rsystem.\n\n\n\nDas erkl√§rt auch die Fehlermeldung von oben: Ein Byte kann Werte zwischen 0 und 255 darstellen. Wir haben im Experiment den Drehknopf voll nach oben oder nach unten gedreht, wodurch der Wert entweder gr√∂√üer als 255 oder kleiner als 0 wurde. Und damit ist es kein g√ºltiger Wert im Sinne eines Bytes mehr.\n\n\n2.6.3 Kilo, Mega, Giga\nEin Byte besteht aus 8 Bits. Wenn wir also von Bytes sprechen, reden wir oft auch von Kilobytes, Megabytes, Gigabytes et cetera. Diese Begriffe sind wichtig, um die Gr√∂√üe von Daten zu beschreiben. In Tabelle¬†2.1 seht ihr eine √úbersicht √ºber die verschiedenen Gr√∂√üenordnungen.\n\n\n\nTabelle¬†2.1: Verschiedene Mengeneinheiten f√ºr Bytes und deren ungef√§hre Entsprechung.\n\n\n\n\n\n\n\n\n\n\n\nPotenz (Bytes)\nAusgeschrieben\nBezeichnung (Abk√ºrzung)\nEntspricht ca.\n\n\n\n\n\\(10^3\\)\nTausend\nKilobyte (KB)\nkleine Textdatei\n\n\n\\(10^6\\)\nMillion\nMegabyte (MB)\nDigitales Foto\n\n\n\\(10^9\\)\nMilliarde\nGigabyte (GB)\nFilm (DVD 4,7 GB)\n\n\n\\(10^{12}\\)\nBillion\nTerabyte (TB)\nG√§ngige Festplattenkapazit√§t\n\n\n\\(10^{15}\\)\nBilliarde\nPetabyte (PB)\nSpeichervolumen Rechenzentrum\n\n\n\\(10^{18}\\)\nTrillion\nExabyte (EB)\nInternetverkehr pro Tag\n\n\n\\(10^{21}\\)\nTrilliarde\nZettabyte (ZB)\nDatenbestand weltweit (&gt;100 ZB)\n\n\n\\(10^{24}\\)\nQuadrillion\nYottabyte (YB)\nkeine Entsprechung\n\n\n\n\n\n\nJetzt, da ihr wisst, was mit einem Byte gemeint ist, k√∂nnt ihr eine ungef√§hre Vorstellung f√ºr die Gr√∂√üenordnungen von Datenmengen entwickeln. Die ersten drei Zeilen aus Tabelle¬†2.1 k√∂nnt ihr selbst einmal nachvollziehen. Schaut euch dazu mal eine Textdatei an, notiert deren Gr√∂√üe und rechnet aus, wie viele Gl√ºhbirnen f√ºr die Speicherung gebraucht werden. Denkt daran: Ein Byte entspricht acht Gl√ºhbirnen.\nWir kommen in den sp√§teren Kapiteln immer wieder auf die Bits und Bytes zur√ºck, weil wir in Computern letztlich √ºberall mit diesen Einheiten arbeiten. Es ist somit gut, wenn ihr schon an dieser Stelle ein grundlegendes Verst√§ndnis f√ºr diese Konzepte entwickelt.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-led-dimmer-part-2",
    "href": "numbers.html#sec-led-dimmer-part-2",
    "title": "2¬† Zahlen",
    "section": "2.7 LED-Dimmer 2.0",
    "text": "2.7 LED-Dimmer 2.0\nZur√ºck zu unserem eigentlichen Vorhaben. Wir waren gerade dabei, einen Dimmer f√ºr unsere LED zu basteln, als uns die Zahlensysteme dazwischengekommen sind. Daf√ºr haben wir jetzt ein besseres Verst√§ndnis daf√ºr, wie ein Computer Farben sieht ‚Äì n√§mlich als lange Sequenz aus Nullen und Einsen. Und zwar 24 davon, weil jede Grundfarbe ein Byte an Speicher verwendet.\n\n2.7.1 min() und max()\nWas m√ºssen wir also in unserem Programm ver√§ndern, jetzt, da wir wissen, was zuvor das Problem war? Genau! Wir m√ºssen sicherstellen, dass die Werte, die wir an die LED senden, im g√ºltigen Bereich f√ºr ein Byte liegen ‚Äì und zwar zwischen 0 und 255.\n\nknob.reset()\nlast_count = 0\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        last_count = new_count\n\n        # Clamp last_count to valid byte range\n1        last_count = max(0, min(255, last_count))\n\n        print(last_count)\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(last_count, last_count, last_count)\n\n\n1\n\nDie Funktionen min() und max() sorgen daf√ºr, dass der Wert von last_count immer zwischen 0 und 255 bleibt. Wenn last_count kleiner als 0 ist, wird er auf 0 gesetzt. Wenn er gr√∂√üer als 255 ist, wird er auf 255 gesetzt.\n\n\n\n\nDie neue Logik in Zeile 9 hilft uns dabei. Nachdem wir den neuen Wert des Z√§hlers in der Variable last_count gespeichert haben (Zeile 6), wenden wir eine geschickte Kombination der beiden Funktionen max() und min() an, um sicherzustellen, dass der Wert im g√ºltigen Bereich bleibt. Wie funktioniert das genau? Dazu gehen wir die Zeile Schritt f√ºr Schritt durch.\nZun√§chst einmal der Ausdruck min(255, last_count). Die Funktion min() gibt einfach den kleineren der beiden Werte zur√ºck, die ihr √ºbergeben werden. Wenn last_count also gr√∂√üer als 255 ist, wird 255 zur√ºckgegeben. Andernfalls wird last_count zur√ºckgegeben. Das Ergebnis dieser Auswertung ist gleichzeitig der zweite Wert, den wir der Funktion max() √ºbergeben.\nDie Funktion max() macht genau das Gegenteil. Sie gibt den gr√∂√üeren der beiden ihr √ºbergebenen Werte zur√ºck. Zur Auswahl stehen ihr der Wert 0 und das Ergebnis der min()-Funktion. Das bedeutet, dass max() sicherstellt, dass der endg√ºltige Wert von last_count niemals kleiner als 0 ist.\nUnd voil√†! Nach Zeile 9 kann der Wert von last_count nur noch zwischen 0 und 255 liegen. Problem gel√∂st!\nProbiert es am besten direkt aus und dreht mal voll auf! Es sollte nun kein Fehler mehr auftreten.\n\n\n2.7.2 Helligkeit entkoppeln\nVielleicht habt ihr es auch bemerkt, aber so richtig toll funktioniert unser Dimmer immer noch nicht. Zwar erscheint keine Fehlermeldung mehr, wenn wir endlos aufdrehen. Jedoch wird die LED auch nicht gedimmt, wenn wir wieder in die andere Richtung drehen. Der Grund daf√ºr ist einfach: Die Helligkeit der LED h√§ngt in unserem Programm direkt vom Z√§hlerstand des Drehknopfes ab. Wenn der √ºber 255 kommt, wird die Helligkeit zwar auf 255 gedeckelt, der Z√§hler wird aber im Hintergrund trotzdem weiter hochgez√§hlt. Wenn wir die LED wieder dimmen, also einen Helligkeitswert von weniger als 255 erreichen m√∂chten, dann m√ºssen wir zun√§chst mit dem Drehknopf wieder bis unter die 255 kommen.\nViel sch√∂ner w√§re es, wenn wir zwar endlos √ºberdrehen k√∂nnten, aber mit der ersten Drehung in die andere Richtung die Helligkeit der LED sofort verringern. Ein einfacher Weg w√§re, f√ºr den Z√§hlerstand des Drehknopfes analog zu last_count nur Werte zwischen 0 und 255 zu erlauben. Dazu k√∂nnten wir den Z√§hler ‚Äì genau wie last_count ‚Äì manuell auf 0 oder 255 setzen, je nachdem, ob wir gr√∂√üer als 255 oder kleiner als 0 waren. Leider bietet der Drehknopf √ºber seine Programmierschnittstelle keine solche Funktion an. Wir k√∂nnen den Wert zwar auslesen, aber nicht programmatisch ver√§ndern.\nWir m√ºssen also einen Workaround entwickeln. Eine M√∂glichkeit w√§re, die Helligkeit unabh√§ngig vom Z√§hlerstand zu verwalten und daf√ºr eine eigene Variable brightness einzuf√ºhren. Wir k√∂nnten den Wert von brightness dann erh√∂hen oder verringern, wenn wir eine Drehung in die eine oder andere Richtung erkannt haben.\nUm zu erkennen, ob und in welche Richtung der Drehknopf gedreht wurde, k√∂nnen wir die Differenz zwischen dem aktuellen und dem letzten Z√§hlerstand betrachten. Sie gibt uns direkt Aufschluss: Ist die Differenz positiv, wurde der Knopf nach oben gedreht, ist sie negativ, wurde er nach unten gedreht.\n\nknob.reset()\nlast_count = 0\n\n1brightness = 0\nled.set_rgb_value(brightness, brightness, brightness) \n\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n2        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n3        brightness += diff\n        brightness = max(0, min(255, brightness))\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(brightness, brightness, brightness)\n\n4        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n1\n\nDie neue Variable brightness zu Beginn mit 0 initialisieren. Die LED soll aus sein.\n\n2\n\nHier ermitteln wir die Differenz zwischen dem aktuellen und dem letzten Z√§hlerstand und speichern sie in der Variable diff.\n\n3\n\nWir passen die Helligkeit an, indem wir brightness um diff erh√∂hen oder verringern. Dabei stellen wir sicher, dass der Wert zwischen 0 und 255 bleibt.\n\n4\n\nZur √úberpr√ºfung geben wir beide Variablen aus. Wenn wir den Wertebereich 0‚Äì255 verlassen, gehen die Werte der beiden Variablen auseinander.\n\n\n\n\n\n\n2.7.3 Konstanten\nDas sieht schon sehr gut aus! Unser Dimmer ist fast fertig, die grundlegende Funktionalit√§t l√§uft robust. Eine Kleinigkeit st√∂rt mich noch: Der Dimmer reagiert nur sehr langsam, und wir m√ºssen scheinbar endlos drehen, um die LED auf die volle Helligkeit zu bekommen. K√∂nnen wir das beschleunigen?\nDas ist nat√ºrlich eine rhetorische Frage ‚Äì in der Programmierung k√∂nnen wir so gut wie alles umsetzen. Und in diesem Fall ist es sogar recht einfach. Damit die LED schneller hell oder dunkel wird, wenn wir am Drehknopf drehen, k√∂nnen wir die Anpassung der Helligkeit einfach verst√§rken. Momentan wird die Variable brightness um die Differenz des Z√§hlerstands erh√∂ht oder verringert. Wir k√∂nnten stattdessen einen festen, h√∂heren Schrittwert definieren, um die Helligkeit schneller zu √§ndern.\nDazu definieren wir eine neue Variable, die eine Besonderheit hat. Wir geben ihr den Namen STEP, der nur aus Gro√übuchstaben besteht (Zeile 3). Gem√§√ü der Regeln f√ºr die Bennung von Variablen in Python werden Namen in GROSSBUCHSTABEN √ºblicherweise f√ºr Konstanten verwendet ‚Äì und tats√§chlich ist STEP genau genommen auch keine Variable, sondern eine Konstante.\nEine Konstante unterscheidet sich dadurch, dass ihr Wert einmal festgelegt wird und sich danach nicht mehr √§ndert. In unserem Fall wollen wir, dass STEP immer den Wert 10 hat. Konstanten definieren wir typischerweise zu Beginn eines Python-Programms, damit man einen schnellen √úberblick √ºber alle definierten Konstanten und ihre Werte bekommen kann.\nEs ist wichtig zu verstehen, dass der fixe Wert einer Konstante sich nur auf die Ausf√ºhrung des Programms bezieht. Zwischen mehreren Ausf√ºhrungen desselben Programms kann der Wert einer Konstante ge√§ndert werden. Zum Beispiel k√∂nnten wir als Hersteller des LED-Dimmers f√ºr eine neue Version entscheiden, dass dieser sich noch schneller dimmen lassen soll, und wir erh√∂hen den Wert f√ºr STEP auf 20. Oder der Benutzer k√∂nnte diesen Wert √ºber die Einstellungen der hypothetischen Dimmer-App anpassen.\nWenn wir ‚Äì wie in Zeile 15 gezeigt ‚Äì die Differenz des Z√§hlers mit der Schrittgr√∂√üe multiplizieren, k√∂nnen wir die Anpassung der Helligkeit verst√§rken.\n\n\n\n\nListing¬†2.1: Der fertige LED-Dimmer (ohne Boilerplate-Code)\n\n\nknob.reset()\nbrightness = 0\n1STEP = 10\nled.set_rgb_value(brightness, brightness, brightness) \n\nlast_count = 0\nwhile True:\n    new_count = knob.get_count(reset=False)\n\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n2        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        # Setze RGB-Werte auf den Z√§hlerwert\n        led.set_rgb_value(brightness, brightness, brightness)\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n\n\n\n1\n\nHier definieren wir eine Konstante STEP und weisen ihr den Wert 10 zu.\n\n2\n\nDie Helligkeit wird nun um diff * STEP angepasst, was bedeutet, dass jede Drehung des Knopfes einen gr√∂√üeren Einfluss auf die Helligkeit hat.\n\n\n\n\nMit dem LED-Dimmer haben wir die zentrale Funktion des Drehknopfes zur Gen√ºge kennengelernt. Das Ger√§t hat aber noch eine andere Funktion.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#druckknopf-auslesen",
    "href": "numbers.html#druckknopf-auslesen",
    "title": "2¬† Zahlen",
    "section": "2.8 Druckknopf auslesen",
    "text": "2.8 Druckknopf auslesen\nNeben dem Z√§hler besitzt der Drehknopf (der Name sagt es schon) noch eine Funktion, n√§mlich die eines einfachen Druckknopfes. Wir haben es weiter oben in Abschnitt 2.1 mit dem Brick Viewer schon ausprobiert: Der Drehknopf l√§sst sich dr√ºcken und erzeugt eine haptische R√ºckmeldung, ein leichtes Knacken. Im Brick Viewer wurde der kleine Kreis auf der rechten Seite dann rot eingef√§rbt.\nSelbstverst√§ndlich k√∂nnen wir den Zustand des Buttons auch aus einem Programm heraus abfragen. Dazu bietet uns der Drehknopf eine Methode is_pressed() an:\n\nwhile True:\n    if knob.is_pressed():\n        print(\"Button pressed\")\n    else:\n        print(\"Button not pressed\")\n\nDie Funktion liefert True zur√ºck, wenn der Button gerade gedr√ºckt ist, und ansonsten False. Das k√∂nnen wir wunderbar nutzen und dar√ºber eine Bedingung formulieren, um entweder ‚ÄúButton pressed‚Äù oder ‚ÄúButton not pressed‚Äù auf der Konsole auszugeben. Ihr erinnert euch bestimmt an das if-Statement aus Abschnitt 2.3. Das ist genau das, was wir jetzt brauchen!\n\n\n\n\nListing¬†2.2: Ein erster Test des Drehknopf-Buttons.\n\n\n1button_pressed_before = False\nwhile True:\n    button_pressed_after = knob.is_pressed()\n\n2    if button_pressed_before == True and button_pressed_after == False:\n3        print(\"Button was pressed and released\")\n    \n4    button_pressed_before = button_pressed_after\n\n\n\n\n\n1\n\nWir initialisieren eine Variable button_pressed_before, die den vorherigen Zustand des Buttons speichert. Am Anfang gehen wir mal davon aus, dass er nicht gedr√ºckt ist.\n\n2\n\nMit dem if-Statement √ºberpr√ºfen wir, ob der Button logelassen wurde. Dazu muss der vorherige Zustand True und der aktuelle Zustand False sein.\n\n3\n\nWenn der Button soeben losgelassen wurde, geben wir eine entsprechende Information auf der Konsole aus.\n\n4\n\nAm Ende der Schleife aktualisieren wir den vorherigen Zustand button_pressed_before, damit er den aktuellen Zustand f√ºr die n√§chste Iteration speichert.\n\n\n\n\nDas reicht f√ºrs Erste ‚Äì der Button kann tats√§chlich nicht mehr als das. Reicht aber auch: Damit k√∂nnen wir unserem Dimmer schon einen zus√§tzlichen Mehrwert verleihen. Schlie√ülich kann unsere LED nicht nur wei√ü leuchten.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-led-dimmer-part-3",
    "href": "numbers.html#sec-led-dimmer-part-3",
    "title": "2¬† Zahlen",
    "section": "2.9 LED-Dimmer 3.0",
    "text": "2.9 LED-Dimmer 3.0\nW√§re es nicht praktisch, wenn wir das Licht der LED nicht nur dimmen, sondern auch den Farbton ver√§ndern k√∂nnten? Wei√ües Licht ist am Abend bekanntlich nicht empfehlenswert, und gr√ºnes Licht soll beruhigend wirken.\nLasst uns unseren Dimmer so erweitern, dass per Knopfdruck der Farbton gewechselt werden kann. F√ºrs Erste wollen wir die Farben Wei√ü, Gelb und Gr√ºn anbieten. Das l√§sst sich sp√§ter beliebig erweitern.\n\n2.9.1 Farbe per Variable steuern\nDer Ausgangspunkt f√ºr unser dimmbares Stimmungslicht ist der Dimmer aus Listing¬†2.1. Von hier aus f√ºgen wir Schritt f√ºr Schritt die Logik f√ºr den Farbwechsel per Button ein. Lasst uns aber zun√§chst ganz ohne Button versuchen, die Farbe der LED zu √§ndern.\nBisher haben wir es uns einfach gemacht und die LED in Wei√ü leuchten lassen. Dazu mussten wir nur jeden der drei RGB-Farbkan√§le auf den gleichen Wert setzen. Wenn wir neben Wei√ü auch Gelb und Gr√ºn anbieten wollen, m√ºssen wir die Farbkan√§le unterschiedlich ansteuern. F√ºr Gelb setzen wir den roten und den gr√ºnen Kanal auf den gleichen Wert, w√§hrend der blaue Kanal auf 0 bleibt. F√ºr Gr√ºn setzen wir den gr√ºnen Kanal auf den gleichen Wert und die anderen beiden auf 0. Um so eine Logik umzusetzen, haben wir das passende Instrument bereits in unserem Werkzeugkasten: Kontrollstrukturen.\nNehmen wir mal an, wir h√§tten eine Variable color, auf der die aktuelle Farbe gespeichert ist, in der die LED leuchten soll. Sie k√∂nnte also die Werte ‚Äúwhite‚Äù, ‚Äúyellow‚Äù oder ‚Äúgreen‚Äù annehmen. Dann k√∂nnten wir mit if-Statements die notwendige Logik umsetzen:\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nErinnert euch, dass der Code nach einem if nur dann ausgef√ºhrt wird, wenn die vorangegangene Bedingung erf√ºllt ist. Da die Variable color zu einem Zeitpunkt nur einen der drei Werte annehmen kann, muss genau eine der drei Bedingungen erf√ºllt sein und alle anderen entsprechend nicht.\nWenn wir jetzt zu Beginn unseres Programms color auf einen der drei Werte setzen, k√∂nnen wir die Logik schnell mal testen:\n\ncolor = \"white\"\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nAlles sollte so sein wie zuvor, die LED leuchtet wei√ü.\n\ncolor = \"yellow\"\n\nJetzt sollte beim Start des Programms die LED gelb leuchten. Dasselbe probiert mal mit ‚Äúgreen‚Äù aus, das d√ºrfte auch funktionieren.\n\n\n2.9.2 Farbe per Knopfdruck √§ndern\nDie aktuelle Farbe in einer Variable zu speichern ist eine gute Idee gewesen. Darauf k√∂nnen wir aufbauen und den Button f√ºr den Wechsel der Farbe nutzen. Aber wie?\nZun√§chst erinnern wir uns an die Logik aus Listing¬†2.2, in dem wir den Button bereits aus einem Programm heraus getestet haben. Dort haben wir eine Logik gebastelt, die erkennt, wenn der Button gedr√ºckt und wieder losgelassen wird. Wenn das der Fall war, wurde der Wert ‚ÄúButton gedr√ºckt‚Äù auf der Konsole ausgegeben. K√∂nnten wir diese Logik nicht verwenden, um statt etwas auszugeben einfach die Farbe zu wechseln?\nNat√ºrlich k√∂nnen wir das. Passen wir den Code entsprechend an:\n\nbutton_pressed_before = False\nwhile True:\n    button_pressed_after = knob.is_pressed()\n\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n    button_pressed_before = button_pressed_after\n\nWieder ein Haufen voller ifs - aber es sollte funktionieren. Gehen wir es einmal durch: Wenn der Button losgelassen wurde (Zeile 5) gelangen wir zur Pr√ºfung der if-Statements. Im ersten Fall wird gepr√ºft, ob die LED gerade Wei√ü leuchtet (color == \"white\"). Ist das der Fall, dann wechseln wir jetzt auf Gelb. Im zweiten Schritt sehen wir ein elif, das sehr √§hnlich zu einem if ist, mit der Einschr√§nkung, dass es nur √ºberhaupt gepr√ºft wird, wenn das vorherige if nicht schon wahr war. Das macht in diesem Fall einen gro√üen Unterschied (im Vergleich zu weiter oben, als wir einfache if-Statements verwendet haben, um die Farbe der LED mit set_rgb_color zu setzen). √úberlegt mal, was passieren w√ºrde, wenn wir hier folgenden Code einsetzen w√ºrden:\n\nif color == \"white\":\n    color = \"yellow\"\nif color == \"yellow\":\n    color = \"green\"\nif color == \"green\":\n    color = \"white\"\n\nGeht das mal im Kopf durch. Wenn color aktuell den Wert white hat, dann wird durch das erste if der Wert auf yellow gesetzt. Anschlie√üend wird das zweite if gepr√ºft, das jetzt wahr ist, und der Wert wird auf green gesetzt. Das dritte if wird dann also ebenfalls wahr sein, und der Wert wird wieder auf white gesetzt. Im Endeffekt haben wir also nichts gewonnen, die LED bliebe wei√ü. Hier ist die Verwendung von elif entscheidend. Denn ein elif wird nur gepr√ºft, wenn das vorherige if oder elif nicht wahr war. Nach der ersten Anpassung w√§re hier also Schluss und die Farbe ist wie gew√ºnscht Gelb.\nF√ºgen wir alles zusammen - die neue Logik zum setzen der Farben basierend auf der Varible colorund die Logik zum √Ñndern der Variable, sowie die Logik des Dimmers aus Listing¬†2.1:\n\n\n\n\nListing¬†2.3: Farbwechsel und Helligkeitsanpassung in einem Programm.\n\n\nbutton_pressed_before = False\n\n# 1. Main loop to keep program running\nwhile True:\n    new_count = knob.get_count(reset=False)\n    button_pressed_after = knob.is_pressed()\n\n    # 2. Logic for color change on button release\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n        # Update LED to reflect new color\n        if color == \"white\":\n            led.set_rgb_value(brightness, brightness, brightness)\n        if color == \"yellow\":\n            led.set_rgb_value(brightness, brightness, 0)\n        if color == \"green\":\n            led.set_rgb_value(0, brightness, 0)\n\n    button_pressed_before = button_pressed_after\n\n    # 3. Logic for brightness adjustment\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        # Update LED to reflect new color\n        if color == \"white\":\n            led.set_rgb_value(brightness, brightness, brightness)\n        if color == \"yellow\":\n            led.set_rgb_value(brightness, brightness, 0)\n        if color == \"green\":\n            led.set_rgb_value(0, brightness, 0)\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n\n\n\n\nSchaut euch den Code in Ruhe an und pr√ºft, ob ihr ihn Zeile f√ºr Zeile nachvollziehen k√∂nnt. An dieser Stelle hat unser Programm schon eine betr√§chtliche Gr√∂√üe angenommen, und so langsam wird es un√ºbersichtlich. Versuchen wir also, Struktur hineinzubringen. Im Wesentlichen besteht das Programm aus drei Teilen, jeden habe ich mit einem vorangestellten Kommentar markiert:\n\nHauptschleife, um das Programm am Laufen zu halten\nLogik f√ºr Farbwechsel bei Tastenfreigabe\nLogik zur Helligkeitsanpassung\n\nIn der Hauptschleife wird am Anfange immer wieder der aktuelle Z√§hlerstand und der Zustand des Buttons abgefragt und auf jeweils einer Variable gespeichert. Diese Werte ben√∂tigen wir, um zu entscheiden, ob wir die Farbe √§ndern oder die Helligkeit anpassen m√ºssen.\nUm einen potenziellen Farbwechsel k√ºmmert sich der zweite Block, der mit dem if button_pressed_before == True ... beginnt. Die Bedingung pr√ºft, ob der Button gerade aus dem gedr√ºckten Zustand in den nicht gedr√ºckten Zustand wechselt, der Benutzer ihn also gerade losgelassen hat. In diesem Moment soll die Farbe gewechselt werden. Die Logik daf√ºr haben wir gerade entwickelt.\nUm die Helligkeitsanpassung k√ºmmert sich dann der dritte und letzte gr√∂√üere Block. Er beginnt mit if new_count != last_count, was pr√ºft, ob der Drehknop bet√§tigt wurde. Wenn ja, dann wird die Helligkeit entsprechend der Differenz angepasst. Diese Logik haben wir in Abschnitt 2.7 zusammen entwickelt.\nWer von euch jetzt ganz genau hinsieht, der erkennt, dass die Bl√∂cke 2 und 3 zum Teil identischen Code ausf√ºhren. In der Programmierung ist das eine rote Flagge üö©! Lasst uns dar√ºber sprechen, warum!",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#sec-numbers-functions",
    "href": "numbers.html#sec-numbers-functions",
    "title": "2¬† Zahlen",
    "section": "2.10 Funktionen",
    "text": "2.10 Funktionen\nIn der Programmierung m√∂chten wir Wiederholungen um jeden Preis vermeiden. Wir sprechen auch vom DRY-Prinzip, was f√ºr Don‚Äôt Repeat Yourself steht. Wenn wir feststellen, dass wir denselben Code an mehreren Stellen verwenden, sollten wir dar√ºber nachdenken, etwas zu ver√§ndern. Warum? Und was?\nNehmen wir in unserem Beispiel an, wir f√ºhren eine vierte Farbe ein, sagen wir Blau. Dann m√ºssten wir den Code in den Bl√∂cken 2 und 3 anpassen, um die neue Farbe zu ber√ºcksichtigen. Das bedeutet, dass wir den gleichen Code an mehreren Stellen √§ndern m√ºssten, was fehleranf√§llig und m√ºhsam ist. Zwei mag noch nicht nach einem Problem klingen, aber selbst hier zeigt sich das Problem der Wiederholung. Wird eine Stelle vergessen, ist der Code inkonsistent und funktioniert nicht mehr wie gew√ºnscht.\nDie L√∂sung liegt darin, h√§ufig verwendeten Code in Funktionen auszulagern. Funktionen sind ein m√§chtiges Werkzeug in der Programmierung. Sie erm√∂glichen es uns, Codebl√∂cke zu definieren, die wir immer wieder verwenden k√∂nnen, ohne sie jedes Mal neu schreiben zu m√ºssen. Funktionen helfen uns dabei, unseren Code sauberer, √ºbersichtlicher und wartbarer zu gestalten.\nIm Listing¬†2.3 wird dieser Teil an zwei Stellen wiederholt:\n\nif color == \"white\":\n    led.set_rgb_value(brightness, brightness, brightness)\nif color == \"yellow\":\n    led.set_rgb_value(brightness, brightness, 0)\nif color == \"green\":\n    led.set_rgb_value(0, brightness, 0)\n\nZeit, diesen Code nur einmal zu schreiben! Machen wir daraus eine Funktion. Wie das geht? Im Prinzip m√ºssen wir vier Dinge kl√§ren:\n\nWas soll die Funktion tun?\nWie sieht das Ergebnis aus?\nWas ben√∂tigt die Funktion, um ihre Aufgabe zu erledigen?\nWie heisst die Funktion?\n\n\n\n\n\n\n\nAbbildung¬†2.14: Funktionen folgen einem Eingabe-Verarbeitung-Ausgabe (EVA) Schema.\n\n\n\n\ndef set_led_color(color, brightness):\n    if color == \"white\":\n        led.set_rgb_value(brightness, brightness, brightness)\n    if color == \"yellow\":\n        led.set_rgb_value(brightness, brightness, 0)\n    if color == \"green\":\n        led.set_rgb_value(0, brightness, 0)\n\nIn Listing¬†2.4 seht ihr den fertigen Code f√ºr den Dimmer mit Farbwechsel per Knopfdruck.\n\n\n\n\nListing¬†2.4: Der fertige Dimmer mit Farbwechsel per Knopfdruck.\n\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_rotary_encoder_v2 import BrickletRotaryEncoderV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nknob = BrickletRotaryEncoderV2('WZd', ipcon) \nled = BrickletRGBLEDV2('ZG1', ipcon)\n\nknob.reset()\nbrightness = 0\nSTEP = 10\nled.set_rgb_value(brightness, brightness, brightness) \nlast_count = 0\n\ncolor = \"white\"\nbutton_pressed_before = False\n\ndef set_led_color(color, brightness):\n    if color == \"white\":\n        led.set_rgb_value(brightness, brightness, brightness)\n    if color == \"yellow\":\n        led.set_rgb_value(brightness, brightness, 0)\n    if color == \"green\":\n        led.set_rgb_value(0, brightness, 0)\n\nwhile True:\n    new_count = knob.get_count(reset=False)\n    button_pressed_after = knob.is_pressed()\n\n    # If button changes from pressed to not pressed\n    if button_pressed_before == True and button_pressed_after == False:\n        if color == \"white\":\n            color = \"yellow\"\n        elif color == \"yellow\":\n            color = \"green\"\n        elif color == \"green\":\n            color = \"white\"\n\n        print(f\"Color changed to: {color}\")\n        set_led_color(color, brightness)   \n\n    button_pressed_before = button_pressed_after\n\n    if new_count != last_count:\n        diff = new_count - last_count\n        last_count = new_count\n\n        # Adjust brightness\n        brightness += diff * STEP\n        brightness = max(0, min(255, brightness))\n\n        print(f\"Brightness / Counter: {brightness} / {new_count}\")\n        set_led_color(color, brightness)\n\n\n\n\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "numbers.html#footnotes",
    "href": "numbers.html#footnotes",
    "title": "2¬† Zahlen",
    "section": "",
    "text": "H√§nde hoch, wer daran noch glaubt!‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Zahlen</span>"
    ]
  },
  {
    "objectID": "text.html",
    "href": "text.html",
    "title": "3¬† Texte",
    "section": "",
    "text": "Zusammenfassung\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#zusammenfassung",
    "href": "text.html#zusammenfassung",
    "title": "3¬† Texte",
    "section": "",
    "text": "Wir lernen, wie Computer Texte darstellen und speichern.\nWir f√ºhren ASCII und Unicode als Standards f√ºr die Textdarstellung ein.\nWir verstehen Bin√§rcodierung und wie sie im Computer zum Einsatz kommt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#experimentaufbau",
    "href": "text.html#experimentaufbau",
    "title": "3¬† Texte",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\nF√ºr dieses Kapitel ben√∂tigen wir erneut die LED (RGB LED Bricklet 2.0), ersetzen aber den Drehknopf aus Kapitel 2 durch einen Infrarot-Abstandssensor (Distance IR 4-30cm Bricklet 2.0). Beide Ger√§te schlie√üen wir an den Mikrocontroller (Master Brick 3.2) an und fixieren sie auf einer Montageplatte. Wie in der Abbildung gezeigt, befestigen wir den Abstandssensor mit einem Metallwinkel so, dass er b√ºndig mit der Platte ist und nach vorn zeigt.\n\n\n\n\n\n\n\n\n\n\n\n(a) Seitenansicht.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Draufsicht.\n\n\n\n\n\n\n\n\n\n\n\n(c) Nahaufnahme des IR-Abstandssensors.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(d) Seitenansicht, leicht schr√§g.\n\n\n\n\n\n\n\nAbbildung¬†3.1: Einfaches Setup mit einem Mikrocontroller, LED und einem Infrarot-Abstandssensor.\n\n\n\n\n\nErste Schritte mit dem Abstandssensor\nWie bei der LED werfen wir zuerst einen Blick auf den neuen Abstandssensor im Brick Viewer. Schlie√üt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Tab Setup sollten nun neben der LED auch der Abstandssensor erscheinen. Denkt daran: Dort findet ihr auch die UID eurer Ger√§te ‚Äì die braucht ihr gleich im Programm.\n\n\n\n\n\n\nAbbildung¬†3.2: Nach erfolgreicher Verbindung erscheint der Infrarot-Entfernungsmesser in der √úbersicht des Brick Viewers.\n\n\n\nWechselt in den Tab f√ºr den Abstandssensor, wo ihr ihn direkt testen k√∂nnt: Ihr seht die aktuelle Entfernung, die der Sensor misst, in Echtzeit oben in der Mitte (in Zentimetern). Darunter zeigt ein Kurvendiagramm den zeitlichen Verlauf. Bewegt eure Hand vor dem Sensor, um ein Gef√ºhl f√ºr sein Verhalten zu bekommen. Was passiert, wenn ihr sehr nah vor dem Sensor seid? Und was, wenn ihr eure Hand weiter weg bewegt?\n\n\n\n\n\n\nAbbildung¬†3.3: Der Brick Viewer zeigt die aktuelle Entfernung im Zeitverlauf an.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#lichtschranke",
    "href": "text.html#lichtschranke",
    "title": "3¬† Texte",
    "section": "3.1 Lichtschranke",
    "text": "3.1 Lichtschranke\nEinen Infrarot-Abstandssensor verwenden wir in der Praxis zur ber√ºhrungslosen Messung des Abstands zu einem Objekt. Der Sensor sendet einen unsichtbaren Infrarotlichtstrahl aus und misst das Licht, das vom Objekt zur√ºckgeworfen wird. Anhand der Intensit√§t oder des Winkels des zur√ºckkehrenden Lichts berechnet der Sensor die Entfernung. Diese Sensoren sind aus der Praxis nicht wegzudenken und kommen in vielen Szenarien zum Einsatz, zum Beispiel:\n\nObjekterkennung an einem Flie√üband\nF√ºllstandsmessung in Beh√§ltern\nHinderniserkennung f√ºr Roboter, etwa bei Staubsaugerrobotern\nPositionierung von Werkst√ºcken in Maschinen\nEinparkhilfe beim Auto\n\nLetztlich lassen sich alle Anwendungsf√§lle auf zwei Fragen reduzieren:\n\nBefindet sich ein Objekt in der Sicht des Sensors?\nWie weit ist ein Objekt vom Abstandssensor entfernt?\n\nWir starten mit der einfacheren der beiden Fragen: Befindet sich ein Objekt in der Sicht des Sensors? Das beschreibt im Kern die Funktion einer Lichtschranke.\nWie ihr beim Ausprobieren im Brick Viewer festgestellt habt, misst der Sensor Entfernungen zwischen 4 und 30 cm. Das bedeutet: Objekte au√üerhalb dieses Bereichs werden nicht erkannt ‚Äì weder n√§her als 4 cm noch weiter als 30 cm. Eine Lichtschranke hat somit die Aufgabe zu pr√ºfen, ob der IR-Abstandssensor einen Wert kleiner als 30 cm misst. Dann befindet sich ein Objekt in seiner Sichtlinie.\nVerbinden wir uns mit dem Sensor und schreiben das notwendige Grundger√ºst. Tragt eure UIDs ein und legt beide Bricklets an, Sensor und LED:\n\n\n\n\nListing¬†3.1: Boilerplate-Code f√ºr IR-Abstandssensor und RGB-LED\n\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\nimport time\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\n\n1ir = BrickletDistanceIRV2('2a7S', ipcon)\n2led = BrickletRGBLEDV2('ZEL', ipcon)\n\n\n\n\n\n1\n\nTragt hier die UID eures IR-Sensors ein.\n\n2\n\nTragt hier die UID eurer RGB-LED ein.\n\n\n\n\nDer Sensor ist danach in der Variablen ir gespeichert. √úber sie k√∂nnen wir seine Funktionen aufrufen. Eine davon erlaubt uns das Auslesen des aktuell gemessenen Werts:\n\ndistance = ir.get_distance()\n\nEin Blick in die Dokumentation verr√§t, dass der R√ºckgabewert in Millimetern angegeben wird. Ein Wert an der oberen Grenze (rund 300 mm) signalisiert typischerweise, dass sich kein Objekt innerhalb der Reichweite befindet. Damit wir besser testen k√∂nnen, lesen wir den Wert kontinuierlich aus und schreiben ihn auf die Konsole:\n\nwhile True:\n    distance = ir.get_distance()\n    print(f\"Aktuelle Entfernung: {distance} mm\")\n\nIhr werdet sehen, dass wir sehr viele Ausgaben erzeugen, weil in jedem Schleifendurchlauf der Wert ausgegeben wird ‚Äì auch wenn er sich nicht ver√§ndert hat. Geben wir erneut nur die Ver√§nderungen aus, um die Ausgaben zu reduzieren:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if distance != last_distance:\n        print(f\"Aktuelle Entfernung: {distance} mm\")\n        last_distance = distance\n\nIhr erinnert euch: Dasselbe Prinzip haben wir in Abschnitt 2.7 verwendet, um nur bei einer √Ñnderung des Drehknopfs eine Ausgabe zu erzeugen. Wir merken uns den letzten Wert und vergleichen ihn mit dem aktuell gemessenen. Ist er gleich, passiert nichts. Hat er sich ver√§ndert (distance != last_distance), geben wir den neuen Wert aus und aktualisieren den letzten Wert (last_distance = distance).\nWir sind unserem Etappenziel einer Lichtschranke schon sehr nah. Anhand der Ausgabe k√∂nnten wir entscheiden, ob ein Objekt in der Sicht des Sensors ist oder nicht. Das soll aber unser Programm automatisch erledigen. Dazu f√ºgen wir eine weitere Bedingung mit einer if-Anweisung hinzu:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &lt; 300:\n            print(f\"Objekt erkannt: {distance} mm\")\n        else:\n            print(\"Kein Objekt in Reichweite\")\n    \n        last_distance = distance\n\nDie neue if-Anweisung pr√ºft, ob der Abstand kleiner als 300 mm ist. Dann befindet sich etwas vor dem Sensor. In diesem Fall geben wir einen entsprechenden Hinweis aus. Andernfalls kommt der Hinweis ‚ÄûKein Objekt in Reichweite‚Äú. Diesen anderen Fall bildet der optionale else-Teil ab. Code hinter else wird immer dann ausgef√ºhrt, wenn keine der vorher definierten Bedingungen √ºber if oder elif zutrifft.\nDamit unsere Lichtschranke auch ohne Blick auf die Konsole funktioniert, bringen wir im letzten Schritt die LED ins Spiel. Sie soll rot aufleuchten, wenn ein Objekt erkannt wird. Die LED haben wir bereits kennengelernt, den Code k√∂nnen wir √ºbernehmen:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &lt; 300:\n            print(f\"Objekt erkannt: {distance} mm\")\n1            led.set_rgb_value(255, 0, 0)\n        else:\n            print(\"Kein Objekt in Reichweite\")\n2            led.set_rgb_value(0, 0, 0)\n    \n        last_distance = distance\n\n\n1\n\nDie LED leuchtet rot, wenn ein Objekt erkannt wird.\n\n2\n\nDie LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.\n\n\n\n\nProbiert es aus ‚Äì die Lichtschranke sollte funktionieren und Objekte innerhalb von 30 cm zuverl√§ssig erkennen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#hinderniserkennung",
    "href": "text.html#hinderniserkennung",
    "title": "3¬† Texte",
    "section": "3.2 Hinderniserkennung",
    "text": "3.2 Hinderniserkennung\nDie Lichtschranke leuchtet immer rot, sobald ein Objekt erkannt wird. Dabei spielt die Entfernung keine Rolle. Lasst uns die Idee zu einer Hinderniserkennung f√ºr einen hypothetischen Staubsaugerroboter erweitern. Die LED soll anzeigen, ob sich ein Objekt bereits nahe am Roboter befindet oder ob es noch weit genug entfernt ist.\nNehmen wir an, dass Objekte, die 17 cm oder n√§her am Roboter sind, als Gefahr gelten. Alles, was zwischen 17 und 30 cm Abstand h√§lt, sieht der Roboter nicht als bedrohlich an. Die drei Zust√§nde wollen wir √ºber die Farbe der LED abbilden:\n\nGelb: Objekt in mittlerer Entfernung erkannt (17 cm &lt; Abstand &lt; 30 cm)\nRot: Nahes Objekt erkannt (&lt;= 17 cm)\nAus: Kein Objekt vor dem Sensor (&gt;= 30 cm)\n\nWir k√∂nnen dazu den Code der Lichtschranke erweitern:\n\n\n\n\nListing¬†3.2: Der Code f√ºr die zweistufige Hinderniserkennung.\n\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &gt; 170 and distance &lt; 300:\n1            led.set_rgb_value(255, 255, 0)\n        elif distance &lt;= 170:\n2            led.set_rgb_value(255, 0, 0)\n        else:\n3            led.set_rgb_value(0, 0, 0)\n    \n        last_distance = distance\n\n\n\n\n\n1\n\nDie LED leuchtet gelb, wenn ein Objekt in mittlerer Entfernung erkannt wird.\n\n2\n\nDie LED leuchtet rot, wenn ein Objekt in naher Entfernung erkannt wird.\n\n3\n\nDie LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.\n\n\n\n\nIhr erinnert euch an die additive Farbmischung aus Abbildung¬†1.6 (a)? Gelb entsteht durch die Kombination von Rot und Gr√ºn. Wir verwenden hier eine elif-Anweisung, die eine weitere Bedingung pr√ºft, wenn die vorherige if-Bedingung nicht zutrifft. So k√∂nnen wir mehrere Bedingungen hintereinander pr√ºfen. Der letzte else-Teil f√§ngt alle F√§lle ab, in denen kein Objekt erkannt wurde.\nUnser Staubsaugerroboter k√∂nnte den Code oben verwenden, um Hindernisse zu erkennen und bei zu gro√üer N√§he ein Ausweichman√∂ver zu starten.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#universelles-eingabeger√§t",
    "href": "text.html#universelles-eingabeger√§t",
    "title": "3¬† Texte",
    "section": "3.3 Universelles Eingabeger√§t",
    "text": "3.3 Universelles Eingabeger√§t\nEine andere M√∂glichkeit, den Abstandssensor und den Code aus Listing¬†3.2 zu verwenden, ist ein Eingabeger√§t f√ºr Informationen in unseren Computer. Wie soll ein Abstandssensor als Eingabeger√§t f√ºr Informationen fungieren?\nWie wir sp√§ter noch sehen werden, ben√∂tigen wir f√ºr die Darstellung von Informationen unterschiedliche Zust√§nde ‚Äì mindestens zwei. Genau das verk√∂rpert das Bit, das wir in Abschnitt 2.6 kennengelernt haben: Ein Bit hat zwei Zust√§nde, an oder aus, 0 oder 1.\nWas w√§re, wenn wir die beiden Bereiche ‚Äûnah‚Äú und ‚Äûweit genug entfernt‚Äú nicht l√§nger als Entfernungen interpretieren, sondern einfach als zwei Zust√§nde? Sagen wir, der Bereich ‚Äûweit genug entfernt‚Äú steht f√ºr die 1 und der Bereich ‚Äûnah‚Äú f√ºr die 0. Dann k√∂nnten wir √ºber die bewusste Platzierung eines soliden Gegenstands und anschlie√üende Messung der Entfernung den Zustand eines Bits kodieren:\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        if distance &gt; 170 and distance &lt; 300:\n            print(\"1\")\n        elif distance &lt;= 170:\n            print(\"0\")\n    \n        last_distance = distance\n\nWenn ihr den Code ausf√ºhrt, werdet ihr ein Problem erkennen: Platzieren wir unsere Hand nahe am Sensor, um eine 0 zu kodieren, gibt das Programm nacheinander sehr viele Nullen aus. Dasselbe gilt f√ºr Einsen. Dabei wollen wir mit einer Handgeste jeweils nur eine 1 oder 0 √ºbermitteln, nicht eine ganze Reihe. Das liegt daran, dass sich unsere Hand minimal bewegt ‚Äì ein Millimeter reicht.\nWir m√ºssen unser Programm so anpassen, dass es nicht erneut auf eine √Ñnderung reagiert, solange die Hand nicht wieder weggenommen wurde. Das erkennen wir daran, dass der Sensor die maximale Entfernung von 30 cm misst. Erst wenn dieses Ereignis wieder auftritt, soll ein neuer Zustand kodiert werden.\nEine L√∂sung besteht darin, dass wir uns merken, ob unser Eingabeger√§t aktuell empfangsbereit ist oder nicht. Wir f√ºhren daf√ºr die Variable receiving ein, die den Zustand unseres Eingabeger√§ts beschreibt. Ist sie True, ist das Ger√§t bereit, eine Eingabe zu empfangen. Ist sie False, ignorieren wir alle √Ñnderungen, bis die Hand wieder weggenommen wurde.\n\nlast_distance = 0\nreceiving = False\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        \n1        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(f\"1 bei {distance} mm\")\n                receiving = False\n            elif distance &lt;= 170:\n                print(f\"0 bei {distance} mm\")\n                receiving = False\n2        else:\n            if distance &gt;= 300:\n3                receiving = True\n                print(\"Bereit f√ºr den n√§chsten Code\")\n\n        last_distance = distance\n\n\n1\n\nNur im Empfangsmodus wird anhand der Entfernung ein Bit kodiert.\n\n2\n\nWenn wir nicht im Empfangsmodus sind, pr√ºfen wir, ob die Hand wieder weggenommen wurde (&gt;= 30 cm).\n\n3\n\nWenn die Hand weg ist, schalten wir wieder in den Empfangsmodus.\n\n\n\n\nDas sieht schon gut aus. Probiert aber einmal aus, eure Hand sehr langsam von oben nach unten vor den Sensor zu bewegen, und zwar im nahen Bereich, sodass eigentlich eine 0 kodiert werden sollte. In manchen F√§llen erkennt das Programm f√§lschlicherweise eine 1 statt der 0. Warum ist das so? Der Sensor hat bei der Messung eine leichte zeitliche Verz√∂gerung. Wenn er aktuell 30 cm Abstand misst und wir unsere Hand langsam nach unten bewegen, misst der Sensor zun√§chst einen Abstand knapp unter 30 cm. Das Programm reagiert sofort und kodiert eine 1, obwohl wenig sp√§ter der Sensorwert in den Bereich der 0 kommt (zum Beispiel 8 cm).\nWir k√∂nnen das Problem umgehen, indem wir einen kleinen Verzug einbauen, sobald ein Unterschied erkannt wurde. Nach diesem zeitlichen Verzug messen wir erneut, um sicherzugehen, die korrekte Position der Hand zu erwischen. So k√∂nnte das im Code aussehen:\n\nlast_distance = 0\nreceiving = False\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        # 100 ms warten und erneut messen\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(f\"1 bei {distance} mm\")\n                receiving = False\n            elif distance &lt;= 170:\n                print(f\"0 bei {distance} mm\")\n                receiving = False\n        else:\n            if distance &gt;= 300:\n                receiving = True\n                print(\"Bereit f√ºr den n√§chsten Code\")\n\n        last_distance = distance\n\nTestet es jetzt: Unser Eingabeger√§t erkennt die Zust√§nde 0 und 1 zuverl√§ssig.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#texte-kodieren",
    "href": "text.html#texte-kodieren",
    "title": "3¬† Texte",
    "section": "3.4 Texte kodieren",
    "text": "3.4 Texte kodieren\nK√∂nnen wir unser universelles Eingabeger√§t dazu verwenden, dem Computer Texte zu diktieren? Schlie√ülich bedeutet ‚Äûuniversell‚Äú, dass es f√ºr viele Zwecke einsetzbar ist. Und die Antwort lautet: ja! Wenn wir ein Ger√§t entwickeln, mit dem wir Bits kodieren k√∂nnen, k√∂nnen wir damit alles eingeben, was ein Computer darstellen kann.\nIn Kapitel 2 haben wir gesehen, wie wir mit 8 Bits den Wert einer der drei Grundfarben im RGB-Code darstellen k√∂nnen. Wenn wir unser Eingabeger√§t einsetzen, um hintereinander 24 Bits zu √ºbermitteln und diese als einen RGB-Farbcode zu interpretieren, k√∂nnten wir damit unsere LED in einer beliebigen Farbe aufleuchten lassen. Das versuchen wir sp√§ter. Jetzt k√ºmmern wir uns um eine ebenso wichtige Form der Information: Texte.\nTexte bestehen allgemein aus Zeichen. Die meisten Zeichen in Texten sind Buchstaben, die wir in Klein- und Gro√übuchstaben unterscheiden. Dazu kommen Zahlen und Satzzeichen. Schaut auf das Keyboard eures Computers ‚Äì dort findet ihr die meisten Zeichen, die ihr f√ºr Texte ben√∂tigt.\n\n3.4.1 Wie viele Bits ben√∂tigen wir?\nGenau wie bei den Farben, f√ºr die wir 24 Bits ben√∂tigen (jeweils 8 pro Farbe im RGB-Code), stellt sich bei Texten die Frage, wie viele Bits wir ben√∂tigen, um ein Zeichen darzustellen. Die Antwort h√§ngt von der Anzahl der ben√∂tigten Zeichen ab.\nN√§hern wir uns von der anderen Seite und erweitern unseren Zeichencode Bit f√ºr Bit. Wir beginnen klein und fangen mit einem Bit an. Wenn wir Bits als Text interpretieren, wie viele Zeichen (oder Buchstaben) k√∂nnen wir dann mit einem einzigen Bit darstellen? Richtig: zwei!\n\nlast_distance = 0\nreceiving = False\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        # 100 ms warten und erneut messen\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"B\")\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"A\")\n                receiving = False\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\nLasst das Programm laufen und legt eure Hand einmal nahe vor den Sensor, dann zweimal weiter weg und wieder nah. Das habt ihr gerade geschrieben: ‚ÄûABBA‚Äú.\nNeben der bekannten schwedischen Band lassen sich mit den Buchstaben A und B jedoch nicht viele andere W√∂rter bilden. Wir sind also gut beraten, mindestens ein zweites Bit hinzuzunehmen. Die Anzahl Bits, die wir f√ºr einen Buchstaben ben√∂tigen, erh√∂ht sich damit auf zwei. Wie bilden wir das im Programm ab?\nAm einfachsten, indem wir uns die Bits zun√§chst merken, sie also hintereinander in eine Zeichenkette schreiben. Sobald eine vorher definierte L√§nge einer Nachricht ‚Äì hier zun√§chst zwei Bits ‚Äì erreicht ist, dekodieren wir die Bitfolge und erhalten den passenden Buchstaben. Danach geht es wieder von vorn los und unsere Bit-Zeichenkette ist wieder leer.\n\n1MESSAGE_LENGTH = 2\n2bits = \"\"\n3text = \"\"\nlast_distance = 0\nreceiving = False\n\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"1\")\n4                bits += \"1\"\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"0\")\n5                bits += \"0\"\n                receiving = False\n\n6            if len(bits) == MESSAGE_LENGTH:\n                print(f\"Bits: {bits}\")\n7                letter = decode_letter(bits)\n                print(f\"Buchstabe: {letter}\")\n8                text += letter\n                print(f\"Text: {text}\")\n9                bits = \"\"\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\n\n1\n\nDie L√§nge einer Nachricht. So viele Bits m√ºssen wir sammeln, bis wir die Nachricht entschl√ºsseln k√∂nnen.\n\n2\n\nWir erstellen eine leere Zeichenkette bits, in der wir jedes empfangene Bit speichern.\n\n3\n\ntext sammelt die dekodierten Buchstaben zu einem Text.\n\n4\n\nWir merken uns das Bit, indem wir es an das Ende von bits hinzuf√ºgen ‚Äì hier eine ‚Äû1‚Äú.\n\n5\n\nDasselbe f√ºr eine ‚Äû0‚Äú.\n\n6\n\nWenn wir genug Bits zusammen haben, dekodieren wir die Bitfolge.\n\n7\n\ndecode_letter(bits) wandelt die Bitfolge in einen Buchstaben um. Die Funktion implementieren wir gleich.\n\n8\n\nWir f√ºgen den Buchstaben dem bisherigen Text an.\n\n9\n\nDanach setzen wir die Bit-Zeichenkette zur√ºck.\n\n\n\n\nDirekt nach dem Start wartet das Programm darauf, dass ihr eure Hand vor den Sensor haltet. Jede erkannte √Ñnderung wird nach 100 Millisekunden noch einmal gemessen, um den Wert zu stabilisieren. Befinden wir uns im Empfangsmodus (receiving ist True), schreiben wir je nach Abstand eine ‚Äû1‚Äú (weit) oder ‚Äû0‚Äú (nah) ans Ende der Zeichenkette bits und schalten den Empfang vor√ºbergehend aus. Sobald die L√§nge von bits der erwarteten MESSAGE_LENGTH entspricht, rufen wir decode_letter(bits) auf, erhalten den passenden Buchstaben, h√§ngen ihn an text an und leeren bits. Erst wenn der Sensor wieder mindestens 30 cm misst, schalten wir den Empfang erneut frei, damit die n√§chste Eingabe beginnen kann.\nOkay ‚Äì probieren wir es aus. Unser Programm sammelt das erste Bit, dann das zweite und dann‚Ä¶\nNameError: name 'decode_letter' is not defined\nWas ist das? Eine Fehlermeldung, die uns sagt: Die Funktion decode_letter() ist nicht definiert. Wir m√ºssen sie also noch implementieren. Wir haben die Funktion zwar schon namentlich genannt, aber es gibt nirgends eine Definition. Das holen wir jetzt nach.\nErinnert euch an Abschnitt 2.10: Wir m√ºssen wissen, was die Funktion tun soll, was sie daf√ºr ben√∂tigt und was sie zur√ºckgibt. Einen Namen haben wir bereits: decode_letter.\nDie Funktion soll unsere Zeichenkette voller Bits der L√§nge zwei, also so etwas wie ‚Äú00‚Äù, ‚Äú01‚Äù, ‚Äú10‚Äù oder ‚Äú11‚Äù, in einen Buchstaben umwandeln. Die Eingabe ist bits und die Ausgabe ein Buchstabe, den diese Bitfolge kodiert. Unsere Funktion k√∂nnte so aussehen:\n\ndef decode_letter(bits):\n    if bits == \"00\":\n        return \"A\"\n    elif bits == \"01\":\n        return \"B\"\n    elif bits == \"10\":\n        return \"C\"\n    elif bits == \"11\":\n        return \"D\"\n\nMit einem if-Statement, begleitet von drei elif-Zweigen, pr√ºfen wir, welchem der m√∂glichen Werte die Zeichenkette bits entspricht, und geben einen Buchstaben A, B, C oder D zur√ºck. Da es mit zwei Bits insgesamt vier M√∂glichkeiten gibt, k√∂nnen wir auch nur vier Buchstaben damit abbilden. Wir erweitern das weiter unten, damit wir alle Buchstaben des Alphabets abdecken k√∂nnen.\n\nUnser aktuelles Codesystem f√ºr vier Buchstaben.\n\n\nBitfolge\nDezimalzahl\nBuchstabe\n\n\n\n\n00\n0\nA\n\n\n01\n1\nB\n\n\n10\n2\nC\n\n\n11\n3\nD\n\n\n\nDie Tabelle fasst unser Codesystem zusammen. In der zweiten Spalte haben wir zur Bitfolge die entsprechende Dezimalzahl eingetragen. Erinnert euch: Das Bin√§rsystem ist ein Stellenwertsystem wie jedes andere auch, nur eben zur Basis 2. Wie ihr die entsprechende Dezimalzahl zu einer Bin√§rzahl errechnet, haben wir in Abschnitt 2.5.3 gelernt.\nF√ºgen wir die Funktion in unser Programm ein. Wichtig ist: Eine Funktion muss vor ihrer Verwendung definiert sein.\n\n\nCode\nMESSAGE_LENGTH = 2\nbits = \"\"\ntext = \"\"\nlast_distance = 0\nreceiving = False\n\ndef decode_letter(bits):\n    if bits == \"00\":\n        return \"A\"\n    elif bits == \"01\":\n        return \"B\"\n    elif bits == \"10\":\n        return \"C\"\n    elif bits == \"11\":\n        return \"D\"\n\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"1\")\n                bits += \"1\"\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"0\")\n                bits += \"0\"\n                receiving = False\n\n            if len(bits) == MESSAGE_LENGTH: \n                print(f\"Bits: {bits}\")\n                letter = decode_letter(bits)\n                print(f\"Buchstabe: {letter}\")\n                text += letter\n                print(f\"Text: {text}\")\n                bits = \"\"\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\n\nCool, neben ‚ÄûABBA‚Äú k√∂nnen wir jetzt auch ‚ÄûADAC‚Äú schreiben. Wir wollen aber nat√ºrlich noch mehr, und bevor wir Bit f√ºr Bit hinzuf√ºgen, √ºberlegen wir, wie viele Bits wir eigentlich ben√∂tigen.\nEs gibt 26 Buchstaben im Alphabet, und vielleicht wollen wir auch ein Leerzeichen kodieren. Die Unterscheidung zwischen Klein- und Gro√übuchstaben lassen wir an dieser Stelle einmal weg ‚Äì sie w√§re aber f√ºr ein praxistaugliches Codesystem wichtig. Somit sind es 27 Zeichen, die wir kodieren wollen. Mit jedem zus√§tzlichen Bit verdoppeln wir unsere M√∂glichkeiten, das haben wir in Abschnitt 2.6 gelernt. Rufen wir uns noch einmal die Tabelle in den Sinn, um zu erkennen, wie viele Bits wir ben√∂tigen.\n\nAnzahl Bits und m√∂gliche Kodierungen.\n\n\nAnzahl Bits\nM√∂gliche Kodierungen\n\n\n\n\n1\n\\(2^1 = 2\\)\n\n\n2\n\\(2^2 = 4\\)\n\n\n3\n\\(2^3 = 8\\)\n\n\n4\n\\(2^4 = 16\\)\n\n\n5\n\\(2^5 = 32\\)\n\n\n6\n\\(2^6 = 64\\)\n\n\n7\n\\(2^7 = 128\\)\n\n\n8\n\\(2^8 = 256\\)\n\n\n\nDemnach reichen uns f√ºnf Bits aus, denn damit k√∂nnen wir insgesamt 32 Kodierungen vornehmen. Wir h√§tten somit noch f√ºnf freie Pl√§tze, die wir vielleicht f√ºr Satzzeichen wie Punkt oder Komma verwenden.\nUm das in unserem Programm zu reflektieren, m√ºssen wir die Funktion decode_letter anpassen und gleichzeitig die L√§nge einer Nachricht auf 5 Bits erh√∂hen. Damit wir es etwas einfacher haben und die Buchstaben den Dezimalzahlen von 0‚Äì25 zuordnen k√∂nnen, wandeln wir die Bitfolge zuerst in eine Dezimalzahl um:\n\ndef decode_letter(bits):\n    \n    # In Dezimalzahl umwandeln\n1    decimal = int(bits, 2)\n\n    if decimal == 0:\n        return \"A\"\n    elif decimal == 1:\n        return \"B\"\n    elif decimal == 2:\n        return \"C\"\n    elif decimal == 3:\n        return \"D\"\n    elif decimal == 4:\n        return \"E\"\n    ...\n    elif decimal == 25:\n        return \"Z\"\n    else:\n        return \"?\"\n\n\n1\n\nDie Funktion int wandelt die Bitfolge in eine Dezimalzahl um. Der erste Parameter ist die Bitfolge als String, der zweite die Basis (hier 2 f√ºr Bin√§rzahlen).\n\n\n\n\nF√ºr die Umwandlung der Bitfolge verwenden wir die Funktion int(), die uns sp√§ter noch √∂fter begegnen wird. Sie wandelt Zeichenketten in ganze Zahlen um, und wenn wir als zweiten Parameter die Basis des Zahlensystems angeben, funktioniert das auch mit Bin√§rzahlen.\nDie L√∂sung funktioniert, allerdings ist sie nicht besonders elegant. Wir m√ºssen f√ºr jeden Buchstaben einen eigenen if/elif-Zweig schreiben, was schnell un√ºbersichtlich wird. Zudem wird unser Code extrem lang ‚Äì im Codeblock oben deutet ... bereits an, dass es noch viele weitere Buchstaben zwischen E und Z gibt. Gl√ºcklicherweise geht das eleganter, und zwar mit einem W√∂rterbuch.\n\n\n3.4.2 W√∂rterb√ºcher\nEin Dictionary (deutsch: W√∂rterbuch) ist in der Programmierung eine Sammlung von Schl√ºssel-Wert-Paaren. √úber einen Schl√ºssel ‚Äì zum Beispiel eine Zahl ‚Äì greifen wir direkt auf den zugeh√∂rigen Wert zu, etwa einen Buchstaben. Stellt euch das wie ein Telefonbuch vor, bei dem ihr √ºber den Namen die Nummer herausfindet. Das ist ideal, wenn wir Bitfolgen zuerst in Dezimalzahlen umwandeln und dann schnell den passenden Buchstaben nachschlagen m√∂chten. Statt viele if/elif-Zweige zu schreiben, legen wir einmalig eine Nachschlagetabelle an. Das macht den Code k√ºrzer, √ºbersichtlicher und leichter erweiterbar.\nF√ºr unsere Zeichendekodierung k√∂nnen wir ein Dictionary nutzen, das die Dezimalwerte 0‚Äì25 auf ‚ÄûA‚Äú‚Äì‚ÄûZ‚Äú abbildet und zum Beispiel 26 als Leerzeichen reserviert. Damit wird decode_letter deutlich kompakter und leichter zu pflegen.\n\n# Nachricht auf 5 Bits erweitern\nMESSAGE_LENGTH = 5\n\n# Dictionary mit 0‚Äì25 =&gt; A‚ÄìZ und 26 =&gt; Leerzeichen\n1SYMBOLS = {}\n2SYMBOLS[0] = \"A\"\nSYMBOLS[1] = \"B\"\nSYMBOLS[2] = \"C\"\nSYMBOLS[3] = \"D\"\nSYMBOLS[4] = \"E\"\n...\nSYMBOLS[25] = \"Z\"\nSYMBOLS[26] = \" \"\n\ndef decode_letter(bits):\n    decimal = int(bits, 2)\n    return SYMBOLS.get(decimal, \"?\")\n\n\n1\n\nMit geschweiften Klammern erzeugen wir ein leeres Dictionary.\n\n2\n\nMit den eckigen Klammern k√∂nnen wir einem Schl√ºssel einen Wert zuweisen. Wenn es den Eintrag nicht gibt, wird er neu angelegt. Andernfalls wird er √ºberschrieben.\n\n\n\n\nWenn ihr sp√§ter weitere Zeichen (z. B. Punkt oder Komma) erg√§nzen wollt, k√∂nnt ihr sie einfach hinzuf√ºgen:\n\nSYMBOLS[27] = \",\"\nSYMBOLS[28] = \".\"\n\nWie ihr an der Schreibweise von SYMBOLS erkennen k√∂nnt, handelt es sich um eine Konstante. Logisch, schlie√ülich ver√§ndert sich unser Codesystem f√ºr die Symbole im Verlauf des Programms nicht. Wir initialisieren ein leeres Dictionary mit geschweiften Klammern (Zeile 5). Die Zuweisung der Werte erfolgt dann √ºber die eckigen Klammern, wobei in den eckigen Klammern der Schl√ºssel (englisch: Key) steht und der Wert, den wir dem Schl√ºssel zuweisen m√∂chten, hinter dem Gleichheitszeichen folgt.\nPrinzipiell k√∂nnten wir mit den eckigen Klammern auch Werte abfragen. Wenn wir zum Beispiel SYMBOLS[0] schreiben, erhalten wir den Wert ‚ÄúA‚Äù zur√ºck. Wenn wir einen Schl√ºssel abfragen, der nicht existiert, bekommen wir jedoch einen Fehler. Eine bessere M√∂glichkeit zum Abfragen von Werten bietet daher die get()-Methode. Sie liefert den Wert f√ºr den Schl√ºssel zur√ºck, den wir als erstes Argument √ºbergeben. Wenn dieser Schl√ºssel nicht existiert, bekommen wir den Wert None zur√ºck, was robuster ist, als wenn das Programm mit einem Fehler abbr√§che. Zudem k√∂nnen wir als zweites Argument einen Standardwert angeben, der zur√ºckgegeben wird, wenn der Schl√ºssel nicht existiert. In unserem Fall ist das ein Fragezeichen ‚Äú?‚Äù, das signalisiert, dass die Bitfolge keinem bekannten Buchstaben zugeordnet werden kann.\n√úberpr√ºft euch selbst: Welcher Wert kommt bei folgendem Aufruf zur√ºck?: SYMBOLS.get(5)\n\n\n\n\nListing¬†3.3: Der vollst√§ndige Code f√ºr die Texteingabe mit dem Infrarot-Abstandssensor.\n\n\n\nCode\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\nimport time\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\n\nir = BrickletDistanceIRV2('2a7S', ipcon)\nled = BrickletRGBLEDV2('ZEL', ipcon)\n\nMESSAGE_LENGTH = 5 # Anzahl Bits pro Buchstabe\nbits = \"\"\ntext = \"\"\nlast_distance = 0\nreceiving = False\n\n# Dictionary mit 0‚Äì25 =&gt; A‚ÄìZ und 26 =&gt; Leerzeichen\nSYMBOLS = {}\nSYMBOLS[0] = \"A\"\nSYMBOLS[1] = \"B\"\nSYMBOLS[2] = \"C\"\nSYMBOLS[3] = \"D\"\nSYMBOLS[4] = \"E\"\nSYMBOLS[5] = \"F\"\nSYMBOLS[6] = \"G\"\nSYMBOLS[7] = \"H\"\nSYMBOLS[8] = \"I\"\nSYMBOLS[9] = \"J\"\nSYMBOLS[10] = \"K\"\nSYMBOLS[11] = \"L\"\nSYMBOLS[12] = \"M\"\nSYMBOLS[13] = \"N\"\nSYMBOLS[14] = \"O\"\nSYMBOLS[15] = \"P\"\nSYMBOLS[16] = \"Q\"\nSYMBOLS[17] = \"R\"\nSYMBOLS[18] = \"S\"\nSYMBOLS[19] = \"T\"\nSYMBOLS[20] = \"U\"\nSYMBOLS[21] = \"V\"\nSYMBOLS[22] = \"W\"\nSYMBOLS[23] = \"X\"\nSYMBOLS[24] = \"Y\"\nSYMBOLS[25] = \"Z\"\nSYMBOLS[26] = \" \"\n\ndef decode_letter(bits):\n    decimal = int(bits, 2)\n    return SYMBOLS.get(decimal, \"?\")\n\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n\n        time.sleep(0.1) \n        distance = ir.get_distance()\n        \n        if receiving:\n            if distance &gt; 170 and distance &lt; 300:\n                print(\"1\")\n                bits += \"1\"\n                receiving = False\n            elif distance &lt;= 170:\n                print(\"0\")\n                bits += \"0\"\n                receiving = False\n\n            if len(bits) == MESSAGE_LENGTH: \n                print(f\"Bits: {bits}\")\n                letter = decode_letter(bits)\n\n                print(f\"Buchstabe: {letter}\")\n                text += letter\n                \n                print(f\"Text: {text}\")\n                bits = \"\"\n        else:\n            if distance &gt;= 300:\n                receiving = True\n            \n        last_distance = distance\n\n\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas Codebeispiel aus diesem Abschnitt findet ihr auf GitHub.\nKlont das Repository und √∂ffnet den Ordner in eurem Visual Studio Code, um es schnell ausf√ºhren zu k√∂nnen.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#ascii-code",
    "href": "text.html#ascii-code",
    "title": "3¬† Texte",
    "section": "3.5 ASCII-Code",
    "text": "3.5 ASCII-Code\nIm vorigen Abschnitt haben wir zusammen √ºberlegt, wie wir Texte kodieren und als Bitfolge √ºber ein universelles Eingabeger√§t basierend auf einem IR-Abstandssensor √ºbertragen k√∂nnen. Ziemlich cool, findet ihr nicht? Dabei haben wir jedem Buchstaben eine eindeutige Bitfolge zugewiesen und sind letztlich auf unser eigenes 5-Bit-Kodierungssystem gekommen.\nWeil eine der ersten Anwendungen mit dem Computer die Verarbeitung von Texten war, haben sich dar√ºber, wie man Texte kodieren kann, schon andere sehr schlaue Leute Gedanken gemacht. Das Ergebnis ist der ASCII-Code, den es seit den 1960er-Jahren gibt und der weltweit standardisiert ist.\nDer ASCII-Code basiert auf sieben Bits und kann somit 128 verschiedene Symbole verwalten. Die vollst√§ndige Liste an Symbolen seht ihr in Abbildung¬†3.4. Die Tabelle enth√§lt f√ºnf Spalten, wobei die ersten vier den Zahlencode f√ºr das kodierte ASCII-Zeichen in unterschiedlichen Zahlensystemen angeben. Ganz links seht ihr die Dezimalzahl, daneben die Bin√§rdarstellung. Zus√§tzlich wird noch die Oktalzahl und die Hexadezimalschreibweise mit angezeigt. Oktal kennen wir bereits, was es mit Hexadezimal auf sich hat, lernen wir sp√§ter in Kapitel 4.\nWenn ihr genau hinseht, erkennt ihr, dass die Bin√§rzahl nicht aus 7, sondern aus 8 Bits besteht. Die erste Ziffer ganz links ist aber immer 0. Das liegt daran, dass Computer h√§ufig in 8-Bit-Einheiten ‚Äì also in Bytes ‚Äì denken. Auch der Speicher eines Computers ist so organisiert. Deshalb ben√∂tigt ein ASCII-Symbol in der Praxis statt sieben, acht Bits auf unserem Computer.\nWas passiert mit dem vermeintlich ‚Äûverschwendeten‚Äú Bit? Damit k√∂nnten wir doch immerhin 128 weitere Symbole abbilden. Und das wird auch gemacht: Es gibt verschiedene lokale Erweiterungen des ASCII-Codes, die zus√§tzliche Zeichen definieren. F√ºr den deutschen Sprachraum etwa die Umlaute √§, √∂, √º und das scharfe S (√ü). F√ºr andere Sprachen gibt es √§hnliche Erweiterungen. Wir nennen diese Erweiterungen auch Codepages.\nDie Codepage, die wir √ºblicherweise verwenden, nennt sich Windows-1252 (CP-1252) und ist eine Erweiterung des ASCII-Codes, die 256 Zeichen umfasst. Die ersten 128 Zeichen sind identisch mit dem ASCII-Code, die weiteren 128 enthalten zus√§tzliche Zeichen, die in westeurop√§ischen Sprachen ben√∂tigt werden.\n\n\n\n\n\n\nAbbildung¬†3.4: Die urspr√ºngliche ASCII-Codetabelle kodiert die Symbole als 7-Bit-Bin√§rzahlen\n\n\n\nDer ASCII-Code ‚Äì das steht f√ºr American Standard Code for Information Interchange ‚Äì beinhaltet ein paar nette Eigenschaften. So k√∂nnen wir zum Beispiel einen Gro√übuchstaben in einen Kleinbuchstaben umwandeln, indem wir 32 zu seinem Dezimalcode addieren. Umgekehrt funktioniert das nat√ºrlich auch.\nF√ºr unsere Texteingabe √ºber den IR-Abstandssensor bedeutet das: Wir ben√∂tigen √ºberhaupt keinen eigenen Code, sondern k√∂nnen einfach den ASCII-Code verwenden. Allerdings m√ºssen wir unsere Nachricht auf die L√§nge 7 erweitern, was mehr Aufwand bei der Eingabe macht. Daf√ºr verwenden wir einen Standard. Argument genug ‚Äì passen wir den Code an.\nDie √Ñnderungen finden im Wesentlichen in der Funktion decode_letter() statt. Zudem √§ndern wir den Wert der Konstante MESSAGE_LENGTH:\n\nMESSAGE_LENGTH = 7 # Anzahl Bits pro Buchstabe\n\n...\n\ndef decode_letter(bits):\n    # Links eine 0 hinzuf√ºgen, damit es 8 Bits sind\n    bits = \"0\" + bits\n\n    # Bin√§rstring in Dezimalzahl und dann in ASCII-Zeichen umwandeln\n    decimal = int(bits, 2)\n    return chr(decimal)\n\nDie decode_letter()-Funktion f√ºgt nun zun√§chst dem √ºbergebenen Bit-String, der aus 7 Bits bestehen sollte, eine 0 an den Anfang hinzu. Damit haben wir die 8 Bits aus der ASCII-Tabelle in Abbildung¬†3.4 komplettiert. Anschlie√üend erfolgt ‚Äì wie zuvor ‚Äì die Konvertierung von bin√§r nach dezimal. Die wesentliche √Ñnderung steht in der Zeile darunter: Wir geben das Ergebnis der Funktion chr() zur√ºck, der wir den Dezimalwert unseres kodierten Symbols √ºbergeben. Brauchen wir also kein Dictionary mehr?\nGanz genau! Es gibt bereits eine Funktion, die die passenden Symbole f√ºr Codes liefern kann. Wenn wir in die offizielle Dokumentation der Funktion chr() schauen, dann steht dort:\n\nReturn the string representing a character with the specified Unicode code point. For example, chr(97) returns the string ‚Äòa‚Äô, while chr(8364) returns the string ‚Äò‚Ç¨‚Äô. This is the inverse of ord().\n\nDie Funktion gibt also die Repr√§sentation des Codes als Zeichen zur√ºck. Aber was steht da? Mit dem angegebenen Unicode-Codepunkt? Was ist denn jetzt schon wieder Unicode? Wir haben doch gerade √ºber ASCII gesprochen.\n\n3.5.1 Unicode\nUnicode ist ein internationaler Standard, der jedes Zeichen aus praktisch allen Schriftsystemen der Welt eindeutig beschreibt. W√§hrend ASCII nur 128 Symbole umfasst und damit vor allem die englische Sprache abdeckt, definiert Unicode einen gemeinsamen Zeichensatz mit weit √ºber einer Million m√∂glichen Codepunkten. Ein Codepunkt ist dabei eine Nummer, die einem Zeichen zugeordnet ist, zum Beispiel hat der Buchstabe ‚ÄûA‚Äú den Codepunkt U+0041 und das Eurozeichen ‚Äû‚Ç¨‚Äú den Codepunkt U+20AC.\nWichtig ist die Unterscheidung zwischen Zeichensatz und Kodierung: Unicode ist der Zeichensatz (die Menge aller Zeichen mit ihren Codepunkten), w√§hrend Formate wie UTF-8, UTF-16 oder UTF-32 beschreiben, wie diese Codepunkte als Bits und Bytes gespeichert oder √ºbertragen werden. UTF-8 ist heute die am weitesten verbreitete Kodierung im Web. Sie ist variabel lang und hat eine zentrale Eigenschaft: Die ersten 128 Codepunkte (0‚Äì127) entsprechen exakt dem ASCII-Code. Dadurch ist UTF-8 vollst√§ndig r√ºckw√§rtskompatibel zu ASCII. Eine reine ASCII-Datei ist zugleich g√ºltiges UTF-8, und Funktionen wie chr() und ord() in Python arbeiten mit Unicode-Codepunkten. Wenn ihr also chr(65) aufruft, erhaltet ihr ‚ÄûA‚Äú ‚Äì das passt sowohl in ASCII als auch in Unicode. F√ºr Zeichen au√üerhalb des ASCII-Bereichs verwendet UTF-8 mehr als ein Byte, bleibt aber weiterhin eindeutig und effizient.\nUTF-8 verwendet je nach Zeichen unterschiedlich viele Bytes ‚Äì zwischen einem und vier. H√§ufige Zeichen wie die ASCII-Buchstaben brauchen nur 1 Byte. Ein ‚ÄûA‚Äú hat den Codepunkt U+0041 und wird in UTF-8 als 0x41 gespeichert. Zeichen mit Akzenten ben√∂tigen oft 2 Bytes, zum Beispiel ‚Äû√§‚Äú (U+00E4) als 0xC3 0xA4. Das Eurozeichen ‚Äû‚Ç¨‚Äú (U+20AC) braucht 3 Bytes: 0xE2 0x82 0xAC. Ein Emoji wie ‚Äûüòä‚Äú (U+1F60A) ben√∂tigt 4 Bytes: 0xF0 0x9F 0x98 0x8A.\nEine hilfreiche Analogie: Stellt euch UTF-8 wie einen Paketdienst mit vier Paketgr√∂√üen (S, M, L, XL) vor. Die meisten Sendungen (ASCII-Zeichen) passen in Gr√∂√üe S und sind damit sehr platzsparend. F√ºr seltenere oder komplexere Zeichen wird automatisch eine gr√∂√üere Paketgr√∂√üe gew√§hlt. Am ‚ÄûAdressaufkleber‚Äú ‚Äì den ersten Bits des ersten Bytes ‚Äì erkennt der Empf√§nger sofort, wie gro√ü das Paket ist und wie viele Folgebytes er einlesen muss. So bleibt Text kompakt, und reine ASCII-Texte sind automatisch g√ºltiges UTF-8.\nAuf diese Weise wird sichergestellt, dass die h√§ufigsten Zeichen m√∂glichst wenig Speicherplatz ben√∂tigen, w√§hrend dennoch alle Zeichen der Welt eindeutig kodiert werden k√∂nnen. Das macht UTF-8 zur bevorzugten Wahl f√ºr die Textverarbeitung in modernen Anwendungen und im Web. Ihr k√∂nnt das √ºbrigens selbst einmal √ºberpr√ºfen: Erstellt zwei leere Textdateien und speichert beide als UTF-8. F√ºgt in die erste einen Text nur aus Buchstaben, Zahlen und Leerzeichen ein und in die zweite einen Text mit Sonderzeichen und Emojis. Dabei sollte in jeder Datei die gleiche Anzahl Zeichen stehen. Wie unterscheidet sich die Gr√∂√üe der Dateien im Dateiexplorer?",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "text.html#led-dimmer-4.0",
    "href": "text.html#led-dimmer-4.0",
    "title": "3¬† Texte",
    "section": "3.6 LED-Dimmer 4.0",
    "text": "3.6 LED-Dimmer 4.0\nIn Kapitel 2 haben wir bereits drei Versionen eines LED-Dimmers gebaut. Eine letzte, vierte Variante kommt noch dazu: Lasst uns schauen, ob wir die Helligkeit mit dem Abstandssensor steuern k√∂nnen.\nDas war wieder einmal eine rhetorische Frage, nat√ºrlich k√∂nnen wir das! Mit Computern l√§sst sich so gut wie jedes Problem l√∂sen, es geht nur um das Wie. Vielleicht habt ihr schon eine Idee, nachdem wir den Abstandssensor in diesem Kapitel schon intensiv kennengelernt haben.\nDer Dimmer aus Kapitel 2 l√§sst die LED in verschiedenen Stufen heller und dunkler leuchten. √úber den Drehknopf haben wir zun√§chst 1er-Schritte umgesetzt, was bedeutete, dass wir 256 Ticks des Drehknopfs ben√∂tigten, um die LED auf volle Helligkeit zu schalten. Sp√§ter haben wir dann eine Konstante STEP eingef√ºhrt, um die Schritte zu vergr√∂√üern, sodass nur noch eine Umdrehung notwendig war.\nWie l√§sst sich das auf den Abstandssensor √ºbertragen? Im Gegensatz zum Drehknopf, den wir beliebig lange in eine Richtung drehen k√∂nnen, hat der Abstandssensor einen festen Messbereich zwischen 4 und 30 cm. Das macht unsere Aufgabe einfacher, denn eine Transformation des Messbereichs in den Helligkeitsbereich der LED ist ausreichend. Wenn der Abstandssensor nun einen Wert von 4 cm misst, soll die LED auf 0 % Helligkeit dimmen, und bei 30 cm auf 100 % Helligkeit.\nNehmen wir an, der aktuelle Messwert ist in distance gespeichert, dann k√∂nnten wir den Helligkeitswert brightness so berechnen:\n\nbrightness = (distance - 40) / (300 - 40) * 255\n\nVergewissern wir uns, dass die Formel richtig ist. Wenn distance den Wert 4 cm hat, dann sollte brightness 0 sein. Das passt, denn der erste Teil der Formel wird dann 0. Und 0 geteilt durch egal was ergibt 0. Wenn distance = 300, dann sollte brightness 255 sein. Das passt ebenfalls, denn der erste Teil der Formel wird dann 260 und 260 geteilt durch 260 ergibt 1. Multipliziert mit 255 ergibt 255. Sieht also gut aus.\nDer folgende Code baut die Berechnungslogik in den LED-Dimmer aus Abschnitt 2.7 ein, der nur eine Farbe (Wei√ü) beherrscht. Wir k√∂nnten ihn aber genau wie in Abschnitt 2.9 um weitere Farben erweitern:\n\nfrom tinkerforge.ip_connection import IPConnection\nfrom tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2\nfrom tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2\n\nipcon = IPConnection()\nipcon.connect('localhost', 4223)\nir = BrickletDistanceIRV2('2a7S', ipcon) \n\nled = BrickletRGBLEDV2('ZEL', ipcon)\nled.set_rgb_value(0, 0, 0)  # Anfangszustand: aus\n\nlast_distance = 0\nwhile True:\n    distance = ir.get_distance()\n    if last_distance != distance:\n        last_distance = distance\n\n        # Abstand (40‚Äì300 mm) auf LED-Helligkeit (0‚Äì255) abbilden\n        brightness = int((distance - 40) / (300 - 40) * 255)\n        led.set_rgb_value(brightness, brightness, brightness)  # LED-Helligkeit setzen\n\nJe n√§her wir mit der Hand an den Sensor kommen, desto dunkler wird die LED ‚Äì und umgekehrt.\nDamit schlie√üen wir dieses Kapitel ab. Wir haben gelernt, wie Computer Texte kodieren. Der Umweg √ºber unser eigenes Eingabeger√§t f√ºr Bin√§rcodes hat sich gelohnt: Eure Programmierskills sind gewachsen!\nIm folgenden Kapitel 4 besch√§ftigen wir uns mit Bildern, wie Computer sie sehen, und wie ein Bild auf den Bildschirm kommt.\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Texte</span>"
    ]
  },
  {
    "objectID": "images.html",
    "href": "images.html",
    "title": "4¬† Bilder",
    "section": "",
    "text": "Zusammenfassung\nUnsere wichtigsten Lernziele in diesem Kapitel sind:",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#zusammenfassung",
    "href": "images.html#zusammenfassung",
    "title": "4¬† Bilder",
    "section": "",
    "text": "Wir f√ºhren das Hexadezimalsystem als ein Zahlensystem mit einer Basis &gt; 10 ein\n\n\n\n\n\n\n\nExperiment\n\n\n\n\nEinf√ºhrung in die Idee einer Pixelmatrix aus Farbwerten als Bild\nVerwendung des LCD-Displays zur Veranschaulichung, auch wenn nur schwarz/wei√ü\nVerwendung von Zeichen auf dem LCD, um Pixel-Bitmaps f√ºr Schriftarten hervorzuheben\nStudierende nutzen Bitmap-Sheet, um ein eigenes Logo zu entwerfen und auf dem LCD anzuzeigen",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#experimentaufbau",
    "href": "images.html#experimentaufbau",
    "title": "4¬† Bilder",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\n\n\nErste Schritte mit ‚Ä¶",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-bitmaps",
    "href": "images.html#sec-images-bitmaps",
    "title": "4¬† Bilder",
    "section": "4.1 Bitmaps",
    "text": "4.1 Bitmaps",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-compressed",
    "href": "images.html#sec-images-compressed",
    "title": "4¬† Bilder",
    "section": "4.2 Komprimierte Bilder",
    "text": "4.2 Komprimierte Bilder",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-hexadecimal",
    "href": "images.html#sec-images-hexadecimal",
    "title": "4¬† Bilder",
    "section": "4.3 Hexadezimal",
    "text": "4.3 Hexadezimal",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "images.html#sec-images-rgb-code",
    "href": "images.html#sec-images-rgb-code",
    "title": "4¬† Bilder",
    "section": "4.4 Der RGB-Code",
    "text": "4.4 Der RGB-Code\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Bilder</span>"
    ]
  },
  {
    "objectID": "sound.html",
    "href": "sound.html",
    "title": "5¬† Ton",
    "section": "",
    "text": "Zusammenfassung",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ton</span>"
    ]
  },
  {
    "objectID": "sound.html#experimentaufbau",
    "href": "sound.html#experimentaufbau",
    "title": "5¬† Ton",
    "section": "Experimentaufbau",
    "text": "Experimentaufbau\n\nHardware\n\n\nErste Schritte mit ‚Ä¶\n\n\n\n\nAdami, Christoph. 2016. ‚ÄûWhat is Information?‚Äú Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, und Dennis Brylow. 2020. Computer science: an overview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: the hidden language of computer hardware and software. 2. Aufl. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, und John Horton Conway. 2004. How to solve it: a new aspect of mathematical method. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.\n\n\nScott, John C. 2009. But how do it know?: the basic principles of computers for everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Ton</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Literaturverzeichnis",
    "section": "",
    "text": "Adami, Christoph. 2016. ‚ÄúWhat Is Information?‚Äù\nPhilosophical Transactions of the Royal Society A: Mathematical,\nPhysical and Engineering Sciences 374 (2063): 20150230. https://doi.org/10.1098/rsta.2015.0230.\n\n\nBrookshear, J. Glenn, and Dennis Brylow. 2020. Computer Science: An\nOverview. 13th edition, global edition. NY, NY: Pearson.\n\n\nPetzold, Charles. 2022. Code: The Hidden Language of Computer\nHardware and Software. 2nd ed. Hoboken: Microsoft Press.\n\n\nP√≥lya, George, and John Horton Conway. 2004. How to Solve It: A New\nAspect of Mathematical Method. Expanded Princeton Science Library\ned. Princeton Science Library. Princeton [N.J.]: Princeton University\nPress.\n\n\nScott, John C. 2009. But How Do It Know?: The Basic Principles of\nComputers for Everyone. Oldsmar, FL: John C. Scott.",
    "crumbs": [
      "Literaturverzeichnis"
    ]
  }
]