# Texte {#sec-text}

## Zusammenfassung {.unnumbered .collapsable}

Im dritten Kapitel basteln wir ein universelles Eingabeger√§t f√ºr Informationen. Daf√ºr verwenden wir einen Infrarot-Abstandssensor, mit dem wir Bits kodieren k√∂nnen. Mit diesen Bits k√∂nnen wir dann zum Beispiel Texte eingeben.

### Schritt f√ºr Schritt zum Ziel {.unnumbered}

Der Weg dahin f√ºhrt √ºber folgende Schritte:

| \# | Was? | Wo? |
|--|-------------------------------------------------------|----------------|
| 1 | Wir machen uns mit dem Infrarot-Abstandssensor vertraut. | @sec-text-experiment-setup |
| 2 | Wir bauen eine einfache Lichtschranke. | @sec-text-light-barrier |
| 3 | Wir erweitern die Lichtschranke zu einer Hinderniserkennung f√ºr Roboter. | @sec-text-obstacle-detection |
| 4 | Wir erschaffen ein universelles Eingabeger√§t f√ºr Bin√§rcodes. | @sec-text-universal-input |
| 5 | Wir geben den Bin√§rcodes eine Bedeutung und √ºbermitteln Texte. | @sec-text-encode-text |
| 6 | Wir schauen auf ein verbreitetes Codesystem f√ºr Texte: ASCII. | @sec-text-ascii-code |
| 7 | Wir setzen den Infrarot-Abstandssensor in den LED-Dimmer ein. | @sec-text-led-dimmer |

### Begriffe und Konzepte {.unnumbered}

Dabei lernen wir neue Begriffe und Konzepte kennen.

<!-- CHAPTER_GLOSSARY_START -->
::: {.datatable-nosearch data-order='[[2,"asc"]]'}
| Begriff | Kategorie | Wo? |
|---|---|---|
| **Infrarot-Abstandssensor** | Hardware | @sec-text-light-barrier |
| **Else-Anweisung** | Programmieren | @sec-text-light-barrier |
| **Kodieren** | Codesysteme | @sec-text-universal-input |
| **Keyboard** | Hardware | @sec-text-universal-input |
| **Dekodieren** | Codesysteme | @sec-text-universal-input |
| **Bug** | Programmierung | @sec-text-encode-text |
| **Zeichenkette** | Programmierung | @sec-text-encode-text |
| **Dictionary** | Programmierung | @sec-text-encode-text |
| **ASCII-Code** | Codesysteme | @sec-text-encode-text |
| **Codepage** | Codesysteme | @sec-text-encode-text |
| **Unicode** | Codesysteme | @sec-text-encode-text |
| **UTF-8** | Codesysteme | @sec-text-encode-text |
| **Textdatei** | Codesysteme | @sec-text-encode-text |
| **Codepunkt** | Codesysteme | @sec-text-encode-text |
:::
<!-- CHAPTER_GLOSSARY_END -->

## Experimentaufbau {#sec-text-experiment-setup .collapsable}

### Hardware

F√ºr dieses Kapitel ben√∂tigen wir erneut die LED ([RGB LED Bricklet 2.0](https://www.tinkerforge.com/de/shop/rgb-led-v2-bricklet.html)), ersetzen aber den Drehknopf aus @sec-numbers durch einen Infrarot-Abstandssensor ([Distance IR 4-30cm Bricklet 2.0](https://www.tinkerforge.com/de/shop/distance-ir-4-30cm-v2-bricklet.html)). Beide Ger√§te schlie√üen wir an den Mikrocontroller ([Master Brick 3.2](https://www.tinkerforge.com/de/shop/master-brick.html)) an und fixieren sie auf einer Montageplatte. Wie in der Abbildung gezeigt, befestigen wir den Abstandssensor mit einem Metallwinkel so, dass er b√ºndig mit der Platte ist und nach vorn zeigt.

Die vollst√§ndige Hardwareliste f√ºr dieses Kapitel sieht so aus:

-  1 x [Master Brick 3.2](https://www.tinkerforge.com/de/doc/Hardware/Bricks/Master_Brick.html)
-  1 x [RGB LED Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/RGB_LED_V2.html)
-  1 x [Distance IR 4-30cm Bricklet 2.0](https://www.tinkerforge.com/de/shop/distance-ir-4-30cm-v2-bricklet.html)
-  1 x [Montageplatte 22x10](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-plate-22x10.html)
-  2 x [Brickletkabel 15cm (7p-7p)](https://www.tinkerforge.com/de/shop/accessories/cable/bricklet-cable-15cm-7p-7p.html)
-  2 x [Befestigungskit 12 mm](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-kit-12mm.html)

::: {#fig-setup-rgb-led-ir layout="[[1], [1,1], [1,1]]"}
![Seitenansicht.](images/master_brick_with_led_and_ir_03.jpg){#fig-setup-rgb-led-ir .lightbox group="setup-rgb-ir"}

![Draufsicht.](images/master_brick_with_led_and_ir_02.jpg){#fig-setup-rgb-led-ir-b .lightbox group="setup-rgb-ir"}

![Nahaufnahme des IR-Abstandssensors.](images/master_brick_with_led_and_ir_04.jpg){#fig-setup-rgb-led-ir-c .lightbox group="setup-rgb-ir"}

![Seitenansicht, leicht schr√§g.](images/master_brick_with_led_and_ir_01.jpg){#fig-setup-rgb-led-ir-d .lightbox group="setup-rgb-ir"}

Einfaches Setup mit einem Mikrocontroller, LED und einem Infrarot-Abstandssensor.
:::

### Erste Schritte mit dem Abstandssensor {#sec-text-first-steps}

Wie bei der LED werfen wir zuerst einen Blick auf den neuen Abstandssensor im Brick Viewer. Schlie√üt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Tab Setup sollten nun neben der LED auch der Abstandssensor erscheinen. Denkt daran: Dort findet ihr auch die UID eurer Ger√§te ‚Äì die braucht ihr gleich im Programm.

![Nach erfolgreicher Verbindung erscheint der Infrarot-Entfernungsmesser in der √úbersicht des Brick Viewers.](images/brick_viewer_connect_ir_sensor.png){#fig-brick-viewer-connect-ir-sensor .lightbox group="brick-viewer-ir"}

Wechselt in den Tab f√ºr den Abstandssensor, wo ihr ihn direkt testen k√∂nnt: Ihr seht die aktuelle Entfernung, die der Sensor misst, in Echtzeit oben in der Mitte (in Zentimetern). Darunter zeigt ein Kurvendiagramm den zeitlichen Verlauf. Bewegt eure Hand vor dem Sensor, um ein Gef√ºhl f√ºr sein Verhalten zu bekommen. Was passiert, wenn ihr sehr nah vor dem Sensor seid? Und was, wenn ihr eure Hand weiter weg bewegt?

![Der Brick Viewer zeigt die aktuelle Entfernung im Zeitverlauf an.](images/brick_viewer_ir_sensor.png){#fig-brick-viewer-ir-sensor .lightbox group="brick-viewer-ir"}

## Lichtschranke {#sec-text-light-barrier .collapsable}

Einen \gloss{Infrarot-Abstandssensor}{Ein Sensor, der √ºber Licht des Infrarotspektrums Abst√§nde messen kann.}{Hardware} verwenden wir in der Praxis zur ber√ºhrungslosen Messung des Abstands zu einem Objekt. Der Sensor sendet einen unsichtbaren Infrarotlichtstrahl aus und misst das Licht, das vom Objekt zur√ºckgeworfen wird. Anhand der Intensit√§t oder des Winkels des zur√ºckkehrenden Lichts berechnet der Sensor die Entfernung. Diese Sensoren sind aus der Praxis nicht wegzudenken und kommen in vielen Szenarien zum Einsatz, zum Beispiel:

- Objekterkennung an einem Flie√üband
- F√ºllstandsmessung in Beh√§ltern
- Hinderniserkennung f√ºr Roboter, etwa bei Staubsaugerrobotern
- Positionierung von Werkst√ºcken in Maschinen
- Einparkhilfe beim Auto

Letztlich lassen sich alle Anwendungsf√§lle auf zwei Fragen reduzieren:

1. Befindet sich ein Objekt in der Sicht des Sensors?
2. Wie weit ist ein Objekt vom Abstandssensor entfernt?

Wir starten mit der einfacheren der beiden Fragen: Befindet sich ein Objekt in der Sicht des Sensors? Das beschreibt im Kern die Funktion einer Lichtschranke.

Wie ihr beim Ausprobieren im Brick Viewer festgestellt habt, misst der Sensor Entfernungen zwischen 4 und 30 cm. Das bedeutet: Objekte au√üerhalb dieses Bereichs werden nicht erkannt ‚Äì weder n√§her als 4 cm noch weiter als 30 cm. Eine Lichtschranke hat somit die Aufgabe zu pr√ºfen, ob der IR-Abstandssensor einen Wert kleiner als 30 cm misst. Dann befindet sich ein Objekt in seiner Sichtlinie.

Verbinden wir uns mit dem Sensor und schreiben das notwendige Grundger√ºst. Tragt eure UIDs ein und legt beide Bricklets an, Sensor und LED:

```{python}
#| lst-cap: Boilerplate-Code f√ºr IR-Abstandssensor und RGB-LED
#| lst-label: lst-text-ir-led-boilerplate
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2
import time

ipcon = IPConnection()
ipcon.connect('localhost', 4223)

ir = BrickletDistanceIRV2('2a7S', ipcon)     # <1>
led = BrickletRGBLEDV2('ZEL', ipcon)         # <2>
```

1. Tragt hier die UID eures IR-Sensors ein.
2. Tragt hier die UID eurer RGB-LED ein.

Der Sensor ist danach in der Variablen `ir` gespeichert. √úber sie k√∂nnen wir [seine Funktionen](https://www.tinkerforge.com/de/doc/Software/Bricklets/DistanceIRV2_Bricklet_Python.html) aufrufen. Eine davon erlaubt uns das Auslesen des aktuell gemessenen Werts:

```{python}
#| code-line-numbers: false
distance = ir.get_distance()
```

Ein Blick in die Dokumentation verr√§t, dass der R√ºckgabewert in Millimetern angegeben wird. Ein Wert an der oberen Grenze (rund 300 mm) signalisiert typischerweise, dass sich kein Objekt innerhalb der Reichweite befindet. Damit wir besser testen k√∂nnen, lesen wir den Wert kontinuierlich aus und schreiben ihn auf die Konsole:

```{python}
#| code-line-numbers: false
while True:
    distance = ir.get_distance()
    print(f"Aktuelle Entfernung: {distance} mm")
```

Ihr werdet sehen, dass wir sehr viele Ausgaben erzeugen, weil in jedem Schleifendurchlauf der Wert ausgegeben wird ‚Äì auch wenn er sich nicht ver√§ndert hat. Geben wir erneut nur die Ver√§nderungen aus, um die Ausgaben zu reduzieren:

```{python}
#| code-line-numbers: false
last_distance = 0
while True:
    distance = ir.get_distance()
    if distance != last_distance:
        print(f"Aktuelle Entfernung: {distance} mm")
        last_distance = distance
```

Ihr erinnert euch: Dasselbe Prinzip haben wir in @sec-numbers-led-dimmer-2 verwendet, um nur bei einer √Ñnderung des Drehknopfs eine Ausgabe zu erzeugen. Wir merken uns den letzten Wert und vergleichen ihn mit dem aktuell gemessenen. Ist er gleich, passiert nichts. Hat er sich ver√§ndert (`distance != last_distance`), geben wir den neuen Wert aus und aktualisieren den letzten Wert (`last_distance = distance`).

Wir sind unserem Etappenziel einer Lichtschranke schon sehr nah. Anhand der Ausgabe k√∂nnten wir entscheiden, ob ein Objekt in der Sicht des Sensors ist oder nicht. Das soll aber unser Programm automatisch erledigen. Dazu f√ºgen wir eine weitere Bedingung mit einer `if`-Anweisung hinzu:

```{python}
#| code-line-numbers: false
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance < 300:
            print(f"Objekt erkannt: {distance} mm")
        else:
            print("Kein Objekt in Reichweite")
    
        last_distance = distance
```

Die neue `if`-Anweisung pr√ºft, ob der Abstand kleiner als 300 mm ist. Dann befindet sich etwas vor dem Sensor. In diesem Fall geben wir einen entsprechenden Hinweis aus. Andernfalls kommt der Hinweis ‚ÄûKein Objekt in Reichweite‚Äú. Diesen anderen Fall bildet der optionale `else`-Teil ab. Code hinter `else` wird immer dann ausgef√ºhrt, wenn keine der vorher definierten Bedingungen √ºber `if` oder `elif` zutrifft.

Damit unsere Lichtschranke auch ohne Blick auf die Konsole funktioniert, bringen wir im letzten Schritt die LED ins Spiel. Sie soll rot aufleuchten, wenn ein Objekt erkannt wird. Die LED haben wir bereits kennengelernt, den Code k√∂nnen wir √ºbernehmen:

```{python}
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance < 300:
            print(f"Objekt erkannt: {distance} mm")
            led.set_rgb_value(255, 0, 0) # <1>
        else:
            print("Kein Objekt in Reichweite")
            led.set_rgb_value(0, 0, 0)   # <2>
    
        last_distance = distance
```

1. Die LED leuchtet rot, wenn ein Objekt erkannt wird.
2. Die LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.

Probiert es aus ‚Äì die Lichtschranke sollte funktionieren und Objekte innerhalb von 30 cm zuverl√§ssig erkennen.

## Hinderniserkennung {#sec-text-obstacle-detection .collapsable}

Die Lichtschranke leuchtet immer rot, sobald ein Objekt erkannt wird. Dabei spielt die Entfernung keine Rolle. Lasst uns die Idee zu einer Hinderniserkennung f√ºr einen hypothetischen Staubsaugerroboter erweitern. Die LED soll anzeigen, ob sich ein Objekt bereits nahe am Roboter befindet oder ob es noch weit genug entfernt ist.

Nehmen wir an, dass Objekte, die 17 cm oder n√§her am Roboter sind, als Gefahr gelten. Alles, was zwischen 17 und 30 cm Abstand h√§lt, sieht der Roboter nicht als bedrohlich an. Die drei Zust√§nde wollen wir √ºber die Farbe der LED abbilden:

- Gelb: Objekt in mittlerer Entfernung erkannt (17 cm < Abstand < 30 cm)
- Rot: Nahes Objekt erkannt (<= 17 cm)
- Aus: Kein Objekt vor dem Sensor (>= 30 cm)

Wir k√∂nnen dazu den Code der Lichtschranke erweitern:

```{python}
#| lst-cap: Der Code f√ºr die zweistufige Hinderniserkennung.
#| lst-label: lst-text-obstacle-detection
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance > 170 and distance < 300:
            led.set_rgb_value(255, 255, 0) # <1>
        elif distance <= 170:
            led.set_rgb_value(255, 0, 0)   # <2>
        else:
            led.set_rgb_value(0, 0, 0)     # <3>
    
        last_distance = distance
```

1. Die LED leuchtet gelb, wenn ein Objekt in mittlerer Entfernung erkannt wird.
2. Die LED leuchtet rot, wenn ein Objekt in naher Entfernung erkannt wird.
3. Die LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.

Ihr erinnert euch an die additive Farbmischung aus @fig-additive-color-mixing? Gelb entsteht durch die Kombination von Rot und Gr√ºn. Wir verwenden hier eine `elif`-Anweisung, die eine weitere Bedingung pr√ºft, wenn die vorherige `if`-Bedingung nicht zutrifft. So k√∂nnen wir mehrere Bedingungen hintereinander pr√ºfen. Der letzte `else`-Teil f√§ngt alle F√§lle ab, in denen kein Objekt erkannt wurde.

<!-- 
\gloss{Else-Anweisung}{Ein optionaler Teil einer if-Anweisung, der ausgef√ºhrt wird, wenn keine der vorherigen Bedingungen zutrifft.}{Programmieren}
-->

Unser Staubsaugerroboter k√∂nnte den Code oben verwenden, um Hindernisse zu erkennen und bei zu gro√üer N√§he ein Ausweichman√∂ver zu starten.

## Universelles Eingabeger√§t {#sec-text-universal-input .collapsable}

Eine andere M√∂glichkeit, den Abstandssensor und den Code aus @lst-text-obstacle-detection zu verwenden, ist ein Eingabeger√§t f√ºr Informationen in unseren Computer. Wie soll ein Abstandssensor als Eingabeger√§t f√ºr Informationen fungieren?

Wie wir sp√§ter noch sehen werden, ben√∂tigen wir f√ºr die Darstellung von Informationen unterschiedliche Zust√§nde ‚Äì mindestens zwei. Genau das verk√∂rpert das Bit, das wir in @sec-numbers-bit-and-bytes kennengelernt haben: Ein Bit hat zwei Zust√§nde, an oder aus, 0 oder 1.

Was w√§re, wenn wir die beiden Bereiche ‚Äûnah‚Äú und ‚Äûweit genug entfernt‚Äú nicht l√§nger als Entfernungen interpretieren, sondern einfach als zwei Zust√§nde? Sagen wir, der Bereich ‚Äûweit genug entfernt‚Äú steht f√ºr die 1 und der Bereich ‚Äûnah‚Äú f√ºr die 0. Dann k√∂nnten wir √ºber die bewusste Platzierung eines soliden Gegenstands und anschlie√üende Messung der Entfernung den Zustand eines Bits kodieren:

```{python}
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance > 170 and distance < 300:
            print("1")
        elif distance <= 170:
            print("0")
    
        last_distance = distance
```

Wenn ihr den Code ausf√ºhrt, werdet ihr ein Problem erkennen: Platzieren wir unsere Hand nahe am Sensor, um eine 0 zu kodieren, gibt das Programm nacheinander sehr viele Nullen aus. Dasselbe gilt f√ºr Einsen. Dabei wollen wir mit einer Handgeste jeweils nur eine 1 oder 0 √ºbermitteln, nicht eine ganze Reihe. Das liegt daran, dass sich unsere Hand st√§ndig minimal bewegt ‚Äì ein Millimeter reicht.

Wir m√ºssen unser Programm so anpassen, dass es nicht erneut auf eine √Ñnderung reagiert, solange die Hand nicht wieder weggenommen wurde. Das erkennen wir daran, dass der Sensor die maximale Entfernung von 30 cm misst. Erst wenn dieses Ereignis wieder auftritt, soll ein neuer Zustand kodiert werden.

Eine L√∂sung besteht darin, dass wir uns merken, ob unser Eingabeger√§t aktuell empfangsbereit ist oder nicht. Wir f√ºhren daf√ºr die Variable `receiving` ein, die den Zustand unseres Eingabeger√§ts beschreibt. Ist sie `True`, ist das Ger√§t bereit, eine Eingabe zu empfangen. Ist sie `False`, ignorieren wir alle √Ñnderungen, bis die Hand wieder weggenommen wurde.

```{python}
last_distance = 0
receiving = False
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        
        if receiving: # <1>
            if distance > 170 and distance < 300:
                print(f"1 bei {distance} mm")
                receiving = False
            elif distance <= 170:
                print(f"0 bei {distance} mm")
                receiving = False
        else: # <2>
            if distance >= 300:
                receiving = True # <3>
                print("Bereit f√ºr den n√§chsten Code")

        last_distance = distance
```

1. Nur im Empfangsmodus wird anhand der Entfernung ein Bit kodiert.
2. Wenn wir nicht im Empfangsmodus sind, pr√ºfen wir, ob die Hand wieder weggenommen wurde (>= 30 cm).
3. Wenn die Hand weg ist, schalten wir wieder in den Empfangsmodus.

Das sieht schon gut aus. Probiert aber einmal aus, eure Hand sehr langsam von oben nach unten vor den Sensor zu bewegen, und zwar im nahen Bereich, sodass eigentlich eine 0 kodiert werden sollte. In manchen F√§llen erkennt das Programm f√§lschlicherweise eine 1 statt der 0. Warum ist das so? Der Sensor hat bei der Messung eine leichte zeitliche Verz√∂gerung. Wenn er aktuell 30 cm Abstand misst und wir unsere Hand langsam nach unten bewegen, misst der Sensor zun√§chst einen Abstand knapp unter 30 cm. Das Programm reagiert sofort und kodiert eine 1, obwohl wenig sp√§ter der Sensorwert in den Bereich der 0 kommt (zum Beispiel 8 cm).

Wir k√∂nnen das Problem umgehen, indem wir einen kleinen Verzug einbauen, sobald ein Unterschied erkannt wurde. Nach diesem zeitlichen Verzug messen wir erneut, um sicherzugehen, die korrekte Position der Hand zu erwischen. So k√∂nnte das im Code aussehen:

```{python}
last_distance = 0
receiving = False
while True:
    distance = ir.get_distance()
    if last_distance != distance:

        # 100 ms warten und erneut messen
        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print(f"1 bei {distance} mm")
                receiving = False
            elif distance <= 170:
                print(f"0 bei {distance} mm")
                receiving = False
        else:
            if distance >= 300:
                receiving = True
                print("Bereit f√ºr den n√§chsten Code")

        last_distance = distance
```

Testet es jetzt: Unser Eingabeger√§t erkennt die Zust√§nde 0 und 1 zuverl√§ssig.

## Texte kodieren {#sec-text-encode-text .collapsable}

<!--
\gloss{Kodieren}{Das Umwandeln von Informationen in ein bestimmtes Format, das von einem Computer verarbeitet werden kann.}{Codesysteme}
-->

K√∂nnen wir unser universelles Eingabeger√§t dazu verwenden, dem Computer Texte zu diktieren? Schlie√ülich bedeutet ‚Äûuniversell‚Äú, dass es f√ºr viele Zwecke einsetzbar ist. Und die Antwort lautet: ja! Wenn wir ein Ger√§t entwickeln, mit dem wir Bits kodieren k√∂nnen, k√∂nnen wir damit alles eingeben, was ein Computer darstellen kann.

In @sec-numbers haben wir gesehen, wie wir mit 8 Bits den Wert einer der drei Grundfarben im RGB-Code darstellen k√∂nnen. Wenn wir unser Eingabeger√§t einsetzen, um hintereinander 24 Bits zu √ºbermitteln und diese als einen RGB-Farbcode zu interpretieren, k√∂nnten wir damit unsere LED in einer beliebigen Farbe aufleuchten lassen. Das versuchen wir sp√§ter. Jetzt k√ºmmern wir uns um eine ebenso wichtige Form der Information: Texte.

Texte bestehen allgemein aus Zeichen. Die meisten Zeichen in Texten sind Buchstaben, die wir in Klein- und Gro√übuchstaben unterscheiden. Dazu kommen Zahlen und Satzzeichen. Schaut auf das \gloss{Keyboard}{Tastatur}{Hardware} eures Computers ‚Äì dort findet ihr die meisten Zeichen, die ihr f√ºr Texte ben√∂tigt.

### Wie viele Bits ben√∂tigen wir?

Genau wie bei den Farben, f√ºr die wir 24 Bits ben√∂tigen (jeweils 8 pro Farbe im RGB-Code), stellt sich bei Texten die Frage, wie viele Bits wir ben√∂tigen, um ein Zeichen darzustellen. Die Antwort h√§ngt von der Anzahl der ben√∂tigten Zeichen ab.

N√§hern wir uns von der anderen Seite und erweitern unseren Zeichencode Bit f√ºr Bit. Wir beginnen klein und fangen mit einem Bit an. Wenn wir Bits als Text interpretieren, wie viele Zeichen (oder Buchstaben) k√∂nnen wir dann mit einem einzigen Bit darstellen? Richtig: zwei!

```{python}
last_distance = 0
receiving = False
while True:
    distance = ir.get_distance()
    if last_distance != distance:

        # 100 ms warten und erneut messen
        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("B")
                receiving = False
            elif distance <= 170:
                print("A")
                receiving = False
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

Lasst das Programm laufen und legt eure Hand einmal nahe vor den Sensor, dann zweimal weiter weg und wieder nah. Das habt ihr gerade geschrieben: ‚ÄûABBA‚Äú.

Neben der bekannten schwedischen Band lassen sich mit den Buchstaben A und B jedoch nicht viele andere W√∂rter bilden. Wir sind also gut beraten, mindestens ein zweites Bit hinzuzunehmen. Die Anzahl Bits, die wir f√ºr einen Buchstaben ben√∂tigen, erh√∂ht sich damit auf zwei. Wie bilden wir das im Programm ab?

Am einfachsten, indem wir uns die Bits zun√§chst merken, sie also hintereinander in eine Zeichenkette schreiben. Sobald eine vorher definierte L√§nge einer Nachricht ‚Äì hier zun√§chst zwei Bits ‚Äì erreicht ist, dekodieren wir die Bitfolge und erhalten den passenden Buchstaben. Danach geht es wieder von vorn los und unsere Bit-Zeichenkette ist wieder leer.

<!--
\gloss{Dekodieren}{Das Umwandeln von kodierten Informationen zur√ºck in ihr urspr√ºngliches Format.}{Codesysteme}
-->

```{python}
MESSAGE_LENGTH = 2 # <1>
bits = ""         # <2>
text = ""         # <3>
last_distance = 0
receiving = False

while True:
    distance = ir.get_distance()
    if last_distance != distance:

        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("1")
                bits += "1"  # <4>
                receiving = False
            elif distance <= 170:
                print("0")
                bits += "0"  # <5>
                receiving = False

            if len(bits) == MESSAGE_LENGTH:  # <6>
                print(f"Bits: {bits}")
                letter = decode_letter(bits) # <7>
                print(f"Buchstabe: {letter}")
                text += letter               # <8>
                print(f"Text: {text}")
                bits = ""                    # <9>
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

1. Die L√§nge einer Nachricht. So viele Bits m√ºssen wir sammeln, bis wir die Nachricht entschl√ºsseln k√∂nnen.
2. Wir erstellen eine leere Zeichenkette `bits`, in der wir jedes empfangene Bit speichern.
3. `text` sammelt die dekodierten Buchstaben zu einem Text.
4. Wir merken uns das Bit, indem wir es an das Ende von `bits` hinzuf√ºgen ‚Äì hier eine ‚Äû1‚Äú.
5. Dasselbe f√ºr eine ‚Äû0‚Äú.
6. Wenn wir genug Bits zusammen haben, dekodieren wir die Bitfolge.
7. `decode_letter(bits)` wandelt die Bitfolge in einen Buchstaben um. Die Funktion implementieren wir gleich.
8. Wir f√ºgen den Buchstaben dem bisherigen Text an.
9. Danach setzen wir die Bit-Zeichenkette zur√ºck.

Direkt nach dem Start wartet das Programm darauf, dass ihr eure Hand vor den Sensor haltet. Jede erkannte √Ñnderung wird nach 100 Millisekunden noch einmal gemessen, um den Wert zu stabilisieren. Befinden wir uns im Empfangsmodus (`receiving` ist `True`), schreiben wir je nach Abstand eine ‚Äû1‚Äú (weit) oder ‚Äû0‚Äú (nah) ans Ende der Zeichenkette `bits` und schalten den Empfang vor√ºbergehend aus. Sobald die L√§nge von `bits` der erwarteten `MESSAGE_LENGTH` entspricht, rufen wir `decode_letter(bits)` auf, erhalten den passenden Buchstaben, h√§ngen ihn an `text` an und leeren `bits`. Erst wenn der Sensor wieder mindestens 30 cm misst, schalten wir den Empfang erneut frei, damit die n√§chste Eingabe beginnen kann.

Okay ‚Äì probieren wir es aus. Unser Programm sammelt das erste Bit, dann das zweite und dann...

```
NameError: name 'decode_letter' is not defined
```

<!--
\gloss{Bug}{Ein Fehler in einem Programm, der dazu f√ºhrt, dass es nicht wie erwartet funktioniert.}{Programmierung}
-->

Was ist das? Eine Fehlermeldung (wie sprechen auch von Bugs), die uns sagt: Die Funktion `decode_letter()` ist nicht definiert. Wir m√ºssen sie also noch implementieren. Wir haben die Funktion zwar schon namentlich genannt, aber es gibt nirgends eine Definition. Das holen wir jetzt nach.

Erinnert euch an @sec-numbers-functions: Wir m√ºssen wissen, was die Funktion tun soll, was sie daf√ºr ben√∂tigt und was sie zur√ºckgibt. Einen Namen haben wir bereits: `decode_letter`.

Die Funktion soll unsere \gloss{Zeichenkette}{Eine Abfolge von Zeichen}{Programmierung} voller Bits der L√§nge zwei, also so etwas wie "00", "01", "10" oder "11", in einen Buchstaben umwandeln. Die Eingabe ist `bits` und die Ausgabe ein Buchstabe, den diese Bitfolge kodiert. Unsere Funktion k√∂nnte so aussehen:

```{python}
def decode_letter(bits):
    if bits == "00":
        return "A"
    elif bits == "01":
        return "B"
    elif bits == "10":
        return "C"
    elif bits == "11":
        return "D"
```

Mit einem `if`-Statement, begleitet von drei `elif`-Zweigen, pr√ºfen wir, welchem der m√∂glichen Werte die Zeichenkette `bits` entspricht, und geben einen Buchstaben A, B, C oder D zur√ºck. Da es mit zwei Bits insgesamt vier M√∂glichkeiten gibt, k√∂nnen wir auch nur vier Buchstaben damit abbilden. Wir erweitern das weiter unten, damit wir alle Buchstaben des Alphabets abdecken k√∂nnen.

| Bitfolge | Dezimalzahl | Buchstabe |
|----------|-------------|-----------|
| 00       | 0           | A         |
| 01       | 1           | B         |
| 10       | 2           | C         |
| 11       | 3           | D         |

: Unser aktuelles Codesystem f√ºr vier Buchstaben.

Die Tabelle fasst unser Codesystem zusammen. In der zweiten Spalte haben wir zur Bitfolge die entsprechende Dezimalzahl eingetragen. Erinnert euch: Das Bin√§rsystem ist ein Stellenwertsystem wie jedes andere auch, nur eben zur Basis 2. Wie ihr die entsprechende Dezimalzahl zu einer Bin√§rzahl errechnet, haben wir in @sec-numbers-binary-system gelernt.

F√ºgen wir die Funktion in unser Programm ein. Wichtig ist: Eine Funktion muss vor ihrer Verwendung definiert sein.

```{python}
#| code-fold: show
MESSAGE_LENGTH = 2
bits = ""
text = ""
last_distance = 0
receiving = False

def decode_letter(bits):
    if bits == "00":
        return "A"
    elif bits == "01":
        return "B"
    elif bits == "10":
        return "C"
    elif bits == "11":
        return "D"

while True:
    distance = ir.get_distance()
    if last_distance != distance:

        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("1")
                bits += "1"
                receiving = False
            elif distance <= 170:
                print("0")
                bits += "0"
                receiving = False

            if len(bits) == MESSAGE_LENGTH: 
                print(f"Bits: {bits}")
                letter = decode_letter(bits)
                print(f"Buchstabe: {letter}")
                text += letter
                print(f"Text: {text}")
                bits = ""
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

Cool, neben ‚ÄûABBA‚Äú k√∂nnen wir jetzt auch ‚ÄûADAC‚Äú schreiben. Wir wollen aber nat√ºrlich noch mehr, und bevor wir Bit f√ºr Bit hinzuf√ºgen, √ºberlegen wir, wie viele Bits wir eigentlich ben√∂tigen.

Es gibt 26 Buchstaben im Alphabet, und vielleicht wollen wir auch ein Leerzeichen kodieren. Die Unterscheidung zwischen Klein- und Gro√übuchstaben lassen wir an dieser Stelle einmal weg ‚Äì sie w√§re aber f√ºr ein praxistaugliches Codesystem wichtig. Somit sind es 27 Zeichen, die wir kodieren wollen. Mit jedem zus√§tzlichen Bit verdoppeln wir unsere M√∂glichkeiten, das haben wir in @sec-numbers-bit-and-bytes gelernt. Rufen wir uns noch einmal die Tabelle in den Sinn, um zu erkennen, wie viele Bits wir ben√∂tigen.

| Anzahl Bits | M√∂gliche Kodierungen |
|-------------|----------------------|
| 1           | $2^1 = 2$            |
| 2           | $2^2 = 4$            |
| 3           | $2^3 = 8$            |
| 4           | $2^4 = 16$           |
| 5           | $2^5 = 32$           |
| 6           | $2^6 = 64$           |
| 7           | $2^7 = 128$          |
| 8           | $2^8 = 256$          |

: Anzahl Bits und m√∂gliche Kodierungen.

Demnach reichen uns f√ºnf Bits aus, denn damit k√∂nnen wir insgesamt 32 Kodierungen vornehmen. Wir h√§tten somit noch f√ºnf freie Pl√§tze, die wir vielleicht f√ºr Satzzeichen wie Punkt oder Komma verwenden.

Um das in unserem Programm zu reflektieren, m√ºssen wir die Funktion `decode_letter` anpassen und gleichzeitig die L√§nge einer Nachricht auf 5 Bits erh√∂hen. Damit wir es etwas einfacher haben und die Buchstaben den Dezimalzahlen von 0‚Äì25 zuordnen k√∂nnen, wandeln wir die Bitfolge zuerst in eine Dezimalzahl um:

```{python}
def decode_letter(bits):
    
    # In Dezimalzahl umwandeln
    decimal = int(bits, 2) # <1>

    if decimal == 0:
        return "A"
    elif decimal == 1:
        return "B"
    elif decimal == 2:
        return "C"
    elif decimal == 3:
        return "D"
    elif decimal == 4:
        return "E"
    ...
    elif decimal == 25:
        return "Z"
    else:
        return "?"
```

1. Die Funktion `int` wandelt die Bitfolge in eine Dezimalzahl um. Der erste Parameter ist die Bitfolge als String, der zweite die Basis (hier 2 f√ºr Bin√§rzahlen).

F√ºr die Umwandlung der Bitfolge verwenden wir die Funktion `int()`, die uns sp√§ter noch √∂fter begegnen wird. Sie wandelt Zeichenketten in ganze Zahlen um, und wenn wir als zweiten Parameter die Basis des Zahlensystems angeben, funktioniert das auch mit Bin√§rzahlen.

Die L√∂sung funktioniert, allerdings ist sie nicht besonders elegant. Wir m√ºssen f√ºr jeden Buchstaben einen eigenen `if`/`elif`-Zweig schreiben, was schnell un√ºbersichtlich wird. Zudem wird unser Code extrem lang ‚Äì im Codeblock oben deutet `...` bereits an, dass es noch viele weitere Buchstaben zwischen E und Z gibt. Gl√ºcklicherweise geht das eleganter, und zwar mit einem W√∂rterbuch.

### W√∂rterb√ºcher

<!--
\gloss{Dictionary}{Eine Sammlung von Schl√ºssel-Wert-Paaren, die eine schneller Suche erm√∂glichen.}{Programmierung}
-->

Ein Dictionary (deutsch: W√∂rterbuch) ist in der Programmierung eine Sammlung von Schl√ºssel-Wert-Paaren. √úber einen Schl√ºssel ‚Äì zum Beispiel eine Zahl ‚Äì greifen wir direkt auf den zugeh√∂rigen Wert zu, etwa einen Buchstaben. Stellt euch das wie ein Telefonbuch vor, bei dem ihr √ºber den Namen die Nummer herausfindet. Das ist ideal, wenn wir Bitfolgen zuerst in Dezimalzahlen umwandeln und dann schnell den passenden Buchstaben nachschlagen m√∂chten. Statt viele `if`/`elif`-Zweige zu schreiben, legen wir einmalig eine Nachschlagetabelle an. Das macht den Code k√ºrzer, √ºbersichtlicher und leichter erweiterbar.

F√ºr unsere Zeichendekodierung k√∂nnen wir ein Dictionary nutzen, das die Dezimalwerte 0‚Äì25 auf ‚ÄûA‚Äú‚Äì‚ÄûZ‚Äú abbildet und zum Beispiel 26 als Leerzeichen reserviert. Damit wird `decode_letter` deutlich kompakter und leichter zu pflegen.

```{python}
# Nachricht auf 5 Bits erweitern
MESSAGE_LENGTH = 5

# Dictionary mit 0‚Äì25 => A‚ÄìZ und 26 => Leerzeichen
SYMBOLS = {} # <1>
SYMBOLS[0] = "A" # <2>
SYMBOLS[1] = "B"
SYMBOLS[2] = "C"
SYMBOLS[3] = "D"
SYMBOLS[4] = "E"
...
SYMBOLS[25] = "Z"
SYMBOLS[26] = " "

def decode_letter(bits):
    decimal = int(bits, 2)
    return SYMBOLS.get(decimal, "?")
```

1. Mit geschweiften Klammern erzeugen wir ein leeres Dictionary.
2. Mit den eckigen Klammern k√∂nnen wir einem Schl√ºssel einen Wert zuweisen. Wenn es den Eintrag nicht gibt, wird er neu angelegt. Andernfalls wird er √ºberschrieben.

Wenn ihr sp√§ter weitere Zeichen (z. B. Punkt oder Komma) erg√§nzen wollt, k√∂nnt ihr sie einfach hinzuf√ºgen:

```{python}
#| code-line-numbers: false
SYMBOLS[27] = ","
SYMBOLS[28] = "."
```

Wie ihr an der Schreibweise von `SYMBOLS` erkennen k√∂nnt, handelt es sich um eine Konstante. Logisch, schlie√ülich ver√§ndert sich unser Codesystem f√ºr die Symbole im Verlauf des Programms nicht. Wir initialisieren ein leeres Dictionary mit geschweiften Klammern (Zeile 5). Die Zuweisung der Werte erfolgt dann √ºber die eckigen Klammern, wobei in den eckigen Klammern der Schl√ºssel (englisch: Key) steht und der Wert, den wir dem Schl√ºssel zuweisen m√∂chten, hinter dem Gleichheitszeichen folgt.

Prinzipiell k√∂nnten wir mit den eckigen Klammern auch Werte abfragen. Wenn wir zum Beispiel `SYMBOLS[0]` schreiben, erhalten wir den Wert "A" zur√ºck. Wenn wir einen Schl√ºssel abfragen, der nicht existiert, bekommen wir jedoch einen Fehler. Eine bessere M√∂glichkeit zum Abfragen von Werten bietet daher die `get()`-Methode. Sie liefert den Wert f√ºr den Schl√ºssel zur√ºck, den wir als erstes Argument √ºbergeben. Wenn dieser Schl√ºssel nicht existiert, bekommen wir den Wert `None` zur√ºck, was robuster ist, als wenn das Programm mit einem Fehler abbr√§che. Zudem k√∂nnen wir als zweites Argument einen Standardwert angeben, der zur√ºckgegeben wird, wenn der Schl√ºssel nicht existiert. In unserem Fall ist das ein Fragezeichen "?", das signalisiert, dass die Bitfolge keinem bekannten Buchstaben zugeordnet werden kann.

√úberpr√ºft euch selbst: Welcher Wert kommt bei folgendem Aufruf zur√ºck?: `SYMBOLS.get(5)`

```{python}
#| lst-cap: Der vollst√§ndige Code f√ºr die Texteingabe mit dem Infrarot-Abstandssensor.
#| lst-label: lst-text-full
#| code-fold: true
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2
import time

ipcon = IPConnection()
ipcon.connect('localhost', 4223)

ir = BrickletDistanceIRV2('2a7S', ipcon)
led = BrickletRGBLEDV2('ZEL', ipcon)

MESSAGE_LENGTH = 5 # Anzahl Bits pro Buchstabe
bits = ""
text = ""
last_distance = 0
receiving = False

# Dictionary mit 0‚Äì25 => A‚ÄìZ und 26 => Leerzeichen
SYMBOLS = {}
SYMBOLS[0] = "A"
SYMBOLS[1] = "B"
SYMBOLS[2] = "C"
SYMBOLS[3] = "D"
SYMBOLS[4] = "E"
SYMBOLS[5] = "F"
SYMBOLS[6] = "G"
SYMBOLS[7] = "H"
SYMBOLS[8] = "I"
SYMBOLS[9] = "J"
SYMBOLS[10] = "K"
SYMBOLS[11] = "L"
SYMBOLS[12] = "M"
SYMBOLS[13] = "N"
SYMBOLS[14] = "O"
SYMBOLS[15] = "P"
SYMBOLS[16] = "Q"
SYMBOLS[17] = "R"
SYMBOLS[18] = "S"
SYMBOLS[19] = "T"
SYMBOLS[20] = "U"
SYMBOLS[21] = "V"
SYMBOLS[22] = "W"
SYMBOLS[23] = "X"
SYMBOLS[24] = "Y"
SYMBOLS[25] = "Z"
SYMBOLS[26] = " "

def decode_letter(bits):
    decimal = int(bits, 2)
    return SYMBOLS.get(decimal, "?")

while True:
    distance = ir.get_distance()
    if last_distance != distance:

        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("1")
                bits += "1"
                receiving = False
            elif distance <= 170:
                print("0")
                bits += "0"
                receiving = False

            if len(bits) == MESSAGE_LENGTH: 
                print(f"Bits: {bits}")
                letter = decode_letter(bits)

                print(f"Buchstabe: {letter}")
                text += letter
                
                print(f"Text: {text}")
                bits = ""
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_03/3_4_coding_text.py).

Klont das Repository und √∂ffnet den Ordner in eurem Visual Studio Code, um es schnell ausf√ºhren zu k√∂nnen.
:::

## ASCII-Code {#sec-text-ascii-code .collapsable}

<!--
\gloss{ASCII-Code}{Ein standardisiertes Kodierungssystem f√ºr Texte, das jedem Zeichen eine eindeutige Bitfolge zuweist.}{Codesysteme}
\gloss{Codepage}{Eine Erweiterung eines Kodierungssystems, die zus√§tzliche Zeichen definiert.}{Codesysteme}
-->

Im vorigen Abschnitt haben wir zusammen √ºberlegt, wie wir Texte kodieren und als Bitfolge √ºber ein universelles Eingabeger√§t basierend auf einem IR-Abstandssensor √ºbertragen k√∂nnen. Ziemlich cool, findet ihr nicht? Dabei haben wir jedem Buchstaben eine eindeutige Bitfolge zugewiesen und sind letztlich auf unser eigenes 5-Bit-Kodierungssystem gekommen.

Weil eine der ersten Anwendungen mit dem Computer die Verarbeitung von Texten war, haben sich dar√ºber, wie man Texte kodieren kann, schon andere sehr schlaue Leute Gedanken gemacht. Das Ergebnis ist der ASCII-Code, den es seit den 1960er-Jahren gibt und der weltweit standardisiert ist.

Der ASCII-Code basiert auf sieben Bits und kann somit 128 verschiedene Symbole verwalten. Die vollst√§ndige Liste an Symbolen seht ihr in @fig-text-ascii-table. Die Tabelle enth√§lt f√ºnf Spalten, wobei die ersten vier den Zahlencode f√ºr das kodierte ASCII-Zeichen in unterschiedlichen Zahlensystemen angeben. Ganz links seht ihr die Dezimalzahl, daneben die Bin√§rdarstellung. Zus√§tzlich wird noch die Oktalzahl und die Hexadezimalschreibweise mit angezeigt. Oktal kennen wir bereits, was es mit Hexadezimal auf sich hat, lernen wir sp√§ter in @sec-images.

Wenn ihr genau hinseht, erkennt ihr, dass die Bin√§rzahl nicht aus 7, sondern aus 8 Bits besteht. Die erste Ziffer ganz links ist aber immer 0. Das liegt daran, dass Computer h√§ufig in 8-Bit-Einheiten ‚Äì also in Bytes ‚Äì denken. Auch der Speicher eines Computers ist so organisiert. Deshalb ben√∂tigt ein ASCII-Symbol in der Praxis statt sieben, acht Bits auf unserem Computer.

Was passiert mit dem vermeintlich ‚Äûverschwendeten‚Äú Bit? Damit k√∂nnten wir doch immerhin 128 weitere Symbole abbilden. Und das wird auch gemacht: Es gibt verschiedene lokale Erweiterungen des ASCII-Codes, die zus√§tzliche Zeichen definieren. F√ºr den deutschen Sprachraum etwa die Umlaute √§, √∂, √º und das scharfe S (√ü). F√ºr andere Sprachen gibt es √§hnliche Erweiterungen. Wir nennen diese Erweiterungen auch Codepages.

Die Codepage, die wir √ºblicherweise verwenden, nennt sich Windows-1252 (CP-1252) und ist eine Erweiterung des ASCII-Codes, die 256 Zeichen umfasst. Die ersten 128 Zeichen sind identisch mit dem ASCII-Code, die weiteren 128 enthalten zus√§tzliche Zeichen, die in westeurop√§ischen Sprachen ben√∂tigt werden.

![Die urspr√ºngliche ASCII-Codetabelle kodiert die Symbole als 7-Bit-Bin√§rzahlen](https://winf-hsos.github.io/university-docs/images/code_ascii_table.png){#fig-text-ascii-table .lightbox}

Der ASCII-Code ‚Äì das steht f√ºr American Standard Code for Information Interchange ‚Äì beinhaltet ein paar nette Eigenschaften. So k√∂nnen wir zum Beispiel einen Gro√übuchstaben in einen Kleinbuchstaben umwandeln, indem wir 32 zu seinem Dezimalcode addieren. Umgekehrt funktioniert das nat√ºrlich auch.

F√ºr unsere Texteingabe √ºber den IR-Abstandssensor bedeutet das: Wir ben√∂tigen √ºberhaupt keinen eigenen Code, sondern k√∂nnen einfach den ASCII-Code verwenden. Allerdings m√ºssen wir unsere Nachricht auf die L√§nge 7 erweitern, was mehr Aufwand bei der Eingabe macht. Daf√ºr verwenden wir einen Standard. Argument genug ‚Äì passen wir den Code an.

Die √Ñnderungen finden im Wesentlichen in der Funktion `decode_letter()` statt. Zudem √§ndern wir den Wert der Konstante `MESSAGE_LENGTH`:

```{python}
MESSAGE_LENGTH = 7 # Anzahl Bits pro Buchstabe

...

def decode_letter(bits):
    # Links eine 0 hinzuf√ºgen, damit es 8 Bits sind
    bits = "0" + bits

    # Bin√§rstring in Dezimalzahl und dann in ASCII-Zeichen umwandeln
    decimal = int(bits, 2)
    return chr(decimal)
```

Die `decode_letter()`-Funktion f√ºgt nun zun√§chst dem √ºbergebenen Bit-String, der aus 7 Bits bestehen sollte, eine 0 an den Anfang hinzu. Damit haben wir die 8 Bits aus der ASCII-Tabelle in @fig-text-ascii-table komplettiert. Anschlie√üend erfolgt ‚Äì wie zuvor ‚Äì die Konvertierung von bin√§r nach dezimal. Die wesentliche √Ñnderung steht in der Zeile darunter: Wir geben das Ergebnis der Funktion `chr()` zur√ºck, der wir den Dezimalwert unseres kodierten Symbols √ºbergeben. Brauchen wir also kein Dictionary mehr?

Ganz genau! Es gibt bereits eine Funktion, die die passenden Symbole f√ºr Codes liefern kann. Wenn wir in die offizielle Dokumentation der Funktion `chr()` schauen, dann steht dort:

> Return the string representing a character with the specified Unicode code point. For example, `chr(97)` returns the string 'a', while `chr(8364)` returns the string '‚Ç¨'. This is the inverse of `ord()`.

Die Funktion gibt also die Repr√§sentation des Codes als Zeichen zur√ºck. Aber was steht da? Mit dem angegebenen Unicode-Codepunkt? Was ist denn jetzt schon wieder Unicode? Wir haben doch gerade √ºber ASCII gesprochen.

### Unicode

<!--
\gloss{Unicode}{Ein internationaler Standard zur Kodierung von Texten, der eine gro√üe Anzahl von Zeichen aus verschiedenen Schriftsystemen umfasst.}{Codesysteme}
\gloss{UTF-8}{Eine Kodierungsmethode f√ºr Unicode-Zeichen, die variable Byte-L√§ngen verwendet.}{Codesysteme}
\gloss{Textdatei}{Eine Datei, die nur Textinformationen enth√§lt und keine Formatierungen oder Bin√§rdaten.}{Codesysteme}
\gloss{Codepunkt}{Eine eindeutige Nummer, die einem Zeichen in einem Zeichensatz zugeordnet ist.}{Codesysteme}
-->

Unicode ist ein internationaler Standard, der jedes Zeichen aus praktisch allen Schriftsystemen der Welt eindeutig beschreibt. W√§hrend ASCII nur 128 Symbole umfasst und damit vor allem die englische Sprache abdeckt, definiert Unicode einen gemeinsamen Zeichensatz mit weit √ºber einer Million m√∂glichen Codepunkten. Ein Codepunkt ist dabei eine Nummer, die einem Zeichen zugeordnet ist, zum Beispiel hat der Buchstabe ‚ÄûA‚Äú den Codepunkt U+0041 und das Eurozeichen ‚Äû‚Ç¨‚Äú den Codepunkt U+20AC.

Wichtig ist die Unterscheidung zwischen Zeichensatz und Kodierung: Unicode ist der Zeichensatz (die Menge aller Zeichen mit ihren Codepunkten), w√§hrend Formate wie UTF-8, UTF-16 oder UTF-32 beschreiben, wie diese Codepunkte als Bits und Bytes gespeichert oder √ºbertragen werden. UTF-8 ist heute die am weitesten verbreitete Kodierung im Web. Sie ist variabel lang und hat eine zentrale Eigenschaft: Die ersten 128 Codepunkte (0‚Äì127) entsprechen exakt dem ASCII-Code. Dadurch ist UTF-8 vollst√§ndig r√ºckw√§rtskompatibel zu ASCII. Eine reine ASCII-Datei ist zugleich g√ºltiges UTF-8, und Funktionen wie `chr()` und `ord()` in Python arbeiten mit Unicode-Codepunkten. Wenn ihr also `chr(65)` aufruft, erhaltet ihr ‚ÄûA‚Äú ‚Äì das passt sowohl in ASCII als auch in Unicode. F√ºr Zeichen au√üerhalb des ASCII-Bereichs verwendet UTF-8 mehr als ein Byte, bleibt aber weiterhin eindeutig und effizient.

UTF-8 verwendet je nach Zeichen unterschiedlich viele Bytes ‚Äì zwischen einem und vier. H√§ufige Zeichen wie die ASCII-Buchstaben brauchen nur 1 Byte. Ein ‚ÄûA‚Äú hat den Codepunkt U+0041 und wird in UTF-8 als 0x41 gespeichert. Zeichen mit Akzenten ben√∂tigen oft 2 Bytes, zum Beispiel ‚Äû√§‚Äú (U+00E4) als 0xC3 0xA4. Das Eurozeichen ‚Äû‚Ç¨‚Äú (U+20AC) braucht 3 Bytes: 0xE2 0x82 0xAC. Ein Emoji wie ‚Äûüòä‚Äú (U+1F60A) ben√∂tigt 4 Bytes: 0xF0 0x9F 0x98 0x8A.

Eine hilfreiche Analogie: Stellt euch UTF-8 wie einen Paketdienst mit vier Paketgr√∂√üen (S, M, L, XL) vor. Die meisten Sendungen (ASCII-Zeichen) passen in Gr√∂√üe S und sind damit sehr platzsparend. F√ºr seltenere oder komplexere Zeichen wird automatisch eine gr√∂√üere Paketgr√∂√üe gew√§hlt. Am ‚ÄûAdressaufkleber‚Äú ‚Äì den ersten Bits des ersten Bytes ‚Äì erkennt der Empf√§nger sofort, wie gro√ü das Paket ist und wie viele Folgebytes er einlesen muss. So bleibt Text kompakt, und reine ASCII-Texte sind automatisch g√ºltiges UTF-8.

Auf diese Weise wird sichergestellt, dass die h√§ufigsten Zeichen m√∂glichst wenig Speicherplatz ben√∂tigen, w√§hrend dennoch alle Zeichen der Welt eindeutig kodiert werden k√∂nnen. Das macht UTF-8 zur bevorzugten Wahl f√ºr die Textverarbeitung in modernen Anwendungen und im Web. Ihr k√∂nnt das √ºbrigens selbst einmal √ºberpr√ºfen: Erstellt zwei leere Textdateien und speichert beide als UTF-8. F√ºgt in die erste einen Text nur aus Buchstaben, Zahlen und Leerzeichen ein und in die zweite einen Text mit Sonderzeichen und Emojis. Dabei sollte in jeder Datei die gleiche Anzahl Zeichen stehen. Wie unterscheidet sich die Gr√∂√üe der Dateien im Dateiexplorer?

## LED-Dimmer 4.0 {#sec-text-led-dimmer .collapsable}

In @sec-numbers haben wir bereits drei Versionen eines LED-Dimmers gebaut. Eine letzte, vierte Variante kommt noch dazu: Lasst uns schauen, ob wir die Helligkeit mit dem Abstandssensor steuern k√∂nnen.

Das war wieder einmal eine rhetorische Frage, nat√ºrlich k√∂nnen wir das! Mit Computern l√§sst sich so gut wie jedes Problem l√∂sen, es geht nur um das Wie. Vielleicht habt ihr schon eine Idee, nachdem wir den Abstandssensor in diesem Kapitel schon intensiv kennengelernt haben.

Der Dimmer aus @sec-numbers l√§sst die LED in verschiedenen Stufen heller und dunkler leuchten. √úber den Drehknopf haben wir zun√§chst 1er-Schritte umgesetzt, was bedeutete, dass wir 256 Ticks des Drehknopfs ben√∂tigten, um die LED auf volle Helligkeit zu schalten. Sp√§ter haben wir dann eine Konstante `STEP` eingef√ºhrt, um die Schritte zu vergr√∂√üern, sodass nur noch eine Umdrehung notwendig war.

Wie l√§sst sich das auf den Abstandssensor √ºbertragen? Im Gegensatz zum Drehknopf, den wir beliebig lange in eine Richtung drehen k√∂nnen, hat der Abstandssensor einen festen Messbereich zwischen 4 und 30 cm. Das macht unsere Aufgabe einfacher, denn eine Transformation des Messbereichs in den Helligkeitsbereich der LED ist ausreichend. Wenn der Abstandssensor nun einen Wert von 4 cm misst, soll die LED auf 0 % Helligkeit dimmen, und bei 30 cm auf 100 % Helligkeit.

Nehmen wir an, der aktuelle Messwert ist in `distance` gespeichert, dann k√∂nnten wir den Helligkeitswert `brightness` so berechnen:

```{python}
#| code-line-numbers: false
brightness = (distance - 40) / (300 - 40) * 255
```

Vergewissern wir uns, dass die Formel richtig ist. Wenn `distance` den Wert 4 cm hat, dann sollte `brightness` 0 sein. Das passt, denn der erste Teil der Formel wird dann 0. Und 0 geteilt durch egal was ergibt 0. Wenn `distance = 300`, dann sollte `brightness` 255 sein. Das passt ebenfalls, denn der erste Teil der Formel wird dann 260 und 260 geteilt durch 260 ergibt 1. Multipliziert mit 255 ergibt 255. Sieht also gut aus.

Der folgende Code baut die Berechnungslogik in den LED-Dimmer aus @sec-numbers-led-dimmer-2 ein, der nur eine Farbe (Wei√ü) beherrscht. Wir k√∂nnten ihn aber genau wie in @sec-numbers-led-dimmer-3 um weitere Farben erweitern:

```{python}
#| lst-cap: Das fertige Programm f√ºr den LED-Dimmer mit Infrarot-Abstandssensor-Steuerung.

from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
ir = BrickletDistanceIRV2('2a7S', ipcon) 

led = BrickletRGBLEDV2('ZEL', ipcon)
led.set_rgb_value(0, 0, 0)  # Anfangszustand: aus

last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        last_distance = distance

        # Abstand (40‚Äì300 mm) auf LED-Helligkeit (0‚Äì255) abbilden
        brightness = int((distance - 40) / (300 - 40) * 255)
        led.set_rgb_value(brightness, brightness, brightness)  # LED-Helligkeit setzen
```

Je n√§her wir mit der Hand an den Sensor kommen, desto dunkler wird die LED ‚Äì und umgekehrt.

Damit schlie√üen wir dieses Kapitel ab. Wir haben gelernt, wie Computer Texte kodieren. Der Umweg √ºber unser eigenes Eingabeger√§t f√ºr Bin√§rcodes hat sich gelohnt: Eure Programmierskills sind gewachsen!

Im folgenden Kapitel besch√§ftigen wir uns mit Bildern, wie Computer sie sehen, und wie ein Bild auf den Bildschirm kommt.