# Texte {#sec-text}

## Zusammenfassung {.unnumbered .collapsable}

Im dritten Kapitel basteln wir ein universelles Eingabegerät für Informationen. Dafür verwenden wir einen Infrarot-Abstandssensor, mit dem wir Bits kodieren können. Mit diesen Bits können wir dann zum Beispiel Texte eingeben.

### Schritt für Schritt zum Ziel {.unnumbered}

Der Weg dahin führt über folgende Schritte:

| \# | Was? | Wo? |
|--|-------------------------------------------------------|----------------|
| 1 | Wir machen uns mit dem Infrarot-Abstandssensor vertraut. | @sec-text-experiment-setup |
| 2 | Wir bauen eine einfache Lichtschranke. | @sec-text-light-barrier |
| 3 | Wir erweitern die Lichtschranke zu einer Hinderniserkennung für Roboter. | @sec-text-obstacle-detection |
| 4 | Wir erschaffen ein universelles Eingabegerät für Binärcodes. | @sec-text-universal-input |
| 5 | Wir geben den Binärcodes eine Bedeutung und übermitteln Texte. | @sec-text-encode-text |
| 6 | Wir schauen auf ein verbreitetes Codesystem für Texte: ASCII. | @sec-text-ascii-code |
| 7 | Wir setzen den Infrarot-Abstandssensor in den LED-Dimmer ein. | @sec-text-led-dimmer |

### Begriffe und Konzepte {.unnumbered}

Dabei lernen wir neue Begriffe und Konzepte kennen.

<!-- CHAPTER_GLOSSARY_START -->
::: {.datatable-nosearch data-order='[[2,"asc"]]'}
| Begriff | Kategorie | Wo? |
|---|---|---|
| **Infrarot-Abstandssensor** | Hardware | @sec-text-light-barrier |
| **Else-Anweisung** | Programmieren | @sec-text-light-barrier |
| **Kodieren** | Codesysteme | @sec-text-universal-input |
| **Keyboard** | Hardware | @sec-text-universal-input |
| **Dekodieren** | Codesysteme | @sec-text-universal-input |
| **Bug** | Programmierung | @sec-text-encode-text |
| **Zeichenkette** | Programmierung | @sec-text-encode-text |
| **Dictionary** | Programmierung | @sec-text-encode-text |
| **ASCII-Code** | Codesysteme | @sec-text-encode-text |
| **Codepage** | Codesysteme | @sec-text-encode-text |
| **Unicode** | Codesysteme | @sec-text-encode-text |
| **UTF-8** | Codesysteme | @sec-text-encode-text |
| **Textdatei** | Codesysteme | @sec-text-encode-text |
| **Codepunkt** | Codesysteme | @sec-text-encode-text |
:::
<!-- CHAPTER_GLOSSARY_END -->

## Experimentaufbau {#sec-text-experiment-setup .collapsable}

### Hardware

Für dieses Kapitel benötigen wir erneut die LED ([RGB LED Bricklet 2.0](https://www.tinkerforge.com/de/shop/rgb-led-v2-bricklet.html)), ersetzen aber den Drehknopf aus @sec-numbers durch einen Infrarot-Abstandssensor ([Distance IR 4-30cm Bricklet 2.0](https://www.tinkerforge.com/de/shop/distance-ir-4-30cm-v2-bricklet.html)). Beide Geräte schließen wir an den Mikrocontroller ([Master Brick 3.2](https://www.tinkerforge.com/de/shop/master-brick.html)) an und fixieren sie auf einer Montageplatte. Wie in der Abbildung gezeigt, befestigen wir den Abstandssensor mit einem Metallwinkel so, dass er bündig mit der Platte ist und nach vorn zeigt.

Die vollständige Hardwareliste für dieses Kapitel sieht so aus:

-  1 x [Master Brick 3.2](https://www.tinkerforge.com/de/doc/Hardware/Bricks/Master_Brick.html)
-  1 x [RGB LED Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/RGB_LED_V2.html)
-  1 x [Distance IR 4-30cm Bricklet 2.0](https://www.tinkerforge.com/de/shop/distance-ir-4-30cm-v2-bricklet.html)
-  1 x [Montageplatte 22x10](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-plate-22x10.html)
-  2 x [Brickletkabel 15cm (7p-7p)](https://www.tinkerforge.com/de/shop/accessories/cable/bricklet-cable-15cm-7p-7p.html)
-  2 x [Befestigungskit 12 mm](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-kit-12mm.html)

::: {#fig-setup-rgb-led-ir layout="[[1], [1,1], [1,1]]"}
![Seitenansicht.](images/master_brick_with_led_and_ir_03.jpg){#fig-setup-rgb-led-ir .lightbox group="setup-rgb-ir"}

![Draufsicht.](images/master_brick_with_led_and_ir_02.jpg){#fig-setup-rgb-led-ir-b .lightbox group="setup-rgb-ir"}

![Nahaufnahme des IR-Abstandssensors.](images/master_brick_with_led_and_ir_04.jpg){#fig-setup-rgb-led-ir-c .lightbox group="setup-rgb-ir"}

![Seitenansicht, leicht schräg.](images/master_brick_with_led_and_ir_01.jpg){#fig-setup-rgb-led-ir-d .lightbox group="setup-rgb-ir"}

Einfaches Setup mit einem Mikrocontroller, LED und einem Infrarot-Abstandssensor.
:::

### Erste Schritte mit dem Abstandssensor {#sec-text-first-steps}

Wie bei der LED werfen wir zuerst einen Blick auf den neuen Abstandssensor im Brick Viewer. Schließt dazu euren Master Brick per USB an, startet den Brick Viewer und klickt auf Connect. Im Tab Setup sollten nun neben der LED auch der Abstandssensor erscheinen. Denkt daran: Dort findet ihr auch die UID eurer Geräte – die braucht ihr gleich im Programm.

![Nach erfolgreicher Verbindung erscheint der Infrarot-Entfernungsmesser in der Übersicht des Brick Viewers.](images/brick_viewer_connect_ir_sensor.png){#fig-brick-viewer-connect-ir-sensor .lightbox group="brick-viewer-ir"}

Wechselt in den Tab für den Abstandssensor, wo ihr ihn direkt testen könnt: Ihr seht die aktuelle Entfernung, die der Sensor misst, in Echtzeit oben in der Mitte (in Zentimetern). Darunter zeigt ein Kurvendiagramm den zeitlichen Verlauf. Bewegt eure Hand vor dem Sensor, um ein Gefühl für sein Verhalten zu bekommen. Was passiert, wenn ihr sehr nah vor dem Sensor seid? Und was, wenn ihr eure Hand weiter weg bewegt?

![Der Brick Viewer zeigt die aktuelle Entfernung im Zeitverlauf an.](images/brick_viewer_ir_sensor.png){#fig-brick-viewer-ir-sensor .lightbox group="brick-viewer-ir"}

## Lichtschranke {#sec-text-light-barrier .collapsable}

Einen \gloss{Infrarot-Abstandssensor}{Ein Sensor, der über Licht des Infrarotspektrums Abstände messen kann.}{Hardware} verwenden wir in der Praxis zur berührungslosen Messung des Abstands zu einem Objekt. Der Sensor sendet einen unsichtbaren Infrarotlichtstrahl aus und misst das Licht, das vom Objekt zurückgeworfen wird. Anhand der Intensität oder des Winkels des zurückkehrenden Lichts berechnet der Sensor die Entfernung. Diese Sensoren sind aus der Praxis nicht wegzudenken und kommen in vielen Szenarien zum Einsatz, zum Beispiel:

- Objekterkennung an einem Fließband
- Füllstandsmessung in Behältern
- Hinderniserkennung für Roboter, etwa bei Staubsaugerrobotern
- Positionierung von Werkstücken in Maschinen
- Einparkhilfe beim Auto

Letztlich lassen sich alle Anwendungsfälle auf zwei Fragen reduzieren:

1. Befindet sich ein Objekt in der Sicht des Sensors?
2. Wie weit ist ein Objekt vom Abstandssensor entfernt?

Wir starten mit der einfacheren der beiden Fragen: Befindet sich ein Objekt in der Sicht des Sensors? Das beschreibt im Kern die Funktion einer Lichtschranke.

Wie ihr beim Ausprobieren im Brick Viewer festgestellt habt, misst der Sensor Entfernungen zwischen 4 und 30 cm. Das bedeutet: Objekte außerhalb dieses Bereichs werden nicht erkannt – weder näher als 4 cm noch weiter als 30 cm. Eine Lichtschranke hat somit die Aufgabe zu prüfen, ob der IR-Abstandssensor einen Wert kleiner als 30 cm misst. Dann befindet sich ein Objekt in seiner Sichtlinie.

Verbinden wir uns mit dem Sensor und schreiben das notwendige Grundgerüst. Tragt eure UIDs ein und legt beide Bricklets an, Sensor und LED:

```{python}
#| lst-cap: Boilerplate-Code für IR-Abstandssensor und RGB-LED
#| lst-label: lst-text-ir-led-boilerplate
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2
import time

ipcon = IPConnection()
ipcon.connect('localhost', 4223)

ir = BrickletDistanceIRV2('2a7S', ipcon)     # <1>
led = BrickletRGBLEDV2('ZEL', ipcon)         # <2>
```

1. Tragt hier die UID eures IR-Sensors ein.
2. Tragt hier die UID eurer RGB-LED ein.

Der Sensor ist danach in der Variablen `ir` gespeichert. Über sie können wir [seine Funktionen](https://www.tinkerforge.com/de/doc/Software/Bricklets/DistanceIRV2_Bricklet_Python.html) aufrufen. Eine davon erlaubt uns das Auslesen des aktuell gemessenen Werts:

```{python}
#| code-line-numbers: false
distance = ir.get_distance()
```

Ein Blick in die Dokumentation verrät, dass der Rückgabewert in Millimetern angegeben wird. Ein Wert an der oberen Grenze (rund 300 mm) signalisiert typischerweise, dass sich kein Objekt innerhalb der Reichweite befindet. Damit wir besser testen können, lesen wir den Wert kontinuierlich aus und schreiben ihn auf die Konsole:

```{python}
#| code-line-numbers: false
while True:
    distance = ir.get_distance()
    print(f"Aktuelle Entfernung: {distance} mm")
```

Ihr werdet sehen, dass wir sehr viele Ausgaben erzeugen, weil in jedem Schleifendurchlauf der Wert ausgegeben wird – auch wenn er sich nicht verändert hat. Geben wir erneut nur die Veränderungen aus, um die Ausgaben zu reduzieren:

```{python}
#| code-line-numbers: false
last_distance = 0
while True:
    distance = ir.get_distance()
    if distance != last_distance:
        print(f"Aktuelle Entfernung: {distance} mm")
        last_distance = distance
```

Ihr erinnert euch: Dasselbe Prinzip haben wir in @sec-numbers-led-dimmer-2 verwendet, um nur bei einer Änderung des Drehknopfs eine Ausgabe zu erzeugen. Wir merken uns den letzten Wert und vergleichen ihn mit dem aktuell gemessenen. Ist er gleich, passiert nichts. Hat er sich verändert (`distance != last_distance`), geben wir den neuen Wert aus und aktualisieren den letzten Wert (`last_distance = distance`).

Wir sind unserem Etappenziel einer Lichtschranke schon sehr nah. Anhand der Ausgabe könnten wir entscheiden, ob ein Objekt in der Sicht des Sensors ist oder nicht. Das soll aber unser Programm automatisch erledigen. Dazu fügen wir eine weitere Bedingung mit einer `if`-Anweisung hinzu:

```{python}
#| code-line-numbers: false
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance < 300:
            print(f"Objekt erkannt: {distance} mm")
        else:
            print("Kein Objekt in Reichweite")
    
        last_distance = distance
```

Die neue `if`-Anweisung prüft, ob der Abstand kleiner als 300 mm ist. Dann befindet sich etwas vor dem Sensor. In diesem Fall geben wir einen entsprechenden Hinweis aus. Andernfalls kommt der Hinweis „Kein Objekt in Reichweite“. Diesen anderen Fall bildet der optionale `else`-Teil ab. Code hinter `else` wird immer dann ausgeführt, wenn keine der vorher definierten Bedingungen über `if` oder `elif` zutrifft.

Damit unsere Lichtschranke auch ohne Blick auf die Konsole funktioniert, bringen wir im letzten Schritt die LED ins Spiel. Sie soll rot aufleuchten, wenn ein Objekt erkannt wird. Die LED haben wir bereits kennengelernt, den Code können wir übernehmen:

```{python}
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance < 300:
            print(f"Objekt erkannt: {distance} mm")
            led.set_rgb_value(255, 0, 0) # <1>
        else:
            print("Kein Objekt in Reichweite")
            led.set_rgb_value(0, 0, 0)   # <2>
    
        last_distance = distance
```

1. Die LED leuchtet rot, wenn ein Objekt erkannt wird.
2. Die LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.

Probiert es aus – die Lichtschranke sollte funktionieren und Objekte innerhalb von 30 cm zuverlässig erkennen.

## Hinderniserkennung {#sec-text-obstacle-detection .collapsable}

Die Lichtschranke leuchtet immer rot, sobald ein Objekt erkannt wird. Dabei spielt die Entfernung keine Rolle. Lasst uns die Idee zu einer Hinderniserkennung für einen hypothetischen Staubsaugerroboter erweitern. Die LED soll anzeigen, ob sich ein Objekt bereits nahe am Roboter befindet oder ob es noch weit genug entfernt ist.

Nehmen wir an, dass Objekte, die 17 cm oder näher am Roboter sind, als Gefahr gelten. Alles, was zwischen 17 und 30 cm Abstand hält, sieht der Roboter nicht als bedrohlich an. Die drei Zustände wollen wir über die Farbe der LED abbilden:

- Gelb: Objekt in mittlerer Entfernung erkannt (17 cm < Abstand < 30 cm)
- Rot: Nahes Objekt erkannt (<= 17 cm)
- Aus: Kein Objekt vor dem Sensor (>= 30 cm)

Wir können dazu den Code der Lichtschranke erweitern:

```{python}
#| lst-cap: Der Code für die zweistufige Hinderniserkennung.
#| lst-label: lst-text-obstacle-detection
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance > 170 and distance < 300:
            led.set_rgb_value(255, 255, 0) # <1>
        elif distance <= 170:
            led.set_rgb_value(255, 0, 0)   # <2>
        else:
            led.set_rgb_value(0, 0, 0)     # <3>
    
        last_distance = distance
```

1. Die LED leuchtet gelb, wenn ein Objekt in mittlerer Entfernung erkannt wird.
2. Die LED leuchtet rot, wenn ein Objekt in naher Entfernung erkannt wird.
3. Die LED schaltet sich aus, wenn kein Objekt mehr erkannt wird.

Ihr erinnert euch an die additive Farbmischung aus @fig-additive-color-mixing? Gelb entsteht durch die Kombination von Rot und Grün. Wir verwenden hier eine `elif`-Anweisung, die eine weitere Bedingung prüft, wenn die vorherige `if`-Bedingung nicht zutrifft. So können wir mehrere Bedingungen hintereinander prüfen. Der letzte `else`-Teil fängt alle Fälle ab, in denen kein Objekt erkannt wurde.

<!-- 
\gloss{Else-Anweisung}{Ein optionaler Teil einer if-Anweisung, der ausgeführt wird, wenn keine der vorherigen Bedingungen zutrifft.}{Programmieren}
-->

Unser Staubsaugerroboter könnte den Code oben verwenden, um Hindernisse zu erkennen und bei zu großer Nähe ein Ausweichmanöver zu starten.

## Universelles Eingabegerät {#sec-text-universal-input .collapsable}

Eine andere Möglichkeit, den Abstandssensor und den Code aus @lst-text-obstacle-detection zu verwenden, ist ein Eingabegerät für Informationen in unseren Computer. Wie soll ein Abstandssensor als Eingabegerät für Informationen fungieren?

Wie wir später noch sehen werden, benötigen wir für die Darstellung von Informationen unterschiedliche Zustände – mindestens zwei. Genau das verkörpert das Bit, das wir in @sec-numbers-bit-and-bytes kennengelernt haben: Ein Bit hat zwei Zustände, an oder aus, 0 oder 1.

Was wäre, wenn wir die beiden Bereiche „nah“ und „weit genug entfernt“ nicht länger als Entfernungen interpretieren, sondern einfach als zwei Zustände? Sagen wir, der Bereich „weit genug entfernt“ steht für die 1 und der Bereich „nah“ für die 0. Dann könnten wir über die bewusste Platzierung eines soliden Gegenstands und anschließende Messung der Entfernung den Zustand eines Bits kodieren:

```{python}
last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        if distance > 170 and distance < 300:
            print("1")
        elif distance <= 170:
            print("0")
    
        last_distance = distance
```

Wenn ihr den Code ausführt, werdet ihr ein Problem erkennen: Platzieren wir unsere Hand nahe am Sensor, um eine 0 zu kodieren, gibt das Programm nacheinander sehr viele Nullen aus. Dasselbe gilt für Einsen. Dabei wollen wir mit einer Handgeste jeweils nur eine 1 oder 0 übermitteln, nicht eine ganze Reihe. Das liegt daran, dass sich unsere Hand ständig minimal bewegt – ein Millimeter reicht.

Wir müssen unser Programm so anpassen, dass es nicht erneut auf eine Änderung reagiert, solange die Hand nicht wieder weggenommen wurde. Das erkennen wir daran, dass der Sensor die maximale Entfernung von 30 cm misst. Erst wenn dieses Ereignis wieder auftritt, soll ein neuer Zustand kodiert werden.

Eine Lösung besteht darin, dass wir uns merken, ob unser Eingabegerät aktuell empfangsbereit ist oder nicht. Wir führen dafür die Variable `receiving` ein, die den Zustand unseres Eingabegeräts beschreibt. Ist sie `True`, ist das Gerät bereit, eine Eingabe zu empfangen. Ist sie `False`, ignorieren wir alle Änderungen, bis die Hand wieder weggenommen wurde.

```{python}
last_distance = 0
receiving = False
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        
        if receiving: # <1>
            if distance > 170 and distance < 300:
                print(f"1 bei {distance} mm")
                receiving = False
            elif distance <= 170:
                print(f"0 bei {distance} mm")
                receiving = False
        else: # <2>
            if distance >= 300:
                receiving = True # <3>
                print("Bereit für den nächsten Code")

        last_distance = distance
```

1. Nur im Empfangsmodus wird anhand der Entfernung ein Bit kodiert.
2. Wenn wir nicht im Empfangsmodus sind, prüfen wir, ob die Hand wieder weggenommen wurde (>= 30 cm).
3. Wenn die Hand weg ist, schalten wir wieder in den Empfangsmodus.

Das sieht schon gut aus. Probiert aber einmal aus, eure Hand sehr langsam von oben nach unten vor den Sensor zu bewegen, und zwar im nahen Bereich, sodass eigentlich eine 0 kodiert werden sollte. In manchen Fällen erkennt das Programm fälschlicherweise eine 1 statt der 0. Warum ist das so? Der Sensor hat bei der Messung eine leichte zeitliche Verzögerung. Wenn er aktuell 30 cm Abstand misst und wir unsere Hand langsam nach unten bewegen, misst der Sensor zunächst einen Abstand knapp unter 30 cm. Das Programm reagiert sofort und kodiert eine 1, obwohl wenig später der Sensorwert in den Bereich der 0 kommt (zum Beispiel 8 cm).

Wir können das Problem umgehen, indem wir einen kleinen Verzug einbauen, sobald ein Unterschied erkannt wurde. Nach diesem zeitlichen Verzug messen wir erneut, um sicherzugehen, die korrekte Position der Hand zu erwischen. So könnte das im Code aussehen:

```{python}
last_distance = 0
receiving = False
while True:
    distance = ir.get_distance()
    if last_distance != distance:

        # 100 ms warten und erneut messen
        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print(f"1 bei {distance} mm")
                receiving = False
            elif distance <= 170:
                print(f"0 bei {distance} mm")
                receiving = False
        else:
            if distance >= 300:
                receiving = True
                print("Bereit für den nächsten Code")

        last_distance = distance
```

Testet es jetzt: Unser Eingabegerät erkennt die Zustände 0 und 1 zuverlässig.

## Texte kodieren {#sec-text-encode-text .collapsable}

<!--
\gloss{Kodieren}{Das Umwandeln von Informationen in ein bestimmtes Format, das von einem Computer verarbeitet werden kann.}{Codesysteme}
-->

Können wir unser universelles Eingabegerät dazu verwenden, dem Computer Texte zu diktieren? Schließlich bedeutet „universell“, dass es für viele Zwecke einsetzbar ist. Und die Antwort lautet: ja! Wenn wir ein Gerät entwickeln, mit dem wir Bits kodieren können, können wir damit alles eingeben, was ein Computer darstellen kann.

In @sec-numbers haben wir gesehen, wie wir mit 8 Bits den Wert einer der drei Grundfarben im RGB-Code darstellen können. Wenn wir unser Eingabegerät einsetzen, um hintereinander 24 Bits zu übermitteln und diese als einen RGB-Farbcode zu interpretieren, könnten wir damit unsere LED in einer beliebigen Farbe aufleuchten lassen. Das versuchen wir später. Jetzt kümmern wir uns um eine ebenso wichtige Form der Information: Texte.

Texte bestehen allgemein aus Zeichen. Die meisten Zeichen in Texten sind Buchstaben, die wir in Klein- und Großbuchstaben unterscheiden. Dazu kommen Zahlen und Satzzeichen. Schaut auf das \gloss{Keyboard}{Tastatur}{Hardware} eures Computers – dort findet ihr die meisten Zeichen, die ihr für Texte benötigt.

### Wie viele Bits benötigen wir?

Genau wie bei den Farben, für die wir 24 Bits benötigen (jeweils 8 pro Farbe im RGB-Code), stellt sich bei Texten die Frage, wie viele Bits wir benötigen, um ein Zeichen darzustellen. Die Antwort hängt von der Anzahl der benötigten Zeichen ab.

Nähern wir uns von der anderen Seite und erweitern unseren Zeichencode Bit für Bit. Wir beginnen klein und fangen mit einem Bit an. Wenn wir Bits als Text interpretieren, wie viele Zeichen (oder Buchstaben) können wir dann mit einem einzigen Bit darstellen? Richtig: zwei!

```{python}
last_distance = 0
receiving = False
while True:
    distance = ir.get_distance()
    if last_distance != distance:

        # 100 ms warten und erneut messen
        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("B")
                receiving = False
            elif distance <= 170:
                print("A")
                receiving = False
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

Lasst das Programm laufen und legt eure Hand einmal nahe vor den Sensor, dann zweimal weiter weg und wieder nah. Das habt ihr gerade geschrieben: „ABBA“.

Neben der bekannten schwedischen Band lassen sich mit den Buchstaben A und B jedoch nicht viele andere Wörter bilden. Wir sind also gut beraten, mindestens ein zweites Bit hinzuzunehmen. Die Anzahl Bits, die wir für einen Buchstaben benötigen, erhöht sich damit auf zwei. Wie bilden wir das im Programm ab?

Am einfachsten, indem wir uns die Bits zunächst merken, sie also hintereinander in eine Zeichenkette schreiben. Sobald eine vorher definierte Länge einer Nachricht – hier zunächst zwei Bits – erreicht ist, dekodieren wir die Bitfolge und erhalten den passenden Buchstaben. Danach geht es wieder von vorn los und unsere Bit-Zeichenkette ist wieder leer.

<!--
\gloss{Dekodieren}{Das Umwandeln von kodierten Informationen zurück in ihr ursprüngliches Format.}{Codesysteme}
-->

```{python}
MESSAGE_LENGTH = 2 # <1>
bits = ""         # <2>
text = ""         # <3>
last_distance = 0
receiving = False

while True:
    distance = ir.get_distance()
    if last_distance != distance:

        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("1")
                bits += "1"  # <4>
                receiving = False
            elif distance <= 170:
                print("0")
                bits += "0"  # <5>
                receiving = False

            if len(bits) == MESSAGE_LENGTH:  # <6>
                print(f"Bits: {bits}")
                letter = decode_letter(bits) # <7>
                print(f"Buchstabe: {letter}")
                text += letter               # <8>
                print(f"Text: {text}")
                bits = ""                    # <9>
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

1. Die Länge einer Nachricht. So viele Bits müssen wir sammeln, bis wir die Nachricht entschlüsseln können.
2. Wir erstellen eine leere Zeichenkette `bits`, in der wir jedes empfangene Bit speichern.
3. `text` sammelt die dekodierten Buchstaben zu einem Text.
4. Wir merken uns das Bit, indem wir es an das Ende von `bits` hinzufügen – hier eine „1“.
5. Dasselbe für eine „0“.
6. Wenn wir genug Bits zusammen haben, dekodieren wir die Bitfolge.
7. `decode_letter(bits)` wandelt die Bitfolge in einen Buchstaben um. Die Funktion implementieren wir gleich.
8. Wir fügen den Buchstaben dem bisherigen Text an.
9. Danach setzen wir die Bit-Zeichenkette zurück.

Direkt nach dem Start wartet das Programm darauf, dass ihr eure Hand vor den Sensor haltet. Jede erkannte Änderung wird nach 100 Millisekunden noch einmal gemessen, um den Wert zu stabilisieren. Befinden wir uns im Empfangsmodus (`receiving` ist `True`), schreiben wir je nach Abstand eine „1“ (weit) oder „0“ (nah) ans Ende der Zeichenkette `bits` und schalten den Empfang vorübergehend aus. Sobald die Länge von `bits` der erwarteten `MESSAGE_LENGTH` entspricht, rufen wir `decode_letter(bits)` auf, erhalten den passenden Buchstaben, hängen ihn an `text` an und leeren `bits`. Erst wenn der Sensor wieder mindestens 30 cm misst, schalten wir den Empfang erneut frei, damit die nächste Eingabe beginnen kann.

Okay – probieren wir es aus. Unser Programm sammelt das erste Bit, dann das zweite und dann...

```
NameError: name 'decode_letter' is not defined
```

<!--
\gloss{Bug}{Ein Fehler in einem Programm, der dazu führt, dass es nicht wie erwartet funktioniert.}{Programmierung}
-->

Was ist das? Eine Fehlermeldung (wie sprechen auch von Bugs), die uns sagt: Die Funktion `decode_letter()` ist nicht definiert. Wir müssen sie also noch implementieren. Wir haben die Funktion zwar schon namentlich genannt, aber es gibt nirgends eine Definition. Das holen wir jetzt nach.

Erinnert euch an @sec-numbers-functions: Wir müssen wissen, was die Funktion tun soll, was sie dafür benötigt und was sie zurückgibt. Einen Namen haben wir bereits: `decode_letter`.

Die Funktion soll unsere \gloss{Zeichenkette}{Eine Abfolge von Zeichen}{Programmierung} voller Bits der Länge zwei, also so etwas wie "00", "01", "10" oder "11", in einen Buchstaben umwandeln. Die Eingabe ist `bits` und die Ausgabe ein Buchstabe, den diese Bitfolge kodiert. Unsere Funktion könnte so aussehen:

```{python}
def decode_letter(bits):
    if bits == "00":
        return "A"
    elif bits == "01":
        return "B"
    elif bits == "10":
        return "C"
    elif bits == "11":
        return "D"
```

Mit einem `if`-Statement, begleitet von drei `elif`-Zweigen, prüfen wir, welchem der möglichen Werte die Zeichenkette `bits` entspricht, und geben einen Buchstaben A, B, C oder D zurück. Da es mit zwei Bits insgesamt vier Möglichkeiten gibt, können wir auch nur vier Buchstaben damit abbilden. Wir erweitern das weiter unten, damit wir alle Buchstaben des Alphabets abdecken können.

| Bitfolge | Dezimalzahl | Buchstabe |
|----------|-------------|-----------|
| 00       | 0           | A         |
| 01       | 1           | B         |
| 10       | 2           | C         |
| 11       | 3           | D         |

: Unser aktuelles Codesystem für vier Buchstaben.

Die Tabelle fasst unser Codesystem zusammen. In der zweiten Spalte haben wir zur Bitfolge die entsprechende Dezimalzahl eingetragen. Erinnert euch: Das Binärsystem ist ein Stellenwertsystem wie jedes andere auch, nur eben zur Basis 2. Wie ihr die entsprechende Dezimalzahl zu einer Binärzahl errechnet, haben wir in @sec-numbers-binary-system gelernt.

Fügen wir die Funktion in unser Programm ein. Wichtig ist: Eine Funktion muss vor ihrer Verwendung definiert sein.

```{python}
#| code-fold: show
MESSAGE_LENGTH = 2
bits = ""
text = ""
last_distance = 0
receiving = False

def decode_letter(bits):
    if bits == "00":
        return "A"
    elif bits == "01":
        return "B"
    elif bits == "10":
        return "C"
    elif bits == "11":
        return "D"

while True:
    distance = ir.get_distance()
    if last_distance != distance:

        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("1")
                bits += "1"
                receiving = False
            elif distance <= 170:
                print("0")
                bits += "0"
                receiving = False

            if len(bits) == MESSAGE_LENGTH: 
                print(f"Bits: {bits}")
                letter = decode_letter(bits)
                print(f"Buchstabe: {letter}")
                text += letter
                print(f"Text: {text}")
                bits = ""
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

Cool, neben „ABBA“ können wir jetzt auch „ADAC“ schreiben. Wir wollen aber natürlich noch mehr, und bevor wir Bit für Bit hinzufügen, überlegen wir, wie viele Bits wir eigentlich benötigen.

Es gibt 26 Buchstaben im Alphabet, und vielleicht wollen wir auch ein Leerzeichen kodieren. Die Unterscheidung zwischen Klein- und Großbuchstaben lassen wir an dieser Stelle einmal weg – sie wäre aber für ein praxistaugliches Codesystem wichtig. Somit sind es 27 Zeichen, die wir kodieren wollen. Mit jedem zusätzlichen Bit verdoppeln wir unsere Möglichkeiten, das haben wir in @sec-numbers-bit-and-bytes gelernt. Rufen wir uns noch einmal die Tabelle in den Sinn, um zu erkennen, wie viele Bits wir benötigen.

| Anzahl Bits | Mögliche Kodierungen |
|-------------|----------------------|
| 1           | $2^1 = 2$            |
| 2           | $2^2 = 4$            |
| 3           | $2^3 = 8$            |
| 4           | $2^4 = 16$           |
| 5           | $2^5 = 32$           |
| 6           | $2^6 = 64$           |
| 7           | $2^7 = 128$          |
| 8           | $2^8 = 256$          |

: Anzahl Bits und mögliche Kodierungen.

Demnach reichen uns fünf Bits aus, denn damit können wir insgesamt 32 Kodierungen vornehmen. Wir hätten somit noch fünf freie Plätze, die wir vielleicht für Satzzeichen wie Punkt oder Komma verwenden.

Um das in unserem Programm zu reflektieren, müssen wir die Funktion `decode_letter` anpassen und gleichzeitig die Länge einer Nachricht auf 5 Bits erhöhen. Damit wir es etwas einfacher haben und die Buchstaben den Dezimalzahlen von 0–25 zuordnen können, wandeln wir die Bitfolge zuerst in eine Dezimalzahl um:

```{python}
def decode_letter(bits):
    
    # In Dezimalzahl umwandeln
    decimal = int(bits, 2) # <1>

    if decimal == 0:
        return "A"
    elif decimal == 1:
        return "B"
    elif decimal == 2:
        return "C"
    elif decimal == 3:
        return "D"
    elif decimal == 4:
        return "E"
    ...
    elif decimal == 25:
        return "Z"
    else:
        return "?"
```

1. Die Funktion `int` wandelt die Bitfolge in eine Dezimalzahl um. Der erste Parameter ist die Bitfolge als String, der zweite die Basis (hier 2 für Binärzahlen).

Für die Umwandlung der Bitfolge verwenden wir die Funktion `int()`, die uns später noch öfter begegnen wird. Sie wandelt Zeichenketten in ganze Zahlen um, und wenn wir als zweiten Parameter die Basis des Zahlensystems angeben, funktioniert das auch mit Binärzahlen.

Die Lösung funktioniert, allerdings ist sie nicht besonders elegant. Wir müssen für jeden Buchstaben einen eigenen `if`/`elif`-Zweig schreiben, was schnell unübersichtlich wird. Zudem wird unser Code extrem lang – im Codeblock oben deutet `...` bereits an, dass es noch viele weitere Buchstaben zwischen E und Z gibt. Glücklicherweise geht das eleganter, und zwar mit einem Wörterbuch.

### Wörterbücher

<!--
\gloss{Dictionary}{Eine Sammlung von Schlüssel-Wert-Paaren, die eine schneller Suche ermöglichen.}{Programmierung}
-->

Ein Dictionary (deutsch: Wörterbuch) ist in der Programmierung eine Sammlung von Schlüssel-Wert-Paaren. Über einen Schlüssel – zum Beispiel eine Zahl – greifen wir direkt auf den zugehörigen Wert zu, etwa einen Buchstaben. Stellt euch das wie ein Telefonbuch vor, bei dem ihr über den Namen die Nummer herausfindet. Das ist ideal, wenn wir Bitfolgen zuerst in Dezimalzahlen umwandeln und dann schnell den passenden Buchstaben nachschlagen möchten. Statt viele `if`/`elif`-Zweige zu schreiben, legen wir einmalig eine Nachschlagetabelle an. Das macht den Code kürzer, übersichtlicher und leichter erweiterbar.

Für unsere Zeichendekodierung können wir ein Dictionary nutzen, das die Dezimalwerte 0–25 auf „A“–„Z“ abbildet und zum Beispiel 26 als Leerzeichen reserviert. Damit wird `decode_letter` deutlich kompakter und leichter zu pflegen.

```{python}
# Nachricht auf 5 Bits erweitern
MESSAGE_LENGTH = 5

# Dictionary mit 0–25 => A–Z und 26 => Leerzeichen
SYMBOLS = {} # <1>
SYMBOLS[0] = "A" # <2>
SYMBOLS[1] = "B"
SYMBOLS[2] = "C"
SYMBOLS[3] = "D"
SYMBOLS[4] = "E"
...
SYMBOLS[25] = "Z"
SYMBOLS[26] = " "

def decode_letter(bits):
    decimal = int(bits, 2)
    return SYMBOLS.get(decimal, "?")
```

1. Mit geschweiften Klammern erzeugen wir ein leeres Dictionary.
2. Mit den eckigen Klammern können wir einem Schlüssel einen Wert zuweisen. Wenn es den Eintrag nicht gibt, wird er neu angelegt. Andernfalls wird er überschrieben.

Wenn ihr später weitere Zeichen (z. B. Punkt oder Komma) ergänzen wollt, könnt ihr sie einfach hinzufügen:

```{python}
#| code-line-numbers: false
SYMBOLS[27] = ","
SYMBOLS[28] = "."
```

Wie ihr an der Schreibweise von `SYMBOLS` erkennen könnt, handelt es sich um eine Konstante. Logisch, schließlich verändert sich unser Codesystem für die Symbole im Verlauf des Programms nicht. Wir initialisieren ein leeres Dictionary mit geschweiften Klammern (Zeile 5). Die Zuweisung der Werte erfolgt dann über die eckigen Klammern, wobei in den eckigen Klammern der Schlüssel (englisch: Key) steht und der Wert, den wir dem Schlüssel zuweisen möchten, hinter dem Gleichheitszeichen folgt.

Prinzipiell könnten wir mit den eckigen Klammern auch Werte abfragen. Wenn wir zum Beispiel `SYMBOLS[0]` schreiben, erhalten wir den Wert "A" zurück. Wenn wir einen Schlüssel abfragen, der nicht existiert, bekommen wir jedoch einen Fehler. Eine bessere Möglichkeit zum Abfragen von Werten bietet daher die `get()`-Methode. Sie liefert den Wert für den Schlüssel zurück, den wir als erstes Argument übergeben. Wenn dieser Schlüssel nicht existiert, bekommen wir den Wert `None` zurück, was robuster ist, als wenn das Programm mit einem Fehler abbräche. Zudem können wir als zweites Argument einen Standardwert angeben, der zurückgegeben wird, wenn der Schlüssel nicht existiert. In unserem Fall ist das ein Fragezeichen "?", das signalisiert, dass die Bitfolge keinem bekannten Buchstaben zugeordnet werden kann.

Überprüft euch selbst: Welcher Wert kommt bei folgendem Aufruf zurück?: `SYMBOLS.get(5)`

```{python}
#| lst-cap: Der vollständige Code für die Texteingabe mit dem Infrarot-Abstandssensor.
#| lst-label: lst-text-full
#| code-fold: true
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2
import time

ipcon = IPConnection()
ipcon.connect('localhost', 4223)

ir = BrickletDistanceIRV2('2a7S', ipcon)
led = BrickletRGBLEDV2('ZEL', ipcon)

MESSAGE_LENGTH = 5 # Anzahl Bits pro Buchstabe
bits = ""
text = ""
last_distance = 0
receiving = False

# Dictionary mit 0–25 => A–Z und 26 => Leerzeichen
SYMBOLS = {}
SYMBOLS[0] = "A"
SYMBOLS[1] = "B"
SYMBOLS[2] = "C"
SYMBOLS[3] = "D"
SYMBOLS[4] = "E"
SYMBOLS[5] = "F"
SYMBOLS[6] = "G"
SYMBOLS[7] = "H"
SYMBOLS[8] = "I"
SYMBOLS[9] = "J"
SYMBOLS[10] = "K"
SYMBOLS[11] = "L"
SYMBOLS[12] = "M"
SYMBOLS[13] = "N"
SYMBOLS[14] = "O"
SYMBOLS[15] = "P"
SYMBOLS[16] = "Q"
SYMBOLS[17] = "R"
SYMBOLS[18] = "S"
SYMBOLS[19] = "T"
SYMBOLS[20] = "U"
SYMBOLS[21] = "V"
SYMBOLS[22] = "W"
SYMBOLS[23] = "X"
SYMBOLS[24] = "Y"
SYMBOLS[25] = "Z"
SYMBOLS[26] = " "

def decode_letter(bits):
    decimal = int(bits, 2)
    return SYMBOLS.get(decimal, "?")

while True:
    distance = ir.get_distance()
    if last_distance != distance:

        time.sleep(0.1) 
        distance = ir.get_distance()
        
        if receiving:
            if distance > 170 and distance < 300:
                print("1")
                bits += "1"
                receiving = False
            elif distance <= 170:
                print("0")
                bits += "0"
                receiving = False

            if len(bits) == MESSAGE_LENGTH: 
                print(f"Bits: {bits}")
                letter = decode_letter(bits)

                print(f"Buchstabe: {letter}")
                text += letter
                
                print(f"Text: {text}")
                bits = ""
        else:
            if distance >= 300:
                receiving = True
            
        last_distance = distance
```

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_03/3_4_coding_text.py).

Klont das Repository und öffnet den Ordner in eurem Visual Studio Code, um es schnell ausführen zu können.
:::

## ASCII-Code {#sec-text-ascii-code .collapsable}

<!--
\gloss{ASCII-Code}{Ein standardisiertes Kodierungssystem für Texte, das jedem Zeichen eine eindeutige Bitfolge zuweist.}{Codesysteme}
\gloss{Codepage}{Eine Erweiterung eines Kodierungssystems, die zusätzliche Zeichen definiert.}{Codesysteme}
-->

Im vorigen Abschnitt haben wir zusammen überlegt, wie wir Texte kodieren und als Bitfolge über ein universelles Eingabegerät basierend auf einem IR-Abstandssensor übertragen können. Ziemlich cool, findet ihr nicht? Dabei haben wir jedem Buchstaben eine eindeutige Bitfolge zugewiesen und sind letztlich auf unser eigenes 5-Bit-Kodierungssystem gekommen.

Weil eine der ersten Anwendungen mit dem Computer die Verarbeitung von Texten war, haben sich darüber, wie man Texte kodieren kann, schon andere sehr schlaue Leute Gedanken gemacht. Das Ergebnis ist der ASCII-Code, den es seit den 1960er-Jahren gibt und der weltweit standardisiert ist.

Der ASCII-Code basiert auf sieben Bits und kann somit 128 verschiedene Symbole verwalten. Die vollständige Liste an Symbolen seht ihr in @fig-text-ascii-table. Die Tabelle enthält fünf Spalten, wobei die ersten vier den Zahlencode für das kodierte ASCII-Zeichen in unterschiedlichen Zahlensystemen angeben. Ganz links seht ihr die Dezimalzahl, daneben die Binärdarstellung. Zusätzlich wird noch die Oktalzahl und die Hexadezimalschreibweise mit angezeigt. Oktal kennen wir bereits, was es mit Hexadezimal auf sich hat, lernen wir später in @sec-images.

Wenn ihr genau hinseht, erkennt ihr, dass die Binärzahl nicht aus 7, sondern aus 8 Bits besteht. Die erste Ziffer ganz links ist aber immer 0. Das liegt daran, dass Computer häufig in 8-Bit-Einheiten – also in Bytes – denken. Auch der Speicher eines Computers ist so organisiert. Deshalb benötigt ein ASCII-Symbol in der Praxis statt sieben, acht Bits auf unserem Computer.

Was passiert mit dem vermeintlich „verschwendeten“ Bit? Damit könnten wir doch immerhin 128 weitere Symbole abbilden. Und das wird auch gemacht: Es gibt verschiedene lokale Erweiterungen des ASCII-Codes, die zusätzliche Zeichen definieren. Für den deutschen Sprachraum etwa die Umlaute ä, ö, ü und das scharfe S (ß). Für andere Sprachen gibt es ähnliche Erweiterungen. Wir nennen diese Erweiterungen auch Codepages.

Die Codepage, die wir üblicherweise verwenden, nennt sich Windows-1252 (CP-1252) und ist eine Erweiterung des ASCII-Codes, die 256 Zeichen umfasst. Die ersten 128 Zeichen sind identisch mit dem ASCII-Code, die weiteren 128 enthalten zusätzliche Zeichen, die in westeuropäischen Sprachen benötigt werden.

![Die ursprüngliche ASCII-Codetabelle kodiert die Symbole als 7-Bit-Binärzahlen](https://winf-hsos.github.io/university-docs/images/code_ascii_table.png){#fig-text-ascii-table .lightbox}

Der ASCII-Code – das steht für American Standard Code for Information Interchange – beinhaltet ein paar nette Eigenschaften. So können wir zum Beispiel einen Großbuchstaben in einen Kleinbuchstaben umwandeln, indem wir 32 zu seinem Dezimalcode addieren. Umgekehrt funktioniert das natürlich auch.

Für unsere Texteingabe über den IR-Abstandssensor bedeutet das: Wir benötigen überhaupt keinen eigenen Code, sondern können einfach den ASCII-Code verwenden. Allerdings müssen wir unsere Nachricht auf die Länge 7 erweitern, was mehr Aufwand bei der Eingabe macht. Dafür verwenden wir einen Standard. Argument genug – passen wir den Code an.

Die Änderungen finden im Wesentlichen in der Funktion `decode_letter()` statt. Zudem ändern wir den Wert der Konstante `MESSAGE_LENGTH`:

```{python}
MESSAGE_LENGTH = 7 # Anzahl Bits pro Buchstabe

...

def decode_letter(bits):
    # Links eine 0 hinzufügen, damit es 8 Bits sind
    bits = "0" + bits

    # Binärstring in Dezimalzahl und dann in ASCII-Zeichen umwandeln
    decimal = int(bits, 2)
    return chr(decimal)
```

Die `decode_letter()`-Funktion fügt nun zunächst dem übergebenen Bit-String, der aus 7 Bits bestehen sollte, eine 0 an den Anfang hinzu. Damit haben wir die 8 Bits aus der ASCII-Tabelle in @fig-text-ascii-table komplettiert. Anschließend erfolgt – wie zuvor – die Konvertierung von binär nach dezimal. Die wesentliche Änderung steht in der Zeile darunter: Wir geben das Ergebnis der Funktion `chr()` zurück, der wir den Dezimalwert unseres kodierten Symbols übergeben. Brauchen wir also kein Dictionary mehr?

Ganz genau! Es gibt bereits eine Funktion, die die passenden Symbole für Codes liefern kann. Wenn wir in die offizielle Dokumentation der Funktion `chr()` schauen, dann steht dort:

> Return the string representing a character with the specified Unicode code point. For example, `chr(97)` returns the string 'a', while `chr(8364)` returns the string '€'. This is the inverse of `ord()`.

Die Funktion gibt also die Repräsentation des Codes als Zeichen zurück. Aber was steht da? Mit dem angegebenen Unicode-Codepunkt? Was ist denn jetzt schon wieder Unicode? Wir haben doch gerade über ASCII gesprochen.

### Unicode

<!--
\gloss{Unicode}{Ein internationaler Standard zur Kodierung von Texten, der eine große Anzahl von Zeichen aus verschiedenen Schriftsystemen umfasst.}{Codesysteme}
\gloss{UTF-8}{Eine Kodierungsmethode für Unicode-Zeichen, die variable Byte-Längen verwendet.}{Codesysteme}
\gloss{Textdatei}{Eine Datei, die nur Textinformationen enthält und keine Formatierungen oder Binärdaten.}{Codesysteme}
\gloss{Codepunkt}{Eine eindeutige Nummer, die einem Zeichen in einem Zeichensatz zugeordnet ist.}{Codesysteme}
-->

Unicode ist ein internationaler Standard, der jedes Zeichen aus praktisch allen Schriftsystemen der Welt eindeutig beschreibt. Während ASCII nur 128 Symbole umfasst und damit vor allem die englische Sprache abdeckt, definiert Unicode einen gemeinsamen Zeichensatz mit weit über einer Million möglichen Codepunkten. Ein Codepunkt ist dabei eine Nummer, die einem Zeichen zugeordnet ist, zum Beispiel hat der Buchstabe „A“ den Codepunkt U+0041 und das Eurozeichen „€“ den Codepunkt U+20AC.

Wichtig ist die Unterscheidung zwischen Zeichensatz und Kodierung: Unicode ist der Zeichensatz (die Menge aller Zeichen mit ihren Codepunkten), während Formate wie UTF-8, UTF-16 oder UTF-32 beschreiben, wie diese Codepunkte als Bits und Bytes gespeichert oder übertragen werden. UTF-8 ist heute die am weitesten verbreitete Kodierung im Web. Sie ist variabel lang und hat eine zentrale Eigenschaft: Die ersten 128 Codepunkte (0–127) entsprechen exakt dem ASCII-Code. Dadurch ist UTF-8 vollständig rückwärtskompatibel zu ASCII. Eine reine ASCII-Datei ist zugleich gültiges UTF-8, und Funktionen wie `chr()` und `ord()` in Python arbeiten mit Unicode-Codepunkten. Wenn ihr also `chr(65)` aufruft, erhaltet ihr „A“ – das passt sowohl in ASCII als auch in Unicode. Für Zeichen außerhalb des ASCII-Bereichs verwendet UTF-8 mehr als ein Byte, bleibt aber weiterhin eindeutig und effizient.

UTF-8 verwendet je nach Zeichen unterschiedlich viele Bytes – zwischen einem und vier. Häufige Zeichen wie die ASCII-Buchstaben brauchen nur 1 Byte. Ein „A“ hat den Codepunkt U+0041 und wird in UTF-8 als 0x41 gespeichert. Zeichen mit Akzenten benötigen oft 2 Bytes, zum Beispiel „ä“ (U+00E4) als 0xC3 0xA4. Das Eurozeichen „€“ (U+20AC) braucht 3 Bytes: 0xE2 0x82 0xAC. Ein Emoji wie „😊“ (U+1F60A) benötigt 4 Bytes: 0xF0 0x9F 0x98 0x8A.

Eine hilfreiche Analogie: Stellt euch UTF-8 wie einen Paketdienst mit vier Paketgrößen (S, M, L, XL) vor. Die meisten Sendungen (ASCII-Zeichen) passen in Größe S und sind damit sehr platzsparend. Für seltenere oder komplexere Zeichen wird automatisch eine größere Paketgröße gewählt. Am „Adressaufkleber“ – den ersten Bits des ersten Bytes – erkennt der Empfänger sofort, wie groß das Paket ist und wie viele Folgebytes er einlesen muss. So bleibt Text kompakt, und reine ASCII-Texte sind automatisch gültiges UTF-8.

Auf diese Weise wird sichergestellt, dass die häufigsten Zeichen möglichst wenig Speicherplatz benötigen, während dennoch alle Zeichen der Welt eindeutig kodiert werden können. Das macht UTF-8 zur bevorzugten Wahl für die Textverarbeitung in modernen Anwendungen und im Web. Ihr könnt das übrigens selbst einmal überprüfen: Erstellt zwei leere Textdateien und speichert beide als UTF-8. Fügt in die erste einen Text nur aus Buchstaben, Zahlen und Leerzeichen ein und in die zweite einen Text mit Sonderzeichen und Emojis. Dabei sollte in jeder Datei die gleiche Anzahl Zeichen stehen. Wie unterscheidet sich die Größe der Dateien im Dateiexplorer?

## LED-Dimmer 4.0 {#sec-text-led-dimmer .collapsable}

In @sec-numbers haben wir bereits drei Versionen eines LED-Dimmers gebaut. Eine letzte, vierte Variante kommt noch dazu: Lasst uns schauen, ob wir die Helligkeit mit dem Abstandssensor steuern können.

Das war wieder einmal eine rhetorische Frage, natürlich können wir das! Mit Computern lässt sich so gut wie jedes Problem lösen, es geht nur um das Wie. Vielleicht habt ihr schon eine Idee, nachdem wir den Abstandssensor in diesem Kapitel schon intensiv kennengelernt haben.

Der Dimmer aus @sec-numbers lässt die LED in verschiedenen Stufen heller und dunkler leuchten. Über den Drehknopf haben wir zunächst 1er-Schritte umgesetzt, was bedeutete, dass wir 256 Ticks des Drehknopfs benötigten, um die LED auf volle Helligkeit zu schalten. Später haben wir dann eine Konstante `STEP` eingeführt, um die Schritte zu vergrößern, sodass nur noch eine Umdrehung notwendig war.

Wie lässt sich das auf den Abstandssensor übertragen? Im Gegensatz zum Drehknopf, den wir beliebig lange in eine Richtung drehen können, hat der Abstandssensor einen festen Messbereich zwischen 4 und 30 cm. Das macht unsere Aufgabe einfacher, denn eine Transformation des Messbereichs in den Helligkeitsbereich der LED ist ausreichend. Wenn der Abstandssensor nun einen Wert von 4 cm misst, soll die LED auf 0 % Helligkeit dimmen, und bei 30 cm auf 100 % Helligkeit.

Nehmen wir an, der aktuelle Messwert ist in `distance` gespeichert, dann könnten wir den Helligkeitswert `brightness` so berechnen:

```{python}
#| code-line-numbers: false
brightness = (distance - 40) / (300 - 40) * 255
```

Vergewissern wir uns, dass die Formel richtig ist. Wenn `distance` den Wert 4 cm hat, dann sollte `brightness` 0 sein. Das passt, denn der erste Teil der Formel wird dann 0. Und 0 geteilt durch egal was ergibt 0. Wenn `distance = 300`, dann sollte `brightness` 255 sein. Das passt ebenfalls, denn der erste Teil der Formel wird dann 260 und 260 geteilt durch 260 ergibt 1. Multipliziert mit 255 ergibt 255. Sieht also gut aus.

Der folgende Code baut die Berechnungslogik in den LED-Dimmer aus @sec-numbers-led-dimmer-2 ein, der nur eine Farbe (Weiß) beherrscht. Wir könnten ihn aber genau wie in @sec-numbers-led-dimmer-3 um weitere Farben erweitern:

```{python}
#| lst-cap: Das fertige Programm für den LED-Dimmer mit Infrarot-Abstandssensor-Steuerung.

from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_distance_ir_v2 import BrickletDistanceIRV2
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223)
ir = BrickletDistanceIRV2('2a7S', ipcon) 

led = BrickletRGBLEDV2('ZEL', ipcon)
led.set_rgb_value(0, 0, 0)  # Anfangszustand: aus

last_distance = 0
while True:
    distance = ir.get_distance()
    if last_distance != distance:
        last_distance = distance

        # Abstand (40–300 mm) auf LED-Helligkeit (0–255) abbilden
        brightness = int((distance - 40) / (300 - 40) * 255)
        led.set_rgb_value(brightness, brightness, brightness)  # LED-Helligkeit setzen
```

Je näher wir mit der Hand an den Sensor kommen, desto dunkler wird die LED – und umgekehrt.

Damit schließen wir dieses Kapitel ab. Wir haben gelernt, wie Computer Texte kodieren. Der Umweg über unser eigenes Eingabegerät für Binärcodes hat sich gelohnt: Eure Programmierskills sind gewachsen!

Im folgenden Kapitel beschäftigen wir uns mit Bildern, wie Computer sie sehen, und wie ein Bild auf den Bildschirm kommt.