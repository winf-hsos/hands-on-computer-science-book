# Farben {#sec-colors}

## Zusammenfassung {.unnumbered .collapsable}

Im ersten Kapitel steigen wir gleich voll ein und schreiben unser erstes Programm. Unser Ziel ist es, eine LED nacheinander in allen Farben des Regenbogens leuchten zu lassen.

Auf dem Weg dorthin gehen wir die folgenden Schritte.

| \# | Was? | Wo? |
|--|-------------------------------------------------------|----------------|
| 1 | Wir lernen, wie man eine LED aus einem Programm heraus steuert. | @sec-colors-control-led |
| 2 | Wir werfen einen kurzen Blick auf Farben und wie sie im Computer erzeugt werden. Dabei lernen wir den Unterschied zwischen additiver und subtraktiver Farbmischung kennen. | @sec-colors-light-and-colors |
| 3 | Wir programmieren eine pulsierende LED als erster Schritt in Richtung Regenbogenverlauf. | @sec-colors-pulsating-led |
| 4 | Wir lernen den Hue-Farbverlauf kennen, weil wir den f√ºr einen sch√∂nen Regenbogen ben√∂tigen. | @sec-colors-hue-circle |
| 5 | Endlich - wir schreiben das Programm f√ºr den Regenbogenverlauf. | @sec-colors-rainbow-led |

## Experimentaufbau {#sec-colors-experiment-setup .collapsable}

### Hardware

Bereit f√ºr euer erstes Hardware-Experiment? Perfekt! Ihr braucht daf√ºr eine LED ([RGB LED Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/RGB_LED_V2.html)) und einen Mikrocontroller ([Master Brick 3.2](https://www.tinkerforge.com/de/shop/master-brick.html)). Befestigt beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in @fig-setup-rgb-led gezeigt. Zwei Schrauben pro Ger√§t reichen v√∂llig. Denkt an die kleinen, wei√üen Unterlegscheiben aus Kunststoff. Sie sch√ºtzen eure Platinen vor Druckstellen.

Die volls√§ndige Hardwareliste f√ºr dieses Kapitel sieht so aus:

-  1 x [Master Brick 3.2](https://www.tinkerforge.com/de/doc/Hardware/Bricks/Master_Brick.html)
-  1 x [RGB LED Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/RGB_LED_V2.html)
-  1 x [Montageplatte 22x10](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-plate-22x10.html)
-  1 x [Brickletkabel 15cm (7p-7p)](https://www.tinkerforge.com/de/shop/accessories/cable/bricklet-cable-15cm-7p-7p.html)
-  1 x [Befestigungskit 12 mm](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-kit-12mm.html)

Neben der Hardware ben√∂tigt ihr auch die passende Software. Diese solltet ihr bereits installiert haben. Falls nicht, schaut im [Abschnitt zu den Voraussetzungen](preparation.qmd) vorbei. Dort ist alles genau beschrieben. Im Folgenden gehe ich davon aus, dass ihr alles am Laufen habt.

::: {#fig-setup-rgb-led layout="[[1], [1,1], [1,1]]"}
![Seitenansicht.](images/master_brick_with_led_01.jpg){#fig-setup-rgb-led-a .lightbox group="setup-rgb-led"}

![Nahaufnahme der LED.](images/master_brick_with_led_02.jpg){#fig-setup-rgb-led-b .lightbox group="setup-rgb-led"}

![Montageplatte mit allen Komponenten.](images/master_brick_with_led_03.jpg){#fig-setup-rgb-led-c .lightbox group="setup-rgb-led"}

![Untenansicht.](images/master_brick_with_led_04.jpg){#fig-setup-rgb-led-d .lightbox group="setup-rgb-led"}

![Ansicht der vier Steckpl√§tze.](images/master_brick_with_led_06.jpg){#fig-setup-rgb-led-e .lightbox group="setup-rgb-led"}

Einfaches Setup mit einem Mikrocontroller und einer LED.
:::

### Erste Schritte mit der LED

Im ersten Schritt wollen wir die LED und ihre Funktionen testen! Das geht ganz leicht mit dem \gloss{Brick Viewer}{Ein Werkzeug zum schnellen Testen der Tinkerforge-Bauteile}{Hardware}. Schlie√üt zuerst den Master Brick √ºber das USB-Kabel an euren Computer an und √∂ffnet den Brick Viewer. Klickt dann auf den Connect-Button.

![√úber den Connect-Button verbindet ihr den Brick Viewer mit dem angeschlossenen Master Brick.](images/brick_viewer_connect.png){#fig-brick-viewer-connect .lightbox fig-align="center" width="100%" group="brick-viewer"}

Wenn alles geklappt hat, zeigt euch der Brick Viewer alle angeschlossenen Ger√§te in Tabs an. Schaut euch @fig-brick-viewer-after-connect an ‚Äì so etwa sollte es aussehen.

![Der Brick Viewer, nachdem ihr mit dem Master Brick verbunden seid.](images/brick_viewer_after_connect.png){#fig-brick-viewer-after-connect .lightbox group="brick-viewer"}

Wechselt nun zum Tab der \gloss{RGB LED}{Eine LED, die in verschiedenen Farben leuchten kann.}{Hardware}. Hier k√∂nnt ihr auf unterschiedlichen Wegen die Farbe der LED einstellen. Mehr kann eine LED nicht!

Mit den drei Schiebereglern steuert ihr die einzelnen Farbkan√§le ‚Äì Rot, Gr√ºn, Blau. Der Wertebereich: 0 bis 255. Warum gerade diese Farben und diese Zahlen? Gute Frage. Die Antwort kommt weiter unten.

![Die Ansicht f√ºr die RGB LED im Brick Viewer, in der ihr alle Funktionen per Klick im Zugriff habt.](images/brick_viewer_rgb_led.png){#fig-brick-viewer-rgb-led .lightbox group="brick-viewer"}

Fazit: Der Brick Viewer ist ideal zum Ausprobieren. Aber wenn ihr echte Projekte umsetzen wollt, m√ºsst ihr programmieren lernen. Also los!

## Erstes Programm: LED ansteuern {#sec-colors-control-led .collapsable}

Wie verbinden wir uns √ºber ein Programm mit der LED und setzen ihre Farbe? Die Antwort darauf findet ihr im folgenden kurzen Codebeispiel.

```{python}
#| lst-label: lst-boilerplate-code
#| lst-cap: Der Boilerplate-Code f√ºr die Verbindung mit den Ger√§ten am Beispiel der RGB LED.

from tinkerforge.ip_connection import IPConnection # <1>
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2 # <2>

ipcon = IPConnection() # <3>
ipcon.connect("localhost", 4223) # <4>
led = BrickletRGBLEDV2("<YOUR_LED_UID>", ipcon) # <5>
```

1.  Hier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.
2.  Hier importieren wir ein weiteres Objekt, das wir zur Darstellung der LED als Python-Objekt ben√∂tigen.
3.  Die Verbindung erfolgt √ºber eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.
4.  Mit `connect` stellen wir eine Verbindung zum angeschlossenen Master Brick her.
5.  Schlie√ülich holen wir uns eine virtuelle Instanz des RGB LED Bricklets, indem wir die \gloss{UID}{*Unique Identifier*: Eindeutige Identifikation, hier eines Tinkerforge-Ger√§ts.}{Programmierung} nennen und sagen, welche Verbindung (`ipcon`) genutzt werden soll.

### Programme

Zun√§chst kl√§ren wir den Begriff \gloss{Programm}{Abfolge von Anweisungen, die ein Computer ausf√ºhrt}{Programmierung}. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausf√ºhrt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm sp√§ter daf√ºr zust√§ndig, mit der LED zu interagieren und sie in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns erm√∂glichen, dem Computer pr√§zise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut f√ºr Einsteiger eignet und gleichzeitig m√§chtig genug ist, um komplexe Aufgaben zu l√∂sen.

Wenn wir ein Programm ausf√ºhren, arbeitet der Computer die Anweisungen Schritt f√ºr Schritt von oben nach unten ab. Die Nummerierung der Zeilen verdeutlicht das sehr sch√∂n. Der Computer beginnt bei Zeile 1 und arbeitet die Befehle Zeile f√ºr Zeile bis nach unten ab.

Es gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir sp√§ter kennen.

### Boilerplate Code {#boilerplate-code}

Der Codeausschnitt in @lst-boilerplate-code wird uns im Verlauf dieses Buches immer wieder begegnen. Wir ben√∂tigen ihn, um uns am Anfang des Programms mit den Ger√§ten zu verbinden, die wir f√ºr unsere Anwendung ben√∂tigen. In der Informatik nennen wir solchen Code, den wir h√§ufig in der gleichen Form ben√∂tigen und fast eins zu eins kopieren k√∂nnen, auch \gloss{Boilerplate-Code}{Vorlagen-Code, der h√§ufig wiederverwendet wird und oft unver√§ndert bleibt.}{Programmierung}. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.

### Bibliotheken {#bibliotheken}

Beginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr √§hnliche Befehle, die mit dem Schl√ºsselwort `from` beginnen. Nach dem Schl√ºsselwort `from` folgt der Name einer \gloss{Bibliothek}{Eine B√ºndelung von fertigen Funktionen, Klassen oder Konstanten in einer Programmiersprache}{Programmierung}, aus der wir ein f√ºr unser Programm ben√∂tigtes Objekt importieren. Die Kombination der Schl√ºsselw√∂rter `from ... import` l√§sst sich also w√∂rtlich √ºbersetzen: "Aus der Bibliothek X importiere das Objekt Y".

Eine *Bibliothek*\index{Bibliothek} in einer Programmiersprache ist die B√ºndelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek k√∂nnt ihr euch vorstellen wie einen Werkzeugkasten: Sie enth√§lt fertige Werkzeuge (Funktionen und Klassen), damit ihr nicht alles von Grund auf selbst programmieren m√ºsst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Ger√§ten loslegen k√∂nnen. F√ºr jedes Ger√§t gibt es in der Tinkerforge-Bibliothek eine eigene Klasse, √ºber die wir auf die Funktionen jedes Ger√§ts zugreifen k√∂nnen.

### Klassen und Objekte

<!--
\gloss{Objekt}{Eine konkrete Instanz einer Klasse, die die definierten Eigenschaften und Funktionen nutzen kann.}{Programmierung}
-->

Mit `from ... import` importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit *importieren* ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge sp√§ter wirklich nutzen, steht auf einem anderen Blatt.

In dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ank√ºndigen. Die erste Klasse hei√üt `IPConnection`\index{`IPConnection`} und die zweite `BrickletRGBLEDV2`\index{`BrickletRGBLEDV2`}. Der Begriff \gloss{Klasse}{Baupl√§ne f√ºr Objekte, die bestimmte Eigenschaften und Funktionen definieren}{Programmierung} ist hier analog zum Begriff *Kategorie* zu verstehen. Wir k√∂nnen zu einer Klasse geh√∂rige Objekte erzeugen, und alle Objekte derselben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.

Stellt euch vor, ihr habt eine Klasse namens `Auto`. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa `fahren()`, `bremsen()` oder `tanken()`. Diese Dinge sollen f√ºr jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Wir k√∂nnen also sagen: "Mein Auto ist ein Objekt der Klasse `Auto`." Jedes `Auto` hat neben den Funktionen die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte f√ºr diese Eigenschaften haben.

Genauso verh√§lt es sich mit den Klassen, die Tinkerforge f√ºr uns bereitgestellt hat. Die Klasse `IPConnection` beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen k√∂nnen, und die Klasse `BrickletRGBLEDV2` beschreibt, wie wir mit der LED interagieren k√∂nnen. Wenn wir ein Objekt dieser Klasse erstellen, k√∂nnen wir alle Funktionen nutzen, die in der Klasse definiert sind. Eine LED muss nicht fahren oder bremsen wie ein Auto. Daf√ºr hat sie andere Funktionen, wie etwa `set_rgb_value()`, die uns erlaubt, die Farbe der LED zu √§ndern. Eine Eigenschaft jeder LED ist ihre UID, die eindeutig ist und uns hilft, sie im System zu identifizieren.

### Schl√ºsselw√∂rter

Soeben haben wir mit `from` und `import` unsere ersten beiden Schl√ºsselw√∂rter in Python kennengelernt! Aber was bedeutet das genau? Ein \gloss{Schl√ºsselwort}{Begriff, der in der Programmiersprache eine feste Bedeutung hat}{Programmierung}, das wir im Englischen auch *keyword* oder *reserved keyword* nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch h√§ufig Namen vergeben m√ºssen, etwa f√ºr Variablen oder Funktionen. Diese Namen d√ºrfen nicht wie ein Schl√ºsselwort lauten, ansonsten funktioniert unser Programm nicht wie gew√ºnscht. Welche Schl√ºsselw√∂rter es in Python gibt, k√∂nnt ihr [hier](https://docs.python.org/3/reference/lexical_analysis.html#keywords "Reservierte Schl√ºsselw√∂rter in Python") nachschauen.

Im Codeausschnitt oben laden wir zuerst das Objekt f√ºr die Verbindung zum angeschlossenen Mikrocontroller, die √ºber eine IP-Verbindung hergestellt wird. Was das genau ist? Sp√§ter mehr dazu. Zus√§tzlich zur `IPConnection` laden wir anschlie√üend noch die ben√∂tigten Klassen f√ºr die Ger√§te, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur die LED, in sp√§teren Experimenten werden es auch mal mehrere Ger√§te sein.

### Objekte erzeugen

In @lst-boilerplate-code in Zeile 4 erzeugen wir ein Objekt\index{Objekt} der Klasse `IPConnection`. Die fertige \gloss{Instanz}{Ein erzeugtes Objekt einer Klasse, die die definierten Eigenschaften und Funktionen nutzen kann}{Programmierung} ‚Äì so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde ‚Äì speichern wir auf einer *Variable* mit dem Namen `ipcon`. Diesen Namen haben wir uns selbst ausgedacht, damit wir sp√§ter darauf zugreifen k√∂nnen. Wir h√§tten auch einen anderen Namen w√§hlen k√∂nnen. Eine Variable ist also ein Platzhalter f√ºr einen Wert, den wir sp√§ter im Programm verwenden wollen. In diesem Fall ist `ipcon` der Platzhalter f√ºr die Verbindung zu unserem Mikrocontroller. Was eine Variable technisch ist, lernen wir sp√§ter noch genauer kennen.

### Methoden

√úber das Objekt `ipcon` k√∂nnen wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode `connect()`. Eine \gloss{Methode}{Funktion, die zu einem Objekt geh√∂rt}{Programmierung} ist eine Funktion, die zu einem Objekt geh√∂rt ‚Äì wie etwa `fahren()` oder `bremsen()` in unserem Auto-Beispiel.

Wir k√∂nnen Methoden aufrufen, um eine bestimmte Aktion auszuf√ºhren. In diesem case stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, √ºber den die Verbindung hergestellt werden soll. In unserem Fall ist das "localhost", was f√ºr die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standardm√§√üig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt `.` nach dem Objekt, gefolgt vom Namen der Methode und den Klammern `()`, in denen wir eventuell ben√∂tigte Parameter angeben.

Eine Methode ist letztlich eine Funktion, die zu einem Objekt geh√∂rt. Zu einem sp√§teren Zeitpunkt schreiben wir unsere eigenen Funktionen und lernen dann noch viel mehr dar√ºber.

### Ein Objekt f√ºr die LED

In Zeile 6 erzeugen wir schlie√ülich ein Objekt der Klasse `BrickletRGBLEDV2`. Dieses Objekt repr√§sentiert unsere LED und erm√∂glicht es uns, mit ihr zu interagieren. Wir nennen das Objekt `led`, was kurz und klar ist. Auch hier haben wir uns den Namen selbst ausgedacht, um sp√§ter darauf zugreifen zu k√∂nnen. Auch wenn wir grunds√§tzlich Variablennamen frei w√§hlen k√∂nnen, sollten sie immer so gew√§hlt werden, dass sie den Inhalt der Variable beschreiben. Das macht es sp√§ter einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten m√ºssen. Dazu geh√∂ren etwa, dass Variablennamen nicht mit einer Zahl beginnen d√ºrfen und keine Leerzeichen enthalten d√ºrfen. Eine ausf√ºhrliche Liste der Regeln findet ihr [hier](https://docs.python.org/3/reference/lexical_analysis.html#identifiers "Regeln f√ºr Variablennamen in Python").

### Zusammenfassung unseres ersten Programms

Damit haben wir unser erstes Programm von oben nach unten erl√§utert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:

|  |  |
|-------------------------|-----------------------------------------------|
| **Programme** | Abfolge von Anweisungen, die nacheinander ausgef√ºhrt werden. |
| **Boilerplate Code** | Standard-Code, den man immer wieder braucht. |
| **Importieren von Bibliotheken** | Sammlung von fertigen Code-Elementen. |
| **Schl√ºsselw√∂rter** | Reservierte Begriffe der Programmiersprache. |
| **Klassen und Objekte** | Kategorien und deren konkrete Instanzen. |
| **Methoden und Funktionen** | Funktionen, die zu einem Objekt geh√∂ren. |
| **Variablen** | Platzhalter f√ºr Werte. |

### Und jetzt?

Wir haben nun eine digitale Repr√§sentation unserer LED in Python. Wir k√∂nnen die LED jetzt zum Leuchten bringen, indem wir eine Methode der Klasse `BrickletRGBLEDV2`, die `set_rgb_value()` hei√üt, verwenden. Diese Methode erwartet drei Parameter: Rot, Gr√ºn und Blau. Mit diesen Parametern k√∂nnen wir die Farbe der LED einstellen.

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 255, 0) # <1>
```

1.  Setzt die LED auf gr√ºn. R = 0, G = 255, B = 0. Logisch, oder?

Moment mal ‚Ä¶ Wo steht hier eigentlich *gr√ºn*? Steht da gar nicht. Stattdessen drei Zahlen. Willkommen bei der \gloss{RGB-Farbkodierung}{Kodierung von Farben mittels Rot-, Gr√ºn- und Blauwerten}{Codesysteme}. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Gr√ºn, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Wei√ü. Nur Gr√ºn auf 255? Na klar: gr√ºn.

Aber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie √ºbersetzen wir die Welt in etwas, das ein Computer versteht?

Warum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit *drei* Zahlen? Warum √ºberhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?

Vorher m√ºssen wir aber kurz zur√ºck in die Schule.

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_01/1_2_first_program.py).
:::

## Licht und Farben {#sec-colors-light-and-colors .collapsable}

### Blick auf die Physik

<!-- \gloss{Elektromagnetische Strahlung}{Form von Energie, die sich in Wellen durch den Raum bewegt}{Physik} -->

Physik ist vielleicht schon eine Weile her. Erinnern wir uns dennoch kurz, was Licht ist und wie Farben damit zusammenh√§ngen. Licht ist elektromagnetische Strahlung. Das bedeutet, es handelt sich um gekoppelte Schwingungen elektrischer und magnetischer Felder, die sich mit Lichtgeschwindigkeit ausbreiten. Vereinfacht k√∂nnen wir uns Licht als Wellen vorstellen, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenl√§ngen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen √ºber Infrarotstrahlung bis hin zu R√∂ntgenstrahlen und Gammastrahlen reicht.

Bei Wellen unterscheiden wir zwischen der \gloss{Frequenz}{Wie oft etwas pro Sekunde passiert}{Physik} (wie oft die Welle pro Sekunde schwingt) und der \gloss{Wellenl√§nge}{der Abstand zwischen zwei aufeinanderfolgenden Wellen}{Physik} (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenl√§nge sind umgekehrt proportional: Je h√∂her die Frequenz, desto k√ºrzer die Wellenl√§nge und umgekehrt.

Frequenzen messen wir in \gloss{Hertz (Hz)}{Einheit f√ºr Frequenz (1/s)}{Physik}, wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenl√§ngen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) f√ºr violettes Licht und etwa 700 nm f√ºr rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abst√§nde zwischen den Wellenl√§ngen des sichtbaren Lichts sind also extrem klein.

Was bedeutet das nun f√ºr eine LED? Eine \gloss{LED}{Steht f√ºr *light emitting diode*}{Hardware} (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchflie√üt. Die Farbe des Lichts h√§ngt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenl√§ngen, was zu verschiedenen Farben f√ºhrt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenl√§nge von etwa 620‚Äì750 nm, w√§hrend eine gr√ºne LED Licht mit einer Wellenl√§nge von etwa 495‚Äì570 nm emittiert.

![Das elektromagnetische Spektrum, von dem das sichtbare Licht ein kleiner Teil ist. (Quelle: [Wikipedia](https://en.wikipedia.org/wiki/File:EM_Spectrum_Properties_edit.svg))](images/em_spectrum.png){#fig-em-spectrum fig-align="center" width="100%"}

Die RGB LED besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer gr√ºnen und einer blauen. Jede dieser LEDs kann unabh√§ngig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Stromst√§rke bedeutet mehr Intensit√§t der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Gr√ºn und Blau in unterschiedlichen Intensit√§ten k√∂nnen wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensit√§t leuchten lassen, erhalten wir Wei√ü. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LEDs sind dann alle aus.

Jetzt wissen wir, warum die Methode `set_rgb_value()` drei \gloss{Parameter}{Werte, die an eine Funktion √ºbergeben werden}{Programmierung} erwartet: Rot, Gr√ºn und Blau. Diese Parameter sind die Intensit√§ten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 k√∂nnen wir jede Farbe im sichtbaren Spektrum erzeugen.

Ein Farbwert im Computer besteht also aus drei Zahlen besteht, die jeweils zwischen 0 und 255 liegen. Das gilt f√ºr unsere LED, aber auch f√ºr Pixel in TVs, Smartphones, digitalen Fotos oder Monitoren. Wie kommt es aber zu der merkw√ºrdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grunds√§tzlich Werte speichert und wie dieser Speicher organisiert ist. Genaueres erfahren wir schon in @sec-numbers.

Klingt alles theoretisch sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus und mischen zwei Farben mit voller Intensit√§t!

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 255, 0)
```

Was macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!

### Additive Farbmischung

<!-- \gloss{Additive Farbmischung}{Mischen von Farben durch Hinzuf√ºgen von Licht}{Physik} -->

Ihr solltet alle eure LEDs in Gelb aufleuchten sehen. In der additiven Farbmischung* mischen wir Rot und Gr√ºn und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Gr√ºn, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensit√§t leuchten lassen, erhalten wir eine neue Farbe, die stets heller ist als die Ursprungsfarben. Wir f√ºgen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensit√§t mischen, erhalten wir schlie√ülich Wei√ü.

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 255, 255)
```

Am anderen Ende des Spektrums erzeugen drei Nullen die Farbe Schwarz:

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 0, 0)
```

### Subtraktive Farbmischung

<!-- \gloss{Subtraktive Farbmischung}{Mischen von Farben durch Entfernen von Licht}{Physik} -->

Ihr k√∂nnt euch merken, dass wir im Kontext von Computern oft von *additiver Farbmischung* sprechen, weil Bildschirme Licht erzeugen. Durch das Mischen der drei Farbkan√§le entstehen neue Farben gem√§√ü der additiven Farbmischung, also stets heller als ihre Grundfarben. Daneben gibt es aber noch die subtraktive Farbmischung. Sie funktioniert anders, n√§mlich genau umgekehrt. Statt beim Mischen Licht hinzuzuf√ºgen, nehmen wir Licht weg.

Erinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbkasten die Mischung aus Rot und Gr√ºn ergeben? Sicher nicht Gelb ‚Äì eher Braun. Eine dunklere Farbe. Das liegt daran, dass wir es hier nicht mit additiver, sondern mit subtraktiver Farbmischung zu tun haben. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht *absorbieren* und *reflektieren*. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtspektrums werden nicht mehr reflektiert, sondern absorbiert und sind damit nicht mehr sichtbar. Das Ergebnis einer Mischung zweier Farben ergibt in der subtraktiven Farbmischung also stets eine dunklere Farbe ‚Äì genau umgekehrt zur additiven Farbmischung.

Was passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, n√§mlich W√§rme. Deshalb wird eine schwarze Oberfl√§che auch besonders hei√ü, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspektrum und wandelt es in W√§rme um. Dagegen wirken wei√üe Oberfl√§chen fast wie Klimaanlagen. Es ist kein Zufall, dass wir in sonnigen Erdteilen viele wei√üe Fassaden sehen.

Wenn wir alle Farben mischen, ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zur√ºck. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen *kombinieren*, um neue Farben zu erhalten.

::: {#fig-color-mixing layout="[[1,1]]"}
![Additive Farbmischung](images/additive_color_mixing.png){#fig-additive-color-mixing .lightbox}

![Subtraktive Farbmischung](images/subtractive_color_mixing.png){#fig-subtractive-color-mixing .lightbox}

Additive und subtraktive Farbmischung.
:::

In @fig-color-mixing sehen wir die beiden Farbmischungsarten im Vergleich. In @fig-subtractive-color-mixing sehen wir die drei Grundfarben, die wir bei der subtraktiven Variante ben√∂tigen, um daraus alle weiteren Farben zu erhalten. Das sind Cyan, Magenta und Gelb. Im Englischen ist die Abk√ºrzung CMY, wo das "Y" f√ºr *Yellow* steht. In der additiven Farbmischung sind es, wie oben schon gesehen, Rot, Gr√ºn und Blau. Wenn ihr @fig-additive-color-mixing betrachtet, dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der additiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?

In der additiven Farbmischung entsteht Gelb durch das Mischen von Rot und Gr√ºn, wobei Blau fehlt. Im Umkehrschluss bedeutet das: Gelbes Licht enth√§lt keine blaue Komponente, es reflektiert also kein Blau. In der subtraktiven Farbmischung (wie beim Farbkasten) wird Gelb erzeugt, indem Blau aus wei√üem Licht herausgefiltert wird ‚Äì Gelb reflektiert also kein Blau, sondern absorbiert es. Gelb kann also auch als Blaufilter gesehen werden. Das erkl√§rt, warum ein gelber Gegenstand unter blauem Licht dunkel erscheint: Er kann das blaue Licht nicht reflektieren.

Jetzt k√∂nnen wir auch erkl√§ren, warum Farbdrucker vier unterschiedliche Kartuschen ben√∂tigen (@fig-toner-cmy). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb k√∂nnen wir jede beliebige Farbe mischen. Zus√§tzlich haben Drucker eine Kartusche f√ºr Schwarz, um erstens ein sattes Schwarz drucken zu k√∂nnen und zweitens die Farbkartuschen zu schonen. Denn schlie√ülich m√ºssen alle drei Farben gemischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen Schwarz enthalten (oder sogar ausschlie√ülich), ist eine schwarze Kartusche einfach effizienter. Die Farbe Schwarz wird bei Druckerkartuschen als Key bezeichnet und mit "K" abgek√ºrzt. Wir sprechen daher auch von \gloss{CMYK}{Abk√ºrzung der Grundfarben im Farbdruck}{Hardware}.

![Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.](images/toner-cmy.png){#fig-toner-cmy .lightbox}

Farben spielen eine so wichtige Rolle bei der Arbeit mit Computern. Deshalb lohnt es sich, ein wenig √ºber die Hintergr√ºnde von Farben und deren Mischung zu verstehen. Wir werden sp√§ter noch lernen, wie Bildschirme Farben darstellen. Sp√§testens dann wird uns das Thema der Farbmischung wieder begegnen.

Ab jetzt wollen wir weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, praxisnah verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED √ºber die Methode `set_rgb_value()` ver√§ndern k√∂nnen, wenn wir wissen, welcher RGB-Code unsere gew√ºnschte Farbe repr√§sentiert. Da wir jetzt mehr √ºber die Farbmischung wissen, k√∂nnen wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 0, 255)
```

Gem√§√ü der Theorie der additiven Farbmischung (@fig-additive-color-mixing) m√ºssten Rot und Blau Magenta ergeben. Probiert es aus!

## Pulsierende LED {#sec-colors-pulsating-led .collapsable}

Das deklarierte Ziel unseres ersten Experiments ist es, einen Regenbogenfarbverlauf zu erzeugen. Dazu m√ºssen wir die Farbe der LED kontinuierlich √§ndern, sodass sie von Rot √ºber Gelb, Gr√ºn, Cyan, Blau und Violett wieder zur√ºck zu Rot wechselt.

Lasst uns aber m√∂glichst einfach anfangen und uns dem Regenbogen schrittweise ann√§hern. Zun√§chst w√§re es sch√∂n, wenn wir die LED einfach Rot pulsieren lassen k√∂nnten. Dazu m√ºssen wir n√§mlich nur den Rot-Kanal und nicht alle drei Kan√§le der LED ansteuern. Gleichzeitig lernen wir schon hier ein Problem kennen, das uns in der Programmierung h√§ufig begegnet und f√ºr das es eine elegante L√∂sung gibt.

### Abz√§hlbare Wiederholungen

Was bedeutet es, die LED pulsieren zu lassen? Und was m√ºssen wir daf√ºr tun? Pulsieren bedeutet, dass die LED √ºber einen kurzen Zeitraum immer heller wird, kurz in der vollen Helligkeit verweilt und dann sofort wieder kontinuierlich dunkler wird. Sobald sie schwarz ist, f√§ngt der Zyklus von vorne an.

Den Ausdruck *immer heller werden* k√∂nnen wir bezogen auf die LED so √ºbersetzen, dass wir den Anteil des Rot-Kanals schrittweise erh√∂hen. Wenn die LED zu Beginn aus ist, also alle Kan√§le auf 0 stehen, k√∂nnen wir den Rot-Kanal von 0 auf 255 erh√∂hen und so die LED immer heller in Rot aufleuchten lassen.

Wir beginnen also mit einer schwarzen LED:

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 0, 0)
```

Anschlie√üend setzen wir den Wert f√ºr Rot auf 1:

```{python}
#| code-line-numbers: false
led.set_rgb_value(1, 0, 0)
```

Und erh√∂hen ihn schrittweise:

```{python}
#| code-line-numbers: false
led.set_rgb_value(2, 0, 0)
led.set_rgb_value(3, 0, 0)
led.set_rgb_value(4, 0, 0)
# ...
```

Wenn wir nach diesem Muster fortfahren, h√§tten wir bis zum vollen Rot 255 Zeilen Code geschrieben, eine Zeile f√ºr jeden Erh√∂hungsschritt. Und anschlie√üend das Gleiche nochmal r√ºckw√§rts, damit wir wieder zu Schwarz kommen. Mit 510 Zeilen Code h√§tten wir dann einen Pulsierungszyklus durchlaufen. Wollen wir die LED √∂fter pulsieren lassen, vervielfacht sich unser Code entsprechend. Das kann nicht die L√∂sung f√ºr ein so einfaches Problem sein.

Und tats√§chlich gibt es in der Programmierung eine bessere M√∂glichkeit, um sich wiederholende Abl√§ufe abzubilden: die \gloss{Schleife}{Wiederholung von Programmcode}{Programmierung}. In einem Fall, bei dem wir genau wissen, wie oft wir etwas wiederholen wollen, bietet sich eine \gloss{Z√§hlerschleife}{Wiederholung mit Z√§hler}{Programmierung} an:

```{python}
#| code-line-numbers: false
for r in range(256):
    led.set_rgb_value(r, 0, 0)
```

Voil√†! Unsere 510 Zeilen Code k√∂nnen wir mit einer Schleife auf zwei Zeilen reduzieren! Dazu m√ºssen wir im Kopf der Schleife (`for ... in ...`) festlegen, wie oft der einger√ºckte Codeblock nach dem Doppelpunkt ausgef√ºhrt werden soll. In Python funktioniert das √ºber die Angabe einer Folge, f√ºr die jedes Element einmal durchlaufen wird. Das aktuelle Element ist in der Schleife als `r` verf√ºgbar. Und `r` nimmt nacheinander jeden Wert der Folge an, die nach dem Schl√ºsselwort `in` folgt. Diese Folge erzeugt hier die Funktion `range(256)`, die ‚Äì wie der Name preisgibt ‚Äì eine Zahlenfolge von 0 bis zum angegebenen Wert minus eins erzeugt. In unserem Fall also von 0 bis 255.

Um das besser nachvollziehen zu k√∂nnen, geben wir den Wert f√ºr `r` einfach mal aus:

```{python}
#| code-line-numbers: false
for r in range(256):
    led.set_rgb_value(r, 0, 0)
    print(r) # <1> 
```

1.  Mit `print()` geben wir einen Wert auf der Konsole aus.

Jetzt wird es deutlich: Mit jedem Durchlauf der Schleife wird ein neuer Wert f√ºr `r` gesetzt und ausgegeben. Und zwar jeweils um eins erh√∂ht. Die Funktion `range(256)` erzeugt genau gesagt eine sortierte Reihe mit den Zahlen von 0 bis 255. Das sieht in Python dann so aus:

```{python}
#| eval: true
#| code-line-numbers: false
list_of_numbers = range(256)
print(list(list_of_numbers)) # <1>
```

1.  Mit der `list()`-Funktion wandeln wir die von `range()` erzeugte Folge in eine Liste um, die wir dann ausgeben k√∂nnen.

R√ºckw√§rts erreichen wir das gleiche Ergebnis mit einer weiteren Schleife, deren Folge wir umkehren, sodass sie von 255 bis 0 geht:

```{python}
#| code-line-numbers: false
for r in range(255, -1, -1):
    led.set_rgb_value(r, 0, 0)
```

<!--
\gloss{Argument}{Platzhalter f√ºr √ºbergebene Werte einer Funktion}{Programmierung} 
-->

Warum hat `range()` auf einmal drei Argumente? Ganz einfach: Standardm√§√üig erstellt die Funktion eine Folge von 0 bis zur angegebenen Zahl minus eins. Wir k√∂nnen die Folge aber beeinflussen, indem wir einen Startwert und einen Schrittwert angeben. In unserem Fall oben beginnen wir bei 255 (erster Parameter) und gehen bis -1 (zweiter Parameter), wobei wir in jedem Schritt um -1 verringern (dritter Parameter). Warum z√§hlen wir bis -1, wo wir doch eigentlich die 0 als kleinste Zahl ben√∂tigen? Das liegt daran, dass die Folge von `range()` immer bis zum zweiten Parameter minus eins geht. Wenn wir also 0 als kleinste Zahl ben√∂tigen, m√ºssen wir bis -1 z√§hlen.

Fassen wir unsere Erkenntnis zusammen und lassen die LED pulsieren:

```{python}
import time

# Increase red step by step
for r in range(256):
    led.set_rgb_value(r, 0, 0)
    time.sleep(0.001)

# Stay at full brightness for a bit
time.sleep(0.25)

# Decrease red step by step
for r in range(255, -1, -1):
    led.set_rgb_value(r, 0, 0)
    time.sleep(0.001)
```

Soweit bekannt? Fast ‚Äì eine kleine Neuerung habe ich gerade eingebaut, n√§mlich die Funktion `time.sleep()`. Diese Funktion pausiert das Programm f√ºr die angegebene Zeit in Sekunden. In unserem Fall pausieren wir f√ºr 0,001 Sekunden, also 1 Millisekunde. Dadurch wird die LED langsamer heller und dunkler, was den Puls-Effekt verst√§rkt. Ohne diese Pause w√ºrde die LED so schnell aufleuchten, dass es f√ºr das menschliche Auge nicht mehr wahrnehmbar w√§re. Tats√§chlich w√ºrden wir auch die Hardware √ºberfordern, weil die LED gar nicht so schnell die Farbe wechseln kann. Das Programm w√ºrde abst√ºrzen.

Am H√∂hepunkt warten wir erneut ‚Äì dieses Mal eine Viertelsekunde ‚Äì, bevor wir die LED langsam ausgehen lassen und den Rotanteil schrittweise wieder auf Null setzen. Dann endet unser Programm, leider viel zu fr√ºh. Die LED soll doch eigentlich weiter pulsieren, bis ... ja, bis wann √ºberhaupt?

### Bedingte Wiederholungen

<!-- \gloss{While-Schleife}{Wiederholung von Programmcode, solange eine Bedingung erf√ºllt ist}{Programmierung} -->

Beim L√∂sen von Problemen sto√üen wir h√§ufig auf Situationen, in denen wir bestimmte Schritte wiederholt ausf√ºhren m√∂chten, aber nur unter bestimmten Bedingungen. Hier kommen bedingte Wiederholungen ins Spiel, die es uns erm√∂glichen, Schleifen zu erstellen, die nur dann fortgesetzt werden, wenn eine bestimmte Bedingung noch erf√ºllt ist.

Das k√∂nnen wir auf unsere pulsierende LED anwenden. Sie soll ihren Pulsierzyklus Dunkel‚ÄìHell‚ÄìDunkel wiederholen, solange der Benutzer nicht unterbricht. Das ist zumindest ein pragmatisches Abbruchkriterium f√ºr unseren Fall. Wir definieren also hier keine feste Anzahl Wiederholungen wie bei der `for ... in`-Schleife, sondern wir wollen festlegen, unter welcher *Bedingung* die Schleife fortgesetzt wird. Wir k√∂nnten also sagen: *solange* die Bedingung X erf√ºllt ist, wiederhole die aufgef√ºhrten Schritte. Und weil Programmiersprachen f√ºr Menschen gemacht sind, klingt es im echten Programm auch so √§hnlich:

```{python}
#| code-line-numbers: false
while 1==1:
    print("This condition is always true")
    time.sleep(1)
```

Das Schl√ºsselwort `while` f√ºhrt eine bedingte Schleife ein, gefolgt von der \gloss{Bedingung}{Aussage, die wahr oder falsch sein kann und die Ausf√ºhrung von Code steuert}{Programmierung}, die die Schleife steuert. Die Bedingung wird vor jedem neuen Schleifendurchlauf gepr√ºft (auch vor dem ersten) und sollte sie falsch (`false`) sein, wird die Schleife beendet.

Wann wird die Schleife oben also beendet? Richtig ‚Äì niemals. Die Bedingung `1==1` ist immer wahr, die Schleife l√§uft somit endlos. Wir sprechen auch von einer Endlosschleife, die wir in der Programmierung unbedingt vermeiden wollen, es sei denn, sie ist explizit gewollt und nicht versehentlich entstanden. Das kurze Programm oben schreibt also in Abst√§nden von einer Sekunde den Text "This condition is always true" auf die Konsole.

Eine Bedingung ist in Python und anderen Programmiersprachen ein wichtiges Konzept, das es uns erm√∂glicht, Entscheidungen zu treffen und den Programmfluss zu steuern. In unserem Fall k√∂nnte die Bedingung lauten: "Solange der Benutzer nicht stoppt, wiederhole den Pulsierzyklus". Eine Bedingung hat die Eigenschaft, dass sie jederzeit ausgewertet werden kann und entweder den Wert wahr (true) oder falsch (false) annimmt. Wie aber dr√ºcken wir das in Python aus?

```{python}
#| code-line-numbers: false
while True:
    print("I will loop forever")
    time.sleep(1)
```

Die einfachste M√∂glichkeit ist es, das Ergebnis der Evaluation direkt hinzuschreiben. Die obige Schleife pr√ºft in jedem Durchgang, ob der Wert `True` wahr ist - was er nat√ºrlich ist. Das ist also so √§hnlich wie bei der Schleife weiter oben, die die Bedingung `1==1` gepr√ºft hat. Die ist ebenfalls immer `True` oder wahr.

Wir lernen im Laufe des Buches noch viele echte Bedingungen kennen, deren Ergebnis nicht von Vornherein bekannt ist. F√ºr unsere pulsierende LED reicht es aber aus, wenn wir eine gewollte Endlosschleife verwenden. Denn auch eine Endlosschleife k√∂nnen wir jederzeit verlassen, indem wir das Programm mit der Tastenkombination Strg+C abbrechen.

Wenn wir jetzt unseren Pulsierzyklus von oben in die neue bedingte `while`-Schleife einf√ºgen, sind wir schon am Ziel. Der Pulsierzyklus wird wiederholt, solange das Programm nicht abgebrochen wird:

```{python}
while True:

    # Increase red step by step
    for r in range(256):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full brightness for a bit
    time.sleep(0.25)

    # Decrease red step by step
    for r in range(255, -1, -1):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full dark for a bit
    time.sleep(0.25)
```

Der Vollst√§ndigkeit halber das Ganze inklusive des [Boilerplate-Codes](#boilerplate-code) f√ºr die Verbindung zu den Tinkerforge-Ger√§ten:

```{python}
#| lst-label: lst-pulse-program
#| lst-cap: Das fertige Programm, das die LED rot pulsieren l√§sst.
import time
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223) 
led = BrickletRGBLEDV2('ZEP', ipcon)

# Turn LED off initially
led.set_rgb_value(0, 0, 0)

while True:

    # Increase red step by step
    for r in range(256):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full brightness for a bit
    time.sleep(0.25)

    # Decrease red step by step
    for r in range(255, -1, -1):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full dark for a bit
    time.sleep(0.25)
```

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_01/1_4_pulsating_led.py).
:::

## Farbkreise {#sec-colors-hue-circle .collapsable}

Das RGB-Farbschema ist f√ºr Computer optimal, weil sich damit mit nur drei Zahlen jede beliebige Farbe kodieren l√§sst. Zahlen sind schlie√ülich die Sprache, mit der Computer am besten umgehen k√∂nnen. F√ºr uns Menschen ist dieses Schema jedoch weniger intuitiv. Oder k√∂nntet ihr auf Anhieb sagen, welche Farbe hinter der Kombination (67, 201, 182) steckt?

Um Farben f√ºr uns leichter w√§hlbar zu machen, wurde der sogenannte \gloss{Hue-Farbkreis}{Kreis, der Farben nach ihrem Farbton anordnet}{Codesysteme} entwickelt. Er ordnet die Farben auf einer Skala von 0 bis 360 Grad an ‚Äì √§hnlich wie die Winkel auf einem Kreis. Neben dem Farbton (Hue) lassen sich zus√§tzlich die S√§ttigung und die Helligkeit einstellen: Der Farbton bestimmt die eigentliche Farbe, die S√§ttigung, wie kr√§ftig oder blass sie wirkt, und die Helligkeit, wie hell oder dunkel sie erscheint.

::: {.content-visible when-format="html"}
![Die Farbauswahl in Google Slides funktioniert √ºber den Hue-Farbkreis.](images/hue_color_picker.gif){#fig-hue-color-picker .lightbox fig-align="center" width="33%"}
:::

::: {.content-hidden when-format="html"}
![Die Farbauswahl in Google Slides funktioniert √ºber den Hue-Farbkreis.](images/hue_color_picker_still.png){#fig-hue-color-picker .lightbox fig-align="center" width="33%"}
:::

In @fig-hue-color-picker seht ihr, wie die Farbauswahl in Google Slides funktioniert. Mit dem Slider in der Mitte bestimmt ihr den Farbton. Habt ihr einen passenden Ton gefunden, k√∂nnt ihr im Rechteck dar√ºber durch Verschieben des kleinen Kreises die S√§ttigung und Helligkeit anpassen.

Beobachtet ihr dabei die RGB-Werte, erkennt ihr die Systematik der Farbton-Skala: Ausgehend von reinem Rot wird Schritt f√ºr Schritt Gr√ºn hinzugef√ºgt ‚Äì so entstehen Orange und Gelb. Danach nimmt der Rotanteil ab, w√§hrend Blau hinzukommt. √úber Cyan gelangen wir zu reinem Blau. Schlie√ülich wird wieder Rot beigemischt, wodurch Violett bis Pink entstehen. Auf diese Weise bildet der Kreis den gesamten Regenbogen ab.

Da die Skala am Ende wieder bei Rot ankommt, l√§sst sich der Farbverlauf nahtlos wiederholen ‚Äì ohne harte √úberg√§nge. Genau deshalb wird der Hue-Verlauf meist als Kreis dargestellt.

![Der Hue-Farbkreis mit HSV-Werten.](images/hue_color_circle_hsv.png){#fig-hue-color-circle .lightbox fig-align="center" width="50%"}

@fig-hue-color-circle zeigt den Hue-Farbkreis im \gloss{HSV-Modell}{Farbmodell, das Farben durch Farbton, S√§ttigung und Helligkeit beschreibt}{Codesysteme}. HSV steht f√ºr Hue, Saturation, Value (Farbton, S√§ttigung, Helligkeit). Der Wert Value gibt die Helligkeit auf einer Skala von 0 bis 100‚ÄØ% an. Im Bild ist die Helligkeit konstant bei 100‚ÄØ%, w√§hrend die S√§ttigung von innen nach au√üen zunimmt. In der Mitte sehen wir deshalb Wei√ü, w√§hrend am √§u√üeren Rand die Farben ihre volle Intensit√§t haben.

Wenn wir ein Programm schreiben, das die gesamte Hue-Farbskala durchl√§uft und die LED jeweils in der passenden Farbe aufleuchten l√§sst, erhalten wir unser Regenbogenprogramm. Da die LED RGB-Werte ben√∂tigt, m√ºssen wir den Verlauf des Hue-Farbkreises in RGB umsetzen. Ein Blick auf die Animation in @fig-hue-color-picker hilft: Der Farbverlauf l√§sst sich in sechs Phasen unterteilen, wie @fig-hue-rgb-diagram zeigt:

1.  Rot = 255, Blau = 0, Gr√ºn steigt linear
2.  Rot sinkt linear, Gr√ºn = 255, Blau = 0
3.  Rot = 0, Gr√ºn = 255, Blau steigt linear
4.  Rot = 0, Gr√ºn sinkt linear, Blau = 255
5.  Rot steigt linear, Gr√ºn = 0, Blau = 255
6.  Rot = 255, Gr√ºn = 0, Blau sinkt linear

Dann beginnt der Zyklus von vorn.

![Der Hue-Farbverlauf mit den Ver√§nderungen der RGB-Werte (Quelle: [Ronja's Tutorials](https://www.ronja-tutorials.com/post/041-hsv-colorspace/)).](images/hue_rgb_diagram.png){#fig-hue-rgb-diagram .lightbox fig-align="center" width="75%"}

## Regenbogen-LED {#sec-colors-rainbow-led .collapsable}

<!-- \gloss{For-Schleife}{Wiederholung mit Z√§hler, s. Z√§hlerschleife}{Programmierung} -->

Mit dem Wissen k√∂nnen wir uns an das erkl√§rte Ziel unseres Experiments machen: die LED nacheinander in allen Farben des Regenbogens aufleuchten zu lassen. Beginnen wir mit der ersten Phase und schreiben daf√ºr ein Python-Programm:

```{python}
#| code-line-numbers: false
for green in range(256):
    led.set_rgb_value(255, green, 0)
    time.sleep(0.01)
```

Weil wir genau wissen, wie oft wir die Schleife durchlaufen wollen, verwenden wir eine `for`-Schleife. Innerhalb der Schleife erh√∂hen wir die Variable `green` jeweils um 1, was effektiv den Gr√ºnanteil unseres RGB-Wertes erh√∂ht. Mit jedem Durchlauf f√ºgen wir somit mehr Gr√ºn hinzu, w√§hrend Rot und Blau konstant bleiben. Phase 1 ist damit abgeschlossen ‚Äì machen wir weiter mit Phase 2:

```{python}
#| code-line-numbers: false
for red in range(255, -1, -1):
    led.set_rgb_value(red, 255, 0)
    time.sleep(0.01)
```

Wie wir mit einer `for`-Schleife r√ºckw√§rts z√§hlen, haben wir schon weiter oben kennengelernt. In Phase 2 verringern wir schrittweise den Rotanteil, w√§hrend die anderen beiden Farben konstant bleiben. Damit kommen wir zu Phase 3:

```{python}
#| code-line-numbers: false
for blue in range(256):
    led.set_rgb_value(0, 255, blue)
    time.sleep(0.01)
```

Ich glaube, ihr habt das Prinzip verstanden. Indem wir die sechs Phasen jeweils in einer eigenen Schleife abarbeiten, erhalten wir das vollst√§ndige Regenbogenprogramm:

```{python}
# phase 1
for green in range(256):
    led.set_rgb_value(255, green, 0)
    time.sleep(0.01)

# phase 2
for red in range(255, -1, -1):
    led.set_rgb_value(red, 255, 0)
    time.sleep(0.01)

# phase 3
for blue in range(256):
    led.set_rgb_value(0, 255, blue)
    time.sleep(0.01)

# phase 4
for green in range(255, -1, -1):
    led.set_rgb_value(0, green, 255)
    time.sleep(0.01)

# phase 5
for red in range(256):
    led.set_rgb_value(red, 0, 255)
    time.sleep(0.01)

# phase 6
for blue in range(255, -1, -1):
    led.set_rgb_value(255, 0, blue)
    time.sleep(0.01)

```

Wie sch√∂n üåà Eine Sache fehlt aber noch.

### Runde f√ºr Runde

Der Regenbogen soll am Ende wieder von vorne beginnen. Wie schon beim Pulsieren der Farben k√∂nnen wir auch hier eine `while`-Schleife verwenden und die Phasen kontinuierlich abspielen ‚Äì solange, bis der Benutzer die Escape-Taste dr√ºckt:

```{python}
while True:

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(0.01)

    # phase 2
    for red in range(255, -1, -1):
        led.set_rgb_value(red, 255, 0)
        time.sleep(0.01)

    # phase 3
    for blue in range(256):
        led.set_rgb_value(0, 255, blue)
        time.sleep(0.01)

    # phase 4
    for green in range(255, -1, -1):
        led.set_rgb_value(0, green, 255)
        time.sleep(0.01)

    # phase 5
    for red in range(256):
        led.set_rgb_value(red, 0, 255)
        time.sleep(0.01)

    # phase 6
    for blue in range(255, -1, -1):
        led.set_rgb_value(255, 0, blue)
        time.sleep(0.01)

```

Wir haben es fast geschafft! Eine Kleinigkeit wollen wir an unserem Programm noch verbessern.

### Geschwindigkeit steuern

Vielleicht habt ihr gemerkt, dass die Geschwindigkeit, mit der unsere LED den gesamten Regenbogen einmal durchl√§uft, nicht sehr hoch ist. Ich w√ºrde das gerne beschleunigen. Die Zeit steuern wir √ºber die `time.sleep()`-Funktion, sodass wir einfach den Wert in jedem Funktionsaufruf verringern k√∂nnten. Das w√§re aber nicht sehr effizient, weil wir ihn an sechs Stellen anpassen m√ºssen. Wenn wir danach merken, dass es zu schnell ist, m√ºssten wir den Wert erneut √ºberall editieren. Das geht einfacher!

Der Trick liegt darin, den Wert f√ºr die Wartedauer als Variable zu definieren und nur an einer Stelle zu √§ndern.

```{python}
pause_duration = 0.01
while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # etc.
```

Schon besser! Wir gehen aber noch einen Schritt weiter. Statt dieses kleinteiligen Werts f√ºr eine Pause zwischen zwei kleinen Farbver√§nderungen m√∂chte ich die Gesamtdauer f√ºr den Durchlauf eines Regenbogens angeben. Der Wert `pause_duration` soll dann auf dieser Basis errechnet werden. Dazu m√ºssen wir nur die Anzahl der Pausen insgesamt kennen; in jeder der sechs Phasen sind es 256. Macht also:

$$
6 \times 256 = 1536
$$

Im Programm setzen wir die Pausendauer also auf die Gesamtdauer in Sekunden geteilt durch 1536:

```{python}
rainbow_duration = 5
pause_duration = rainbow_duration / 1536

while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # etc.
```

Und schon k√∂nnen wir unseren Regenbogen beliebig zeitlich steuern. Damit sind wir am Ende des Kapitels angekommen. Wir schlie√üen es mit dem vollst√§ndigen Code f√ºr unseren Regenbogenverlauf in @lst-rainbow-program ab. Vergesst nicht, den Wert f√ºr die UID eurer LED anzupassen, damit es auch bei euch funktioniert:

```{python}
#| lst-cap: Das fertige Regenbogenprogramm.
#| lst-label: lst-rainbow-program
import time
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect("localhost", 4223)
led = BrickletRGBLEDV2("<YOUR_LED_UID>", ipcon)

# Turn LED off initially
led.set_rgb_value(0, 0, 0)

rainbow_duration = 5
pause_duration = rainbow_duration / 1536

while True:

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # phase 2
    for red in range(255, -1, -1):
        led.set_rgb_value(red, 255, 0)
        time.sleep(pause_duration)

    # phase 3
    for blue in range(256):
        led.set_rgb_value(0, 255, blue)
        time.sleep(pause_duration)

    # phase 4
    for green in range(255, -1, -1):
        led.set_rgb_value(0, green, 255)
        time.sleep(pause_duration)

    # phase 5
    for red in range(256):
        led.set_rgb_value(red, 0, 255)
        time.sleep(pause_duration)

    # phase 6
    for blue in range(255, -1, -1):
        led.set_rgb_value(255, 0, blue)
        time.sleep(pause_duration)
```

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_01/1_6_rainbow_led.py).
:::

Seid ihr bereit f√ºr das n√§chste Experiment?