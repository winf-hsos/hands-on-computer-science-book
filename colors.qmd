# Farben {#sec-colors}

## Zusammenfassung {.unnumbered .collapsable}

Im ersten Kapitel steigen wir gleich voll ein und schreiben unser erstes Programm. Unser Ziel ist es, eine LED nacheinander in allen Farben des Regenbogens leuchten zu lassen.

### Schritt für Schritt zum Ziel {.unnumbered}

Auf dem Weg dorthin gehen wir die folgenden Schritte.

| \# | Was? | Wo? |
|--|-------------------------------------------------------|----------------|
| 1 | Wir lernen, wie man eine LED aus einem Programm heraus steuert. | @sec-colors-control-led |
| 2 | Wir werfen einen kurzen Blick auf Farben und wie sie im Computer erzeugt werden. Dabei lernen wir den Unterschied zwischen additiver und subtraktiver Farbmischung kennen. | @sec-colors-light-and-colors |
| 3 | Wir programmieren eine pulsierende LED als erster Schritt in Richtung Regenbogenverlauf. | @sec-colors-pulsating-led |
| 4 | Wir lernen den Hue-Farbverlauf kennen, weil wir den für einen schönen Regenbogen benötigen. | @sec-colors-hue-circle |
| 5 | Endlich - wir schreiben das Programm für den Regenbogenverlauf. | @sec-colors-rainbow-led |

### Begriffe und Konzepte {.unnumbered}

Dabei lernen wir neue Begriffe und Konzepte kennen.

<!-- CHAPTER_GLOSSARY_START -->
::: {.datatable-nosearch data-order='[[2,"asc"]]'}
| Begriff | Kategorie | Wo? |
|---|---|---|
| **Brick Viewer** | Hardware | @sec-colors-experiment-setup |
| **RGB LED** | Hardware | @sec-colors-experiment-setup |
| **UID** | Programmierung | @sec-colors-control-led |
| **Programm** | Programmierung | @sec-colors-control-led |
| **Boilerplate-Code** | Programmierung | @sec-colors-control-led |
| **Bibliothek** | Programmierung | @sec-colors-control-led |
| **Objekt** | Programmierung | @sec-colors-control-led |
| **Klasse** | Programmierung | @sec-colors-control-led |
| **Schlüsselwort** | Programmierung | @sec-colors-control-led |
| **Instanz** | Programmierung | @sec-colors-control-led |
| **Methode** | Programmierung | @sec-colors-control-led |
| **RGB-Farbkodierung** | Codesysteme | @sec-colors-control-led |
| **Elektromagnetische Strahlung** | Physik | @sec-colors-control-led |
| **Frequenz** | Physik | @sec-colors-light-and-colors |
| **Wellenlänge** | Physik | @sec-colors-light-and-colors |
| **Hertz (Hz)** | Physik | @sec-colors-light-and-colors |
| **LED** | Hardware | @sec-colors-light-and-colors |
| **Parameter** | Programmierung | @sec-colors-light-and-colors |
| **Additive Farbmischung** | Physik | @sec-colors-light-and-colors |
| **Subtraktive Farbmischung** | Physik | @sec-colors-light-and-colors |
| **CMYK** | Hardware | @sec-colors-light-and-colors |
| **Schleife** | Programmierung | @sec-colors-pulsating-led |
| **Zählerschleife** | Programmierung | @sec-colors-pulsating-led |
| **Argument** | Programmierung | @sec-colors-pulsating-led |
| **While-Schleife** | Programmierung | @sec-colors-pulsating-led |
| **Bedingung** | Programmierung | @sec-colors-pulsating-led |
| **Hue-Farbkreis** | Codesysteme | @sec-colors-pulsating-led |
| **HSV-Modell** | Codesysteme | @sec-colors-pulsating-led |
| **For-Schleife** | Programmierung | @sec-colors-hue-circle |
:::
<!-- CHAPTER_GLOSSARY_END -->


## Experimentaufbau {#sec-colors-experiment-setup .collapsable}

### Hardware

Bereit für euer erstes Hardware-Experiment? Perfekt! Ihr braucht dafür eine LED ([RGB LED Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/RGB_LED_V2.html)) und einen Mikrocontroller ([Master Brick 3.2](https://www.tinkerforge.com/de/shop/master-brick.html)). Befestigt beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in @fig-setup-rgb-led gezeigt. Zwei Schrauben pro Gerät reichen völlig. Denkt an die kleinen, weißen Unterlegscheiben aus Kunststoff. Sie schützen eure Platinen vor Druckstellen.

Die vollsändige Hardwareliste für dieses Kapitel sieht so aus:

-  1 x [Master Brick 3.2](https://www.tinkerforge.com/de/doc/Hardware/Bricks/Master_Brick.html)
-  1 x [RGB LED Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/RGB_LED_V2.html)
-  1 x [Montageplatte 22x10](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-plate-22x10.html)
-  1 x [Brickletkabel 15cm (7p-7p)](https://www.tinkerforge.com/de/shop/accessories/cable/bricklet-cable-15cm-7p-7p.html)
-  1 x [Befestigungskit 12 mm](https://www.tinkerforge.com/de/shop/accessories/mounting/mounting-kit-12mm.html)

Neben der Hardware benötigt ihr auch die passende Software. Diese solltet ihr bereits installiert haben. Falls nicht, schaut im [Abschnitt zu den Voraussetzungen](prerequisites.qmd) vorbei. Dort ist alles genau beschrieben. Im Folgenden gehe ich davon aus, dass ihr alles am Laufen habt.

::: {#fig-setup-rgb-led layout="[[1], [1,1], [1,1]]"}
![Seitenansicht.](images/master_brick_with_led_01.jpg){#fig-setup-rgb-led-a .lightbox group="setup-rgb-led"}

![Nahaufnahme der LED.](images/master_brick_with_led_02.jpg){#fig-setup-rgb-led-b .lightbox group="setup-rgb-led"}

![Montageplatte mit allen Komponenten.](images/master_brick_with_led_03.jpg){#fig-setup-rgb-led-c .lightbox group="setup-rgb-led"}

![Untenansicht.](images/master_brick_with_led_04.jpg){#fig-setup-rgb-led-d .lightbox group="setup-rgb-led"}

![Ansicht der vier Steckplätze.](images/master_brick_with_led_06.jpg){#fig-setup-rgb-led-e .lightbox group="setup-rgb-led"}

Einfaches Setup mit einem Mikrocontroller und einer LED.
:::

### Erste Schritte mit der LED

Im ersten Schritt wollen wir die LED und ihre Funktionen testen! Das geht ganz leicht mit dem \gloss{Brick Viewer}{Ein Werkzeug zum schnellen Testen der Tinkerforge-Bauteile}{Hardware}. Schließt zuerst den Master Brick über das USB-Kabel an euren Computer an und öffnet den Brick Viewer. Klickt dann auf den Connect-Button.

![Über den Connect-Button verbindet ihr den Brick Viewer mit dem angeschlossenen Master Brick.](images/brick_viewer_connect.png){#fig-brick-viewer-connect .lightbox fig-align="center" width="100%" group="brick-viewer"}

Wenn alles geklappt hat, zeigt euch der Brick Viewer alle angeschlossenen Geräte in Tabs an. Schaut euch @fig-brick-viewer-after-connect an – so etwa sollte es aussehen.

![Der Brick Viewer, nachdem ihr mit dem Master Brick verbunden seid.](images/brick_viewer_after_connect.png){#fig-brick-viewer-after-connect .lightbox group="brick-viewer"}

Wechselt nun zum Tab der \gloss{RGB LED}{Eine LED, die in verschiedenen Farben leuchten kann.}{Hardware}. Hier könnt ihr auf unterschiedlichen Wegen die Farbe der LED einstellen. Mehr kann eine LED nicht!

Mit den drei Schiebereglern steuert ihr die einzelnen Farbkanäle – Rot, Grün, Blau. Der Wertebereich: 0 bis 255. Warum gerade diese Farben und diese Zahlen? Gute Frage. Die Antwort kommt weiter unten.

![Die Ansicht für die RGB LED im Brick Viewer, in der ihr alle Funktionen per Klick im Zugriff habt.](images/brick_viewer_rgb_led.png){#fig-brick-viewer-rgb-led .lightbox group="brick-viewer"}

Fazit: Der Brick Viewer ist ideal zum Ausprobieren. Aber wenn ihr echte Projekte umsetzen wollt, müsst ihr programmieren lernen. Also los!

## Erstes Programm: LED ansteuern {#sec-colors-control-led .collapsable}

Wie verbinden wir uns über ein Programm mit der LED und setzen ihre Farbe? Die Antwort darauf findet ihr im folgenden kurzen Codebeispiel.

```{python}
#| lst-label: lst-boilerplate-code
#| lst-cap: Der Boilerplate-Code für die Verbindung mit den Geräten am Beispiel der RGB LED.

from tinkerforge.ip_connection import IPConnection # <1>
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2 # <2>

ipcon = IPConnection() # <3>
ipcon.connect("localhost", 4223) # <4>
led = BrickletRGBLEDV2("ZEP", ipcon) # <5>
```

1.  Hier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.
2.  Hier importieren wir ein weiteres Objekt, das wir zur Darstellung der LED als Python-Objekt benötigen.
3.  Die Verbindung erfolgt über eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.
4.  Mit `connect` stellen wir eine Verbindung zum angeschlossenen Master Brick her.
5.  Schließlich holen wir uns eine virtuelle Instanz des RGB LED Bricklets, indem wir die \gloss{UID}{*Unique Identifier*: Eindeutige Identifikation, hier eines Tinkerforge-Geräts.}{Programmierung} nennen und sagen, welche Verbindung (`ipcon`) genutzt werden soll.

### Programme

Zunächst klären wir den Begriff \gloss{Programm}{Abfolge von Anweisungen, die ein Computer ausführt}{Programmierung}. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausführt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm später dafür zuständig, mit der LED zu interagieren und sie in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns ermöglichen, dem Computer präzise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut für Einsteiger eignet und gleichzeitig mächtig genug ist, um komplexe Aufgaben zu lösen.

Wenn wir ein Programm ausführen, arbeitet der Computer die Anweisungen Schritt für Schritt von oben nach unten ab. Die Nummerierung der Zeilen verdeutlicht das sehr schön. Der Computer beginnt bei Zeile 1 und arbeitet die Befehle Zeile für Zeile bis nach unten ab.

Es gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir später kennen.

### Boilerplate Code {#boilerplate-code}

Der Codeausschnitt in @lst-boilerplate-code wird uns im Verlauf dieses Buches immer wieder begegnen. Wir benötigen ihn, um uns am Anfang des Programms mit den Geräten zu verbinden, die wir für unsere Anwendung benötigen. In der Informatik nennen wir solchen Code, den wir häufig in der gleichen Form benötigen und fast eins zu eins kopieren können, auch \gloss{Boilerplate-Code}{Vorlagen-Code, der häufig wiederverwendet wird und oft unverändert bleibt.}{Programmierung}. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.

### Bibliotheken {#bibliotheken}

Beginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr ähnliche Befehle, die mit dem Schlüsselwort `from` beginnen. Nach dem Schlüsselwort `from` folgt der Name einer \gloss{Bibliothek}{Eine Bündelung von fertigen Funktionen, Klassen oder Konstanten in einer Programmiersprache}{Programmierung}, aus der wir ein für unser Programm benötigtes Objekt importieren. Die Kombination der Schlüsselwörter `from ... import` lässt sich also wörtlich übersetzen: "Aus der Bibliothek X importiere das Objekt Y".

Eine *Bibliothek*\index{Bibliothek} in einer Programmiersprache ist die Bündelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek könnt ihr euch vorstellen wie einen Werkzeugkasten: Sie enthält fertige Werkzeuge (Funktionen und Klassen), damit ihr nicht alles von Grund auf selbst programmieren müsst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Geräten loslegen können. Für jedes Gerät gibt es in der Tinkerforge-Bibliothek eine eigene Klasse, über die wir auf die Funktionen jedes Geräts zugreifen können.

### Klassen und Objekte

<!--
\gloss{Objekt}{Eine konkrete Instanz einer Klasse, die die definierten Eigenschaften und Funktionen nutzen kann.}{Programmierung}
-->

Mit `from ... import` importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit *importieren* ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge später wirklich nutzen, steht auf einem anderen Blatt.

In dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei Klassen, deren Verwendung wir ankündigen. Die erste Klasse heißt `IPConnection`\index{`IPConnection`} und die zweite `BrickletRGBLEDV2`\index{`BrickletRGBLEDV2`}. Der Begriff \gloss{Klasse}{Baupläne für Objekte, die bestimmte Eigenschaften und Funktionen definieren}{Programmierung} ist hier analog zum Begriff *Kategorie* zu verstehen. Wir können zu einer Klasse gehörige Objekte erzeugen, und alle Objekte derselben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.

Stellt euch vor, ihr habt eine Klasse namens `Auto`. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa `fahren()`, `bremsen()` oder `tanken()`. Diese Dinge sollen für jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Wir können also sagen: "Mein Auto ist ein Objekt der Klasse `Auto`." Jedes `Auto` hat neben den Funktionen die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte für diese Eigenschaften haben.

Genauso verhält es sich mit den Klassen, die Tinkerforge für uns bereitgestellt hat. Die Klasse `IPConnection` beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen können, und die Klasse `BrickletRGBLEDV2` beschreibt, wie wir mit der LED interagieren können. Wenn wir ein Objekt dieser Klasse erstellen, können wir alle Funktionen nutzen, die in der Klasse definiert sind. Eine LED muss nicht fahren oder bremsen wie ein Auto. Dafür hat sie andere Funktionen, wie etwa `set_rgb_value()`, die uns erlaubt, die Farbe der LED zu ändern. Eine Eigenschaft jeder LED ist ihre UID, die eindeutig ist und uns hilft, sie im System zu identifizieren.

### Schlüsselwörter

Soeben haben wir mit `from` und `import` unsere ersten beiden Schlüsselwörter in Python kennengelernt! Aber was bedeutet das genau? Ein \gloss{Schlüsselwort}{Begriff, der in der Programmiersprache eine feste Bedeutung hat}{Programmierung}, das wir im Englischen auch *keyword* oder *reserved keyword* nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch häufig Namen vergeben müssen, etwa für Variablen oder Funktionen. Diese Namen dürfen nicht wie ein Schlüsselwort lauten, ansonsten funktioniert unser Programm nicht wie gewünscht. Welche Schlüsselwörter es in Python gibt, könnt ihr [hier](https://docs.python.org/3/reference/lexical_analysis.html#keywords "Reservierte Schlüsselwörter in Python") nachschauen.

Im Codeausschnitt oben laden wir zuerst das Objekt für die Verbindung zum angeschlossenen Mikrocontroller, die über eine IP-Verbindung hergestellt wird. Was das genau ist? Später mehr dazu. Zusätzlich zur `IPConnection` laden wir anschließend noch die benötigten Klassen für die Geräte, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur die LED, in späteren Experimenten werden es auch mal mehrere Geräte sein.

### Objekte erzeugen

In @lst-boilerplate-code in Zeile 4 erzeugen wir ein Objekt\index{Objekt} der Klasse `IPConnection`. Die fertige \gloss{Instanz}{Ein erzeugtes Objekt einer Klasse, die die definierten Eigenschaften und Funktionen nutzen kann}{Programmierung} – so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde – speichern wir auf einer *Variable* mit dem Namen `ipcon`. Diesen Namen haben wir uns selbst ausgedacht, damit wir später darauf zugreifen können. Wir hätten auch einen anderen Namen wählen können. Eine Variable ist also ein Platzhalter für einen Wert, den wir später im Programm verwenden wollen. In diesem Fall ist `ipcon` der Platzhalter für die Verbindung zu unserem Mikrocontroller. Was eine Variable technisch ist, lernen wir später noch genauer kennen.

### Methoden

Über das Objekt `ipcon` können wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode `connect()`. Eine \gloss{Methode}{Funktion, die zu einem Objekt gehört}{Programmierung} ist eine Funktion, die zu einem Objekt gehört – wie etwa `fahren()` oder `bremsen()` in unserem Auto-Beispiel.

Wir können Methoden aufrufen, um eine bestimmte Aktion auszuführen. In diesem case stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, über den die Verbindung hergestellt werden soll. In unserem Fall ist das "localhost", was für die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standardmäßig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt `.` nach dem Objekt, gefolgt vom Namen der Methode und den Klammern `()`, in denen wir eventuell benötigte Parameter angeben.

Eine Methode ist letztlich eine Funktion, die zu einem Objekt gehört. Zu einem späteren Zeitpunkt schreiben wir unsere eigenen Funktionen und lernen dann noch viel mehr darüber.

### Ein Objekt für die LED

In Zeile 6 erzeugen wir schließlich ein Objekt der Klasse `BrickletRGBLEDV2`. Dieses Objekt repräsentiert unsere LED und ermöglicht es uns, mit ihr zu interagieren. Wir nennen das Objekt `led`, was kurz und klar ist. Auch hier haben wir uns den Namen selbst ausgedacht, um später darauf zugreifen zu können. Auch wenn wir grundsätzlich Variablennamen frei wählen können, sollten sie immer so gewählt werden, dass sie den Inhalt der Variable beschreiben. Das macht es später einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten müssen. Dazu gehören etwa, dass Variablennamen nicht mit einer Zahl beginnen dürfen und keine Leerzeichen enthalten dürfen. Eine ausführliche Liste der Regeln findet ihr [hier](https://docs.python.org/3/reference/lexical_analysis.html#identifiers "Regeln für Variablennamen in Python").

### Zusammenfassung unseres ersten Programms

Damit haben wir unser erstes Programm von oben nach unten erläutert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:

|  |  |
|-------------------------|-----------------------------------------------|
| **Programme** | Abfolge von Anweisungen, die nacheinander ausgeführt werden. |
| **Boilerplate Code** | Standard-Code, den man immer wieder braucht. |
| **Importieren von Bibliotheken** | Sammlung von fertigen Code-Elementen. |
| **Schlüsselwörter** | Reservierte Begriffe der Programmiersprache. |
| **Klassen und Objekte** | Kategorien und deren konkrete Instanzen. |
| **Methoden und Funktionen** | Funktionen, die zu einem Objekt gehören. |
| **Variablen** | Platzhalter für Werte. |

### Und jetzt?

Wir haben nun eine digitale Repräsentation unserer LED in Python. Wir können die LED jetzt zum Leuchten bringen, indem wir eine Methode der Klasse `BrickletRGBLEDV2`, die `set_rgb_value()` heißt, verwenden. Diese Methode erwartet drei Parameter: Rot, Grün und Blau. Mit diesen Parametern können wir die Farbe der LED einstellen.

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 255, 0) # <1>
```

1.  Setzt die LED auf grün. R = 0, G = 255, B = 0. Logisch, oder?

Moment mal … Wo steht hier eigentlich *grün*? Steht da gar nicht. Stattdessen drei Zahlen. Willkommen bei der *RGB-Farbkodierung*\gloss{RGB-Farbkodierung}{Kodierung von Farben mittels Rot-, Grün- und Blauwerten}{Codesysteme}. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Grün, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Weiß. Nur Grün auf 255? Na klar: grün.

Aber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie übersetzen wir die Welt in etwas, das ein Computer versteht?

Warum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit *drei* Zahlen? Warum überhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?

Vorher müssen wir aber kurz zurück in die Schule.

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_01/1_2_first_program.py).
:::

## Licht und Farben {#sec-colors-light-and-colors .collapsable}

### Blick auf die Physik

<!-- \gloss{Elektromagnetische Strahlung}{Form von Energie, die sich in Wellen durch den Raum bewegt}{Physik} -->

Physik ist vielleicht schon eine Weile her. Erinnern wir uns dennoch kurz, was Licht ist und wie Farben damit zusammenhängen. Licht ist elektromagnetische Strahlung. Das bedeutet, es handelt sich um gekoppelte Schwingungen elektrischer und magnetischer Felder, die sich mit Lichtgeschwindigkeit ausbreiten. Vereinfacht können wir uns Licht als Wellen vorstellen, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenlängen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen über Infrarotstrahlung bis hin zu Röntgenstrahlen und Gammastrahlen reicht.

Bei Wellen unterscheiden wir zwischen der \gloss{Frequenz}{Wie oft etwas pro Sekunde passiert}{Physik} (wie oft die Welle pro Sekunde schwingt) und der \gloss{Wellenlänge}{der Abstand zwischen zwei aufeinanderfolgenden Wellen}{Physik} (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenlänge sind umgekehrt proportional: Je höher die Frequenz, desto kürzer die Wellenlänge und umgekehrt.

Frequenzen messen wir in \gloss{Hertz (Hz)}{Einheit für Frequenz (1/s)}{Physik}, wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenlängen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) für violettes Licht und etwa 700 nm für rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abstände zwischen den Wellenlängen des sichtbaren Lichts sind also extrem klein.

Was bedeutet das nun für eine LED? Eine \gloss{LED}{Steht für *light emitting diode*}{Hardware} (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchfließt. Die Farbe des Lichts hängt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenlängen, was zu verschiedenen Farben führt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenlänge von etwa 620–750 nm, während eine grüne LED Licht mit einer Wellenlänge von etwa 495–570 nm emittiert.

![Das elektromagnetische Spektrum, von dem das sichtbare Licht ein kleiner Teil ist. (Quelle: [Wikipedia](https://en.wikipedia.org/wiki/File:EM_Spectrum_Properties_edit.svg))](images/em_spectrum.png){#fig-em-spectrum fig-align="center" width="100%"}

Die RGB LED besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer grünen und einer blauen. Jede dieser LEDs kann unabhängig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Stromstärke bedeutet mehr Intensität der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Grün und Blau in unterschiedlichen Intensitäten können wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensität leuchten lassen, erhalten wir Weiß. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LEDs sind dann alle aus.

Jetzt wissen wir, warum die Methode `set_rgb_value()` drei \gloss{Parameter}{Werte, die an eine Funktion übergeben werden}{Programmierung} erwartet: Rot, Grün und Blau. Diese Parameter sind die Intensitäten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 können wir jede Farbe im sichtbaren Spektrum erzeugen.

Ein Farbwert im Computer besteht also aus drei Zahlen besteht, die jeweils zwischen 0 und 255 liegen. Das gilt für unsere LED, aber auch für Pixel in TVs, Smartphones, digitalen Fotos oder Monitoren. Wie kommt es aber zu der merkwürdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grundsätzlich Werte speichert und wie dieser Speicher organisiert ist. Genaueres erfahren wir schon in @sec-numbers.

Klingt alles theoretisch sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus und mischen zwei Farben mit voller Intensität!

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 255, 0)
```

Was macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!

### Additive Farbmischung

<!-- \gloss{Additive Farbmischung}{Mischen von Farben durch Hinzufügen von Licht}{Physik} -->

Ihr solltet alle eure LEDs in Gelb aufleuchten sehen. In der additiven Farbmischung* mischen wir Rot und Grün und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Grün, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensität leuchten lassen, erhalten wir eine neue Farbe, die stets heller ist als die Ursprungsfarben. Wir fügen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensität mischen, erhalten wir schließlich Weiß.

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 255, 255)
```

Am anderen Ende des Spektrums erzeugen drei Nullen die Farbe Schwarz:

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 0, 0)
```

### Subtraktive Farbmischung

<!-- \gloss{Subtraktive Farbmischung}{Mischen von Farben durch Entfernen von Licht}{Physik} -->

Ihr könnt euch merken, dass wir im Kontext von Computern oft von *additiver Farbmischung* sprechen, weil Bildschirme Licht erzeugen. Durch das Mischen der drei Farbkanäle entstehen neue Farben gemäß der additiven Farbmischung, also stets heller als ihre Grundfarben. Daneben gibt es aber noch die subtraktive Farbmischung. Sie funktioniert anders, nämlich genau umgekehrt. Statt beim Mischen Licht hinzuzufügen, nehmen wir Licht weg.

Erinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbkasten die Mischung aus Rot und Grün ergeben? Sicher nicht Gelb – eher Braun. Eine dunklere Farbe. Das liegt daran, dass wir es hier nicht mit additiver, sondern mit subtraktiver Farbmischung zu tun haben. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht *absorbieren* und *reflektieren*. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtspektrums werden nicht mehr reflektiert, sondern absorbiert und sind damit nicht mehr sichtbar. Das Ergebnis einer Mischung zweier Farben ergibt in der subtraktiven Farbmischung also stets eine dunklere Farbe – genau umgekehrt zur additiven Farbmischung.

Was passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, nämlich Wärme. Deshalb wird eine schwarze Oberfläche auch besonders heiß, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspektrum und wandelt es in Wärme um. Dagegen wirken weiße Oberflächen fast wie Klimaanlagen. Es ist kein Zufall, dass wir in sonnigen Erdteilen viele weiße Fassaden sehen.

Wenn wir alle Farben mischen, ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zurück. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen *kombinieren*, um neue Farben zu erhalten.

::: {#fig-color-mixing layout="[[1,1]]"}
![Additive Farbmischung](images/additive_color_mixing.png){#fig-additive-color-mixing .lightbox}

![Subtraktive Farbmischung](images/subtractive_color_mixing.png){#fig-subtractive-color-mixing .lightbox}

Additive und subtraktive Farbmischung.
:::

In @fig-color-mixing sehen wir die beiden Farbmischungsarten im Vergleich. In @fig-subtractive-color-mixing sehen wir die drei Grundfarben, die wir bei der subtraktiven Variante benötigen, um daraus alle weiteren Farben zu erhalten. Das sind Cyan, Magenta und Gelb. Im Englischen ist die Abkürzung CMY, wo das "Y" für *Yellow* steht. In der additiven Farbmischung sind es, wie oben schon gesehen, Rot, Grün und Blau. Wenn ihr @fig-additive-color-mixing betrachtet, dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der additiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?

In der additiven Farbmischung entsteht Gelb durch das Mischen von Rot und Grün, wobei Blau fehlt. Im Umkehrschluss bedeutet das: Gelbes Licht enthält keine blaue Komponente, es reflektiert also kein Blau. In der subtraktiven Farbmischung (wie beim Farbkasten) wird Gelb erzeugt, indem Blau aus weißem Licht herausgefiltert wird – Gelb reflektiert also kein Blau, sondern absorbiert es. Gelb kann also auch als Blaufilter gesehen werden. Das erklärt, warum ein gelber Gegenstand unter blauem Licht dunkel erscheint: Er kann das blaue Licht nicht reflektieren.

Jetzt können wir auch erklären, warum Farbdrucker vier unterschiedliche Kartuschen benötigen (@fig-toner-cmy). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb können wir jede beliebige Farbe mischen. Zusätzlich haben Drucker eine Kartusche für Schwarz, um erstens ein sattes Schwarz drucken zu können und zweitens die Farbkartuschen zu schonen. Denn schließlich müssen alle drei Farben gemischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen Schwarz enthalten (oder sogar ausschließlich), ist eine schwarze Kartusche einfach effizienter. Die Farbe Schwarz wird bei Druckerkartuschen als Key bezeichnet und mit "K" abgekürzt. Wir sprechen daher auch von \gloss{CMYK}{Abkürzung der Grundfarben im Farbdruck}{Hardware}.

![Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.](images/toner-cmy.png){#fig-toner-cmy .lightbox}

Farben spielen eine so wichtige Rolle bei der Arbeit mit Computern. Deshalb lohnt es sich, ein wenig über die Hintergründe von Farben und deren Mischung zu verstehen. Wir werden später noch lernen, wie Bildschirme Farben darstellen. Spätestens dann wird uns das Thema der Farbmischung wieder begegnen.

Ab jetzt wollen wir weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, praxisnah verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED über die Methode `set_rgb_value()` verändern können, wenn wir wissen, welcher RGB-Code unsere gewünschte Farbe repräsentiert. Da wir jetzt mehr über die Farbmischung wissen, können wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 0, 255)
```

Gemäß der Theorie der additiven Farbmischung (@fig-additive-color-mixing) müssten Rot und Blau Magenta ergeben. Probiert es aus!

## Pulsierende LED {#sec-colors-pulsating-led .collapsable}

Das deklarierte Ziel unseres ersten Experiments ist es, einen Regenbogenfarbverlauf zu erzeugen. Dazu müssen wir die Farbe der LED kontinuierlich ändern, sodass sie von Rot über Gelb, Grün, Cyan, Blau und Violett wieder zurück zu Rot wechselt.

Lasst uns aber möglichst einfach anfangen und uns dem Regenbogen schrittweise annähern. Zunächst wäre es schön, wenn wir die LED einfach Rot pulsieren lassen könnten. Dazu müssen wir nämlich nur den Rot-Kanal und nicht alle drei Kanäle der LED ansteuern. Gleichzeitig lernen wir schon hier ein Problem kennen, das uns in der Programmierung häufig begegnet und für das es eine elegante Lösung gibt.

### Abzählbare Wiederholungen

Was bedeutet es, die LED pulsieren zu lassen? Und was müssen wir dafür tun? Pulsieren bedeutet, dass die LED über einen kurzen Zeitraum immer heller wird, kurz in der vollen Helligkeit verweilt und dann sofort wieder kontinuierlich dunkler wird. Sobald sie schwarz ist, fängt der Zyklus von vorne an.

Den Ausdruck *immer heller werden* können wir bezogen auf die LED so übersetzen, dass wir den Anteil des Rot-Kanals schrittweise erhöhen. Wenn die LED zu Beginn aus ist, also alle Kanäle auf 0 stehen, können wir den Rot-Kanal von 0 auf 255 erhöhen und so die LED immer heller in Rot aufleuchten lassen.

Wir beginnen also mit einer schwarzen LED:

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 0, 0)
```

Anschließend setzen wir den Wert für Rot auf 1:

```{python}
#| code-line-numbers: false
led.set_rgb_value(1, 0, 0)
```

Und erhöhen ihn schrittweise:

```{python}
#| code-line-numbers: false
led.set_rgb_value(2, 0, 0)
led.set_rgb_value(3, 0, 0)
led.set_rgb_value(4, 0, 0)
# ...
```

Wenn wir nach diesem Muster fortfahren, hätten wir bis zum vollen Rot 255 Zeilen Code geschrieben, eine Zeile für jeden Erhöhungsschritt. Und anschließend das Gleiche nochmal rückwärts, damit wir wieder zu Schwarz kommen. Mit 510 Zeilen Code hätten wir dann einen Pulsierungszyklus durchlaufen. Wollen wir die LED öfter pulsieren lassen, vervielfacht sich unser Code entsprechend. Das kann nicht die Lösung für ein so einfaches Problem sein.

Und tatsächlich gibt es in der Programmierung eine bessere Möglichkeit, um sich wiederholende Abläufe abzubilden: die \gloss{Schleife}{Wiederholung von Programmcode}{Programmierung}. In einem Fall, bei dem wir genau wissen, wie oft wir etwas wiederholen wollen, bietet sich eine \gloss{Zählerschleife}{Wiederholung mit Zähler}{Programmierung} an:

```{python}
#| code-line-numbers: false
for r in range(256):
    led.set_rgb_value(r, 0, 0)
```

Voilà! Unsere 510 Zeilen Code können wir mit einer Schleife auf zwei Zeilen reduzieren! Dazu müssen wir im Kopf der Schleife (`for ... in ...`) festlegen, wie oft der eingerückte Codeblock nach dem Doppelpunkt ausgeführt werden soll. In Python funktioniert das über die Angabe einer Folge, für die jedes Element einmal durchlaufen wird. Das aktuelle Element ist in der Schleife als `r` verfügbar. Und `r` nimmt nacheinander jeden Wert der Folge an, die nach dem Schlüsselwort `in` folgt. Diese Folge erzeugt hier die Funktion `range(256)`, die – wie der Name preisgibt – eine Zahlenfolge von 0 bis zum angegebenen Wert minus eins erzeugt. In unserem Fall also von 0 bis 255.

Um das besser nachvollziehen zu können, geben wir den Wert für `r` einfach mal aus:

```{python}
#| code-line-numbers: false
for r in range(256):
    led.set_rgb_value(r, 0, 0)
    print(r) # <1> 
```

1.  Mit `print()` geben wir einen Wert auf der Konsole aus.

Jetzt wird es deutlich: Mit jedem Durchlauf der Schleife wird ein neuer Wert für `r` gesetzt und ausgegeben. Und zwar jeweils um eins erhöht. Die Funktion `range(256)` erzeugt genau gesagt eine sortierte Reihe mit den Zahlen von 0 bis 255. Das sieht in Python dann so aus:

```{python}
#| eval: true
list_of_numbers = range(256)
print(list(list_of_numbers)) # <1>
```

1.  Mit der `list()`-Funktion wandeln wir die von `range()` erzeugte Folge in eine Liste um, die wir dann ausgeben können.

Rückwärts erreichen wir das gleiche Ergebnis mit einer weiteren Schleife, deren Folge wir umkehren, sodass sie von 255 bis 0 geht:

```{python}
for r in range(255, -1, -1):
    led.set_rgb_value(r, 0, 0)
```

<!--
\gloss{Argument}{Platzhalter für übergebene Werte einer Funktion}{Programmierung} 
-->

Warum hat `range()` auf einmal drei Argumente? Ganz einfach: Standardmäßig erstellt die Funktion eine Folge von 0 bis zur angegebenen Zahl minus eins. Wir können die Folge aber beeinflussen, indem wir einen Startwert und einen Schrittwert angeben. In unserem Fall oben beginnen wir bei 255 (erster Parameter) und gehen bis -1 (zweiter Parameter), wobei wir in jedem Schritt um -1 verringern (dritter Parameter). Warum zählen wir bis -1, wo wir doch eigentlich die 0 als kleinste Zahl benötigen? Das liegt daran, dass die Folge von `range()` immer bis zum zweiten Parameter minus eins geht. Wenn wir also 0 als kleinste Zahl benötigen, müssen wir bis -1 zählen.

Fassen wir unsere Erkenntnis zusammen und lassen die LED pulsieren:

```{python}
import time

# Increase red step by step
for r in range(256):
    led.set_rgb_value(r, 0, 0)
    time.sleep(0.001)

# Stay at full brightness for a bit
time.sleep(0.25)

# Decrease red step by step
for r in range(255, -1, -1):
    led.set_rgb_value(r, 0, 0)
    time.sleep(0.001)
```

Soweit bekannt? Fast – eine kleine Neuerung habe ich gerade eingebaut, nämlich die Funktion `time.sleep()`. Diese Funktion pausiert das Programm für die angegebene Zeit in Sekunden. In unserem Fall pausieren wir für 0,001 Sekunden, also 1 Millisekunde. Dadurch wird die LED langsamer heller und dunkler, was den Puls-Effekt verstärkt. Ohne diese Pause würde die LED so schnell aufleuchten, dass es für das menschliche Auge nicht mehr wahrnehmbar wäre. Tatsächlich würden wir auch die Hardware überfordern, weil die LED gar nicht so schnell die Farbe wechseln kann. Das Programm würde abstürzen.

Am Höhepunkt warten wir erneut – dieses Mal eine Viertelsekunde –, bevor wir die LED langsam ausgehen lassen und den Rotanteil schrittweise wieder auf Null setzen. Dann endet unser Programm, leider viel zu früh. Die LED soll doch eigentlich weiter pulsieren, bis ... ja, bis wann überhaupt?

### Bedingte Wiederholungen

<!-- \gloss{While-Schleife}{Wiederholung von Programmcode, solange eine Bedingung erfüllt ist}{Programmierung} -->

Beim Lösen von Problemen stoßen wir häufig auf Situationen, in denen wir bestimmte Schritte wiederholt ausführen möchten, aber nur unter bestimmten Bedingungen. Hier kommen bedingte Wiederholungen ins Spiel, die es uns ermöglichen, Schleifen zu erstellen, die nur dann fortgesetzt werden, wenn eine bestimmte Bedingung noch erfüllt ist.

Das können wir auf unsere pulsierende LED anwenden. Sie soll ihren Pulsierzyklus Dunkel–Hell–Dunkel wiederholen, solange der Benutzer nicht unterbricht. Das ist zumindest ein pragmatisches Abbruchkriterium für unseren Fall. Wir definieren also hier keine feste Anzahl Wiederholungen wie bei der `for ... in`-Schleife, sondern wir wollen festlegen, unter welcher *Bedingung* die Schleife fortgesetzt wird. Wir könnten also sagen: *solange* die Bedingung X erfüllt ist, wiederhole die aufgeführten Schritte. Und weil Programmiersprachen für Menschen gemacht sind, klingt es im echten Programm auch so ähnlich:

```{python}
while 1==1:
    print("This condition is always true")
    time.sleep(1)
```

Das Schlüsselwort `while` führt eine bedingte Schleife ein, gefolgt von der \gloss{Bedingung}{Aussage, die wahr oder falsch sein kann und die Ausführung von Code steuert}{Programmierung}, die die Schleife steuert. Die Bedingung wird vor jedem neuen Schleifendurchlauf geprüft (auch vor dem ersten) und sollte sie falsch (`false`) sein, wird die Schleife beendet.

Wann wird die Schleife oben also beendet? Richtig – niemals. Die Bedingung `1==1` ist immer wahr, die Schleife läuft somit endlos. Wir sprechen auch von einer Endlosschleife, die wir in der Programmierung unbedingt vermeiden wollen, es sei denn, sie ist explizit gewollt und nicht versehentlich entstanden. Das kurze Programm oben schreibt also in Abständen von einer Sekunde den Text "This condition is always true" auf die Konsole.

Eine Bedingung ist in Python und anderen Programmiersprachen ein wichtiges Konzept, das es uns ermöglicht, Entscheidungen zu treffen und den Programmfluss zu steuern. In unserem Fall könnte die Bedingung lauten: *solange der Benutzer nicht stoppt, wiederhole den Pulsierzyklus*. Eine Bedingung hat die Eigenschaft, dass sie jederzeit ausgewertet werden kann und entweder den Wert wahr (true) oder falsch (false) annimmt. Wie aber drücken wir das in Python aus?

```{python}
while True:
    print("I will loop forever")
    time.sleep(1)
```

Die einfachste Möglichkeit ist es, das Ergebnis der Evaluation direkt hinzuschreiben. Die obige Schleife prüft in jedem Durchgang, ob der Wert `True` wahr ist - was er natürlich ist. Das ist also so ähnlich wie bei der Schleife weiter oben, die die Bedingung `1==1` geprüft hat. Die ist ebenfalls immer `True` oder wahr.

Wir lernen im Laufe des Buches noch viele echte Bedingungen kennen, deren Ergebnis nicht von Vornherein bekannt ist. Für unsere pulsierende LED reicht es aber aus, wenn wir eine gewollte Endlosschleife verwenden. Denn auch eine Endlosschleife können wir jederzeit verlassen, indem wir das Programm mit der Tastenkombination Strg+C abbrechen.

Wenn wir jetzt unseren Pulsierzyklus von oben in die neue bedingte `while`-Schleife einfügen, sind wir schon am Ziel. Der Pulsierzyklus wird wiederholt, solange das Programm nicht abgebrochen wird:

```{python}
while True:

    # Increase red step by step
    for r in range(256):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full brightness for a bit
    time.sleep(0.25)

    # Decrease red step by step
    for r in range(255, -1, -1):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full dark for a bit
    time.sleep(0.25)
```

Der Vollständigkeit halber das Ganze inklusive des [Boilerplate-Codes](#boilerplate-code) für die Verbindung zu den Tinkerforge-Geräten:

```{python}
#| lst-label: lst-pulse-program
#| lst-cap: Das fertige Programm, das die LED rot pulsieren lässt.
import time
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223) 
led = BrickletRGBLEDV2('ZEP', ipcon)

# Turn LED off initially
led.set_rgb_value(0, 0, 0)

while True:

    # Increase red step by step
    for r in range(256):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full brightness for a bit
    time.sleep(0.25)

    # Decrease red step by step
    for r in range(255, -1, -1):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full dark for a bit
    time.sleep(0.25)
```

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_01/1_4_pulsating_led.py).
:::

## Farbkreise {#sec-colors-hue-circle .collapsable}

Das RGB-Farbschema ist für Computer optimal, weil sich damit mit nur drei Zahlen jede beliebige Farbe kodieren lässt. Zahlen sind schließlich die Sprache, mit der Computer am besten umgehen können. Für uns Menschen ist dieses Schema jedoch weniger intuitiv. Oder könntet ihr auf Anhieb sagen, welche Farbe hinter der Kombination (67, 201, 182) steckt?

Um Farben für uns leichter wählbar zu machen, wurde der sogenannte \gloss{Hue-Farbkreis}{Kreis, der Farben nach ihrem Farbton anordnet}{Codesysteme} entwickelt. Er ordnet die Farben auf einer Skala von 0 bis 360 Grad an – ähnlich wie die Winkel auf einem Kreis. Neben dem Farbton (Hue) lassen sich zusätzlich die Sättigung und die Helligkeit einstellen: Der Farbton bestimmt die eigentliche Farbe, die Sättigung, wie kräftig oder blass sie wirkt, und die Helligkeit, wie hell oder dunkel sie erscheint.

::: {.content-visible when-format="html"}
![Die Farbauswahl in Google Slides funktioniert über den Hue-Farbkreis.](images/hue_color_picker.gif){#fig-hue-color-picker .lightbox fig-align="center" width="33%"}
:::

::: {.content-hidden when-format="html"}
![Die Farbauswahl in Google Slides funktioniert über den Hue-Farbkreis.](images/hue_color_picker_still.png){.lightbox fig-align="center" width="33%"}
:::

In @fig-hue-color-picker seht ihr, wie die Farbauswahl in Google Slides funktioniert. Mit dem Slider in der Mitte bestimmt ihr den Farbton. Habt ihr einen passenden Ton gefunden, könnt ihr im Rechteck darüber durch Verschieben des kleinen Kreises die Sättigung und Helligkeit anpassen.

Beobachtet ihr dabei die RGB-Werte, erkennt ihr die Systematik der Farbton-Skala: Ausgehend von reinem Rot wird Schritt für Schritt Grün hinzugefügt – so entstehen Orange und Gelb. Danach nimmt der Rotanteil ab, während Blau hinzukommt. Über Cyan gelangen wir zu reinem Blau. Schließlich wird wieder Rot beigemischt, wodurch Violett bis Pink entstehen. Auf diese Weise bildet der Kreis den gesamten Regenbogen ab.

Da die Skala am Ende wieder bei Rot ankommt, lässt sich der Farbverlauf nahtlos wiederholen – ohne harte Übergänge. Genau deshalb wird der Hue-Verlauf meist als Kreis dargestellt.

![Der Hue-Farbkreis mit HSV-Werten.](images/hue_color_circle_hsv.png){#fig-hue-color-circle .lightbox fig-align="center" width="50%"}

@fig-hue-color-circle zeigt den Hue-Farbkreis im \gloss{HSV-Modell}{Farbmodell, das Farben durch Farbton, Sättigung und Helligkeit beschreibt}{Codesysteme}. HSV steht für Hue, Saturation, Value (Farbton, Sättigung, Helligkeit). Der Wert Value gibt die Helligkeit auf einer Skala von 0 bis 100 % an. Im Bild ist die Helligkeit konstant bei 100 %, während die Sättigung von innen nach außen zunimmt. In der Mitte sehen wir deshalb Weiß, während am äußeren Rand die Farben ihre volle Intensität haben.

Wenn wir ein Programm schreiben, das die gesamte Hue-Farbskala durchläuft und die LED jeweils in der passenden Farbe aufleuchten lässt, erhalten wir unser Regenbogenprogramm. Da die LED RGB-Werte benötigt, müssen wir den Verlauf des Hue-Farbkreises in RGB umsetzen. Ein Blick auf die Animation in @fig-hue-color-picker hilft: Der Farbverlauf lässt sich in sechs Phasen unterteilen, wie @fig-hue-rgb-diagram zeigt:

1.  Rot = 255, Blau = 0, Grün steigt linear
2.  Rot sinkt linear, Grün = 255, Blau = 0
3.  Rot = 0, Grün = 255, Blau steigt linear
4.  Rot = 0, Grün sinkt linear, Blau = 255
5.  Rot steigt linear, Grün = 0, Blau = 255
6.  Rot = 255, Grün = 0, Blau sinkt linear

Dann beginnt der Zyklus von vorn.

![Der Hue-Farbverlauf mit den Veränderungen der RGB-Werte (Quelle: [Ronja's Tutorials](https://www.ronja-tutorials.com/post/041-hsv-colorspace/)).](images/hue_rgb_diagram.png){#fig-hue-rgb-diagram .lightbox fig-align="center" width="75%"}

## Regenbogen-LED {#sec-colors-rainbow-led .collapsable}

<!-- \gloss{For-Schleife}{Wiederholung mit Zähler, s. Zählerschleife}{Programmierung} -->

Mit dem Wissen können wir uns an das erklärte Ziel unseres Experiments machen: die LED nacheinander in allen Farben des Regenbogens aufleuchten zu lassen. Beginnen wir mit der ersten Phase und schreiben dafür ein Python-Programm:

```{python}
for green in range(256):
    led.set_rgb_value(255, green, 0)
    time.sleep(0.01)
```

Weil wir genau wissen, wie oft wir die Schleife durchlaufen wollen, verwenden wir eine `for`-Schleife. Innerhalb der Schleife erhöhen wir die Variable `green` jeweils um 1, was effektiv den Grünanteil unseres RGB-Wertes erhöht. Mit jedem Durchlauf fügen wir somit mehr Grün hinzu, während Rot und Blau konstant bleiben. Phase 1 ist damit abgeschlossen – machen wir weiter mit Phase 2:

```{python}
for red in range(255, -1, -1):
    led.set_rgb_value(red, 255, 0)
    time.sleep(0.01)
```

Wie wir mit einer `for`-Schleife rückwärts zählen, haben wir schon weiter oben kennengelernt. In Phase 2 verringern wir schrittweise den Rotanteil, während die anderen beiden Farben konstant bleiben. Damit kommen wir zu Phase 3:

```{python}
for blue in range(256):
    led.set_rgb_value(0, 255, blue)
    time.sleep(0.01)
```

Ich glaube, ihr habt das Prinzip verstanden. Indem wir die sechs Phasen jeweils in einer eigenen Schleife abarbeiten, erhalten wir das vollständige Regenbogenprogramm:

```{python}
# phase 1
for green in range(256):
    led.set_rgb_value(255, green, 0)
    time.sleep(0.01)

# phase 2
for red in range(255, -1, -1):
    led.set_rgb_value(red, 255, 0)
    time.sleep(0.01)

# phase 3
for blue in range(256):
    led.set_rgb_value(0, 255, blue)
    time.sleep(0.01)

# phase 4
for green in range(255, -1, -1):
    led.set_rgb_value(0, green, 255)
    time.sleep(0.01)

# phase 5
for red in range(256):
    led.set_rgb_value(red, 0, 255)
    time.sleep(0.01)

# phase 6
for blue in range(255, -1, -1):
    led.set_rgb_value(255, 0, blue)
    time.sleep(0.01)

```

Wie schön 🌈 Eine Sache fehlt aber noch.

### Runde für Runde

Der Regenbogen soll am Ende wieder von vorne beginnen. Wie schon beim Pulsieren der Farben können wir auch hier eine `while`-Schleife verwenden und die Phasen kontinuierlich abspielen – solange, bis der Benutzer die Escape-Taste drückt:

```{python}
while True:

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(0.01)

    # phase 2
    for red in range(255, -1, -1):
        led.set_rgb_value(red, 255, 0)
        time.sleep(0.01)

    # phase 3
    for blue in range(256):
        led.set_rgb_value(0, 255, blue)
        time.sleep(0.01)

    # phase 4
    for green in range(255, -1, -1):
        led.set_rgb_value(0, green, 255)
        time.sleep(0.01)

    # phase 5
    for red in range(256):
        led.set_rgb_value(red, 0, 255)
        time.sleep(0.01)

    # phase 6
    for blue in range(255, -1, -1):
        led.set_rgb_value(255, 0, blue)
        time.sleep(0.01)

```

Wir haben es fast geschafft! Eine Kleinigkeit wollen wir an unserem Programm noch verbessern.

### Geschwindigkeit steuern

Vielleicht habt ihr gemerkt, dass die Geschwindigkeit, mit der unsere LED den gesamten Regenbogen einmal durchläuft, nicht sehr hoch ist. Ich würde das gerne beschleunigen. Die Zeit steuern wir über die `time.sleep()`-Funktion, sodass wir einfach den Wert in jedem Funktionsaufruf verringern könnten. Das wäre aber nicht sehr effizient, weil wir ihn an sechs Stellen anpassen müssen. Wenn wir danach merken, dass es zu schnell ist, müssten wir den Wert erneut überall editieren. Das geht einfacher!

Der Trick liegt darin, den Wert für die Wartedauer als Variable zu definieren und nur an einer Stelle zu ändern.

```{python}
pause_duration = 0.01
while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # etc.
```

Schon besser! Wir gehen aber noch einen Schritt weiter. Statt dieses kleinteiligen Werts für eine Pause zwischen zwei kleinen Farbveränderungen möchte ich die Gesamtdauer für den Durchlauf eines Regenbogens angeben. Der Wert `pause_duration` soll dann auf dieser Basis errechnet werden. Dazu müssen wir nur die Anzahl der Pausen insgesamt kennen; in jeder der sechs Phasen sind es 256. Macht also:

$$
6 \times 256 = 1536
$$

Im Programm setzen wir die Pausendauer also auf die Gesamtdauer in Sekunden geteilt durch 1536:

```{python}
rainbow_duration = 5
pause_duration = rainbow_duration / 1536

while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # etc.
```

Und schon können wir unseren Regenbogen beliebig zeitlich steuern. Damit sind wir am Ende des Kapitels angekommen. Wir schließen es mit dem vollständigen Code für unseren Regenbogenverlauf in @lst-rainbow-program ab. Vergesst nicht, den Wert für die UID eurer LED anzupassen, damit es auch bei euch funktioniert:

```{python}
#| lst-cap: Das fertige Regenbogenprogramm.
#| lst-label: lst-rainbow-program
import time
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223) 
led = BrickletRGBLEDV2('ZEP', ipcon)

# Turn LED off initially
led.set_rgb_value(0, 0, 0)

rainbow_duration = 5
pause_duration = rainbow_duration / 1536

while True:

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # phase 2
    for red in range(255, -1, -1):
        led.set_rgb_value(red, 255, 0)
        time.sleep(pause_duration)

    # phase 3
    for blue in range(256):
        led.set_rgb_value(0, 255, blue)
        time.sleep(pause_duration)

    # phase 4
    for green in range(255, -1, -1):
        led.set_rgb_value(0, green, 255)
        time.sleep(pause_duration)

    # phase 5
    for red in range(256):
        led.set_rgb_value(red, 0, 255)
        time.sleep(pause_duration)

    # phase 6
    for blue in range(255, -1, -1):
        led.set_rgb_value(255, 0, blue)
        time.sleep(pause_duration)
```

::: callout-tip
Das Codebeispiel aus diesem Abschnitt findet ihr auf [GitHub](https://github.com/winf-hsos/hands-on-computer-science-code/blob/main/chapter_01/1_6_rainbow_led.py).
:::

Seid ihr bereit für das nächste Experiment?