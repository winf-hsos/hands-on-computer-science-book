---
abstract: |
    Das erste Kapitel hat es gleich in sich: Wir lernen etwas √ºber Farben und wie sie im Computer funktionieren. Gleichzeitig steigen wir in die Programmierung ein und schreiben unser erstes Programm. Dabei nutzen wir eine LED und erzeugen einen Regenbogenfarbverlauf.
abstract-title: ""
---

# Farben üåà {#sec-colors}

## Lernziele {.unnumbered}

Unsere wichtigsten Lernziele in diesem Kapitel sind:

1. Wir verstehen, wie Farben im Computer funktionieren.
2. Wir schreiben unser erstes Programm am Beispiel einer LED-Steuerung.
3. Wir lernen Schleifen in der Programmierung kennen.

## Experimentaufbau {.unnumbered}

Bereit f√ºr euer erstes Hardware-Experiment? Perfekt! Ihr braucht daf√ºr eine LED ([RGB LED Bricklet 2.0](https://www.tinkerforge.com/en/doc/Hardware/Bricklets/RGB_LED_V2.html)) und einen Mikrocontroller ([Master Brick 3.2](https://www.tinkerforge.com/de/shop/master-brick.html)). Befestigt beide Bauteile mit Abstandshaltern auf einer Montageplatte, wie in @fig-setup-rgb-led gezeigt. Zwei Schrauben pro Ger√§t reichen v√∂llig. Denkt an die kleinen, wei√üen Unterlegscheiben aus Kunststoff. Sie sch√ºtzen eure Platinen vor Druckstellen.

Neben der Hardware ben√∂tigt ihr auch die passende Software. Diese solltet ihr bereits installiert haben. Falls nicht, schaut im [Abschnitt zu den Voraussetzungen](prerequisites.qmd) vorbei. Dort ist alles genau beschrieben. Im Folgenden gehe ich davon aus, dass ihr alles am Laufen habt.

::: {#fig-setup-rgb-led layout="[[1], [1,1], [1,1]]"}

![Seitenansicht.](images/master_brick_with_led_01.jpg){#fig-setup-rgb-led-a .lightbox group="setup-rgb-led"}

![Nahaufnahme der LED.](images/master_brick_with_led_02.jpg){#fig-setup-rgb-led-b .lightbox group="setup-rgb-led"}

![Montageplatte mit allen Komponenten.](images/master_brick_with_led_03.jpg){#fig-setup-rgb-led-c .lightbox group="setup-rgb-led"}

![Untenansicht.](images/master_brick_with_led_04.jpg){#fig-setup-rgb-led-d .lightbox group="setup-rgb-led"}

![Ansicht der vier Steckpl√§tze.](images/master_brick_with_led_06.jpg){#fig-setup-rgb-led-e .lightbox group="setup-rgb-led"}

Einfaches Setup mit einem Mikrocontroller und einer LED.

:::

## Erste Schritte mit der LED

Im ersten Schritt wollen wir die LED und ihre Funktionen testen! Das geht ganz leicht mit dem Brick Viewer. Schlie√üt zuerst den Master Brick √ºber das USB-Kabel an euren Computer an und √∂ffnet den Brick Viewer. Klickt dann auf den Connect-Button.

![√úber den Connect-Button verbindet ihr den Brick Viewer mit dem angeschlossenen Master Brick.](images/brick_viewer_connect.png){#fig-brick-viewer-connect .lightbox fig-align="center" width="100%" group="brick-viewer"}

Wenn alles geklappt hat, zeigt euch der Brick Viewer alle angeschlossenen Ger√§te in Tabs an. Schaut euch @fig-brick-viewer-after-connect an ‚Äì so etwa sollte es aussehen.

![Der Brick Viewer nachdem ihr mit dem Master Brick verbunden seid.](images/brick_viewer_after_connect.png){#fig-brick-viewer-after-connect .lightbox group="brick-viewer"}

Wechselt nun zum Tab der RGB LED. Hier k√∂nnt ihr √ºber unterschiedliche Wege die Farbe der LED einstellen. Mehr kann eine LED nicht!

Mit den drei Schiebereglern steuert ihr die einzelnen Farbkan√§le ‚Äì Rot, Gr√ºn, Blau. Der Wertebereich: 0 bis 255. Warum gerade diese die Farben und Zahlen? Gute Frage. Die Antwort kommt weiter unten.

![Die Ansicht f√ºr die RGB LED im Brick Viewer, in der ihr alle Funktionen per Klick im Zugriff habt.](images/brick_viewer_rgb_led_button.png){#fig-brick-viewer-rgb-led .lightbox group="brick-viewer"}

Fazit: Der Brick Viewer ist top zum Rumprobieren. Aber wenn ihr echte Projekte umsetzen wollt, m√ºsst ihr programmieren lernen. Also los!

## Unser erstes Programm

Wie verbinden wir uns √ºber Programm mit der LED und setzen ihre Farbe? Die Antwort darauf findet ihr im folgenden kurzen Codebeispiel.

```{python}
#| lst-label: lst-boilerplate-code
#| lst-cap: Der Boilerplate-Code f√ºr die Verbindung mit den Ger√§ten am Beispiel der RGB LED.

from tinkerforge.ip_connection import IPConnection # <1>
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2 # <2>

ipcon = IPConnection() # <3>
ipcon.connect("localhost", 4223) # <4>
led = BrickletRGBLEDV2("ZEP", ipcon) # <5>
```

1.  Hier importieren wir ein Objekt aus einer Bibliothek zum Herstellen einer Verbindung mit dem Master Brick.
2.  Hier importieren wir ein weiteres Objekt, das wir zur Darstellung der LED als Python-Objekt ben√∂tigen.
3.  Die Verbindung erfolgt √ºber eine sogenannte IP-Verbindung, die wir hier als Objekt erstellen.
4.  Mit `connect` stellen wir eine Verbindung zum angeschlossenen Master Brick her.
5.  Schlie√ülich holen wir uns eine virtuelle Instanz des RGB LED Bricklets, indem wir die UID nennen und sagen, welche Verbindung (`ipcon`) genutzt werden soll.

### Programme

Zun√§chst kl√§ren wir den Begriff *Programm*\index{Programm}. Ein Programm ist eine Abfolge von Anweisungen, die ein Computer ausf√ºhrt, um eine bestimmte Aufgabe zu erledigen. In unserem Fall ist das Programm sp√§ter daf√ºr zust√§ndig, mit der LED zu interagieren und sie in verschiedenen Farben leuchten zu lassen. Programme werden in Programmiersprachen geschrieben, die es uns erm√∂glichen, dem Computer pr√§zise Anweisungen zu geben. Wir verwenden in diesem Buch die Programmiersprache Python, die sich besonders gut f√ºr Einsteiger eignet und gleichzeitig m√§chtig genug ist, um komplexe Aufgaben zu l√∂sen.

Wenn wir ein Programm ausf√ºhren, arbeitet der Computer die Anweisungen Schritt f√ºr Schritt von oben nach unten ab. Die Nummerierung der Zeilen verdeutlicht das sehr sch√∂n. Der Computer beginnt bei Zeile 1 und arbeitet die Befehle Zeile f√ºr Zeile bis nach unten ab. 

Es gibt Befehle, die den Computer von dieser linearen Abfolge abweichen lassen, etwa Schleifen oder Verzweigungen. Diese lernen wir sp√§ter kennen.

### Boilerplate Code

Der Codeausschnitt in @lst-boilerplate-code wird uns im Verlauf dieses Buches immer wieder begegnen. Wir ben√∂tigen ihn, um uns am Anfang des Programms mit den Ger√§ten zu verbinden, die wir f√ºr unsere Anwendung ben√∂tigen. In der Informatik nennen wir solchen Code, den wir h√§ufig in der gleichen Form ben√∂tigen und fast eins zu eins kopieren k√∂nnen, auch *Boilerplate-Code*. Wundert euch also nicht, wenn ich diesen Begriff ab und an mal verwende. Jetzt wisst ihr, was gemeint ist.

### Bibliotheken

Beginnen wir in den ersten beiden Zeilen. Hier seht ihr zwei sehr √§hnliche Befehle, die mit dem Schl√ºsselwort `from` beginnen. Nach dem Schl√ºsselwort `from` folgt der Name einer Bibliothek, aus der wir ein f√ºr unser Programm ben√∂tigtes Objekte importieren. Die Kombination der Schl√ºsselw√∂rter `from ...import` l√§sst sich also w√∂rtlich √ºbersetzen: "Aus der Bibliothek X importiere das Objekt Y".

Eine *Bibliothek*\index{Bibliothek} in einer Programmiersprache ist die B√ºndelung und Bereitstellung von Funktionen, Klassen oder Konstanten. Eine Bibliothek k√∂nnt ihr euch vorstellen wie einen Werkzeugkasten: Sie enth√§lt fertige Werkzeuge (Funktionen und Klassen), damit ihr nicht alles von Grund auf selbst programmieren m√ºsst. Tinkerforge stellt uns genau solche Werkzeuge bereit, damit wir schnell und unkompliziert mit den Ger√§ten loslegen k√∂nnen. F√ºr jedes Ger√§t gibt es in der Tinkerforge-Bibliothek eine eigene Klasse, √ºber die wir auf die Funktionen jedes Ger√§ts zugreifen k√∂nnen.

### Klassen und Objekte

Mit `from ... import` importieren wir also etwas aus einer Bibliothek. Soweit so gut. Aber was bedeutet das genau? Mit *importieren* ist konkret gemeint, dass wir dem Programm mitteilen, dass wir vorhaben, die genannten Dinge in unserem Programm zu verwenden, und dass sie deshalb am besten schon einmal geladen werden sollten. Ob wir diese Dinge sp√§ter wirklich nutzen steht auf einem anderen Blatt.

In dem Fall der ersten beiden Zeilen unseres Programms von oben sind es zwei *Klassen*\index{Klasse}, deren Verwendung wir ank√ºndigen. Die erste Klasse heisst `IPConnection`\index{`IPConnection`} und die zweite `BrickletRGBLEDV2`\index{`BrickletRGBLEDV2`}. Der Begriff *Klasse* ist hier analog zum Begriff *Kategorie* zu verstehen. Wir k√∂nnen zu einer Klasse geh√∂rige *Objekte*\index{Objekt} erzeugen, und alle Objekte der selben Klasse verhalten sich gleich und haben die gleichen Funktionen. Das verstehen wir am besten an einem einfachen Beispiel.

Stellt euch vor, ihr habt eine Klasse namens `Auto`. Diese Klasse beschreibt alle Eigenschaften und Funktionen, die ein Auto haben kann, wie etwa `fahren()`, `bremsen()` oder `tanken()`. Diese Dinge sollen f√ºr jedes Auto gleich ablaufen. Jedes konkrete Auto in der Welt ist ein Objekt dieser Klasse. Wir k√∂nnen also sagen: "Mein Auto ist ein Objekt der Klasse `Auto`." Jedes `Auto` hat neben den Funktionen die gleichen Eigenschaften wie Farbe, Marke und Modell. Aber jedes Auto kann andere Werte f√ºr diese Eigenschaften haben.

Genauso verh√§lt es sich mit den Klassen, die Tinkerforge f√ºr uns bereitgestellt hat. Die Klasse `IPConnection` beschreibt, wie wir eine Verbindung zu einem Mikrocontroller herstellen k√∂nnen, und die Klasse `BrickletRGBLEDV2` beschreibt, wie wir mit der LED interagieren k√∂nnen. Wenn wir ein Objekt dieser Klasse erstellen, k√∂nnen wir alle Funktionen nutzen, die in der Klasse definiert sind. Eine LED muss nicht fahren oder bremsen wie ein Auto. Daf√ºr hat sie andere Funktionen, wie etwa `set_rgb_value()`, die uns erlaubt, die Farbe der LED zu √§ndern. Eine Eigenschaft jeder LED ist ihre UID, die eindeutig ist und uns hilft, sie im System zu identifizieren.

### Schl√ºsselw√∂rter

Soeben haben wir mit `from` und `import` unsere ersten beiden Schl√ºsselw√∂rter\index{Schl√ºsselwort} in Python kennengelernt! Aber was bedeutet das genau? Ein Schl√ºsselwort, das wir im Englischen auch *keyword* oder *reserved keyword* nennen, ist ein Begriff, der in der jeweiligen Programmiersprache eine feste Bedeutung hat und deshalb nicht anderweitig verwendet werden darf. Wir werden gleich noch sehen, dass wir bei der Programmierung auch h√§ufig Namen vergeben m√ºssen, etwa f√ºr Variablen oder Funktionen. Diese Namen d√ºrfen nicht wie ein Schl√ºsselwort lauten, ansonsten funktioniert unser Programm nicht wie gew√ºnscht. Welche Schl√ºsselw√∂rter es in Python gibt, k√∂nnt ihr [hier](https://docs.python.org/3/reference/lexical_analysis.html#keywords "Reservierte Schl√ºsselw√∂rter in Python") nachschauen.

Im Codeausschnitt oben laden wir zuerst das Objekt f√ºr die Verbindung zum angeschlossenen Mikrocontroller, die √ºber eine IP-Verbindung hergestellt wird. Was das genau ist? Sp√§ter mehr dazu. Zus√§tzlich zur `IPConnection` laden wir anschlie√üend noch die ben√∂tigen Klassen f√ºr die Ger√§te, die wir in unserem aktuellen Setup verwenden wollen. In diesem Kapitel ist das nur die LED, in sp√§teren Experimenten werden es auch mal mehrere Ger√§te sein.

### Objekte erzeugen

In @lst-boilerplate-code in Zeile 4 erzeugen wir ein Objekt\index{Objekt} der Klasse `IPConnection`. Die fertige Instanz\index{Objektinstanz} - so nennen wir ein Objekt, das aus einer Klasse erzeugt wurde - speichern wir auf einer *Variable* mit dem Namen `ipcon`. Diesen Namen haben wir uns selbst ausgedacht, damit wir sp√§ter darauf zugreifen k√∂nnen. Wir h√§tten auch einen anderen Namen w√§hlen k√∂nnen.Eine Variable ist also ein Platzhalter f√ºr einen Wert, den wir sp√§ter im Programm verwenden wollen. In diesem Fall ist `ipcon` der Platzhalter f√ºr die Verbindung zu unserem Mikrocontroller. Was eine Variable technisch ist, lernen wir sp√§ter noch genauer kennen.

### Methoden

√úber das Objekt `ipcon` k√∂nnen wir nun eine Verbindung zu unserem Mikrocontroller herstellen. Das geschieht in Zeile 5 mit der Methode `connect()`. Eine *Methode*\index{Methode} ist eine Funktion, die zu einem Objekt geh√∂rt. Wie etwa `fahren()` oder `bremsen()` in unserem Auto-Beispiel.

Wir k√∂nnen Methoden aufrufen, um eine bestimmte Aktion auszuf√ºhren. In diesem Fall stellen wir eine Verbindung zum Mikrocontroller her, indem wir die Adresse und den Port angeben, √ºber den die Verbindung hergestellt werden soll. In unserem Fall ist das "localhost", was f√ºr die lokale Maschine steht, und Port 4223, der durch den Brick Daemon standardm√§√üig so konfiguriert ist. Der Aufruf einer Methode erfolgt immer mit dem Punkt `.` nach dem Objekt, gefolgt vom Namen der Methode und den Klammern `()`, in denen wir eventuell ben√∂tigte Parameter angeben.

Eine Methode ist letztlich eine Funktion, die zu einem Objekt geh√∂rt. Zu einem sp√§teren Zeitpunkt schreiben wir unsere eigenen Funktionen und lernen dann noch viel mehr dar√ºber.

### Ein Objekt f√ºr die LED

In Zeile 6 erzeugen wir schlie√ülich ein Objekt der Klasse `BrickletRGBLEDV2`. Dieses Objekt repr√§sentiert unsere LED und erm√∂glicht es uns, mit ihr zu interagieren. Wir nennen das Objekt `led`, was kurz und klar ist. Auch hier haben wir uns den Namen selbst ausgedacht, um sp√§ter darauf zugreifen zu k√∂nnen. Auch wenn wir grunds√§tzlich Variablennamen frei w√§hlen k√∂nnen, sollten sie immer so gew√§hlt werden, dass sie den Inhalt der Variable beschreiben. Das macht es sp√§ter einfacher, den Code zu verstehen. Gleichzeitig gibt es in Python einige Regeln, die wir bei der Benennung von Variablen beachten m√ºssen. Dazu geh√∂ren etwa, dass Variablennamen nicht mit einer Zahl beginnen d√ºrfen und keine Leerzeichen enthalten d√ºrfen. Eine ausf√ºhrliche Liste der Regeln findet ihr [hier](https://docs.python.org/3/reference/lexical_analysis.html#identifiers "Regeln f√ºr Variablennamen in Python").

### Zusammenfassung unseres ersten Programms

Damit haben wir unser erstes Programm von oben nach unten erl√§utert und dabei schon viele wichtige Konzepte der Programmierung kennengelernt:

|  |  |
|----------------------|--------------------------------------------------|
| **Programme** | Abfolge von Anweisungen, die nacheinander ausgef√ºhrt werden. |
| **Boilerplate Code** | Standard-Code, den man immer wieder braucht. |
| **Importieren von Bibliotheken** | Sammlung von fertigen Code-Elementen. |
| **Schl√ºsselw√∂rter** | Reservierte Begriffe der Programmiersprache. |
| **Klassen und Objekte** | Kategorien und deren konkrete Instanzen. |
| **Methoden und Funktionen** | Funktionen, die zu einem Objekt geh√∂ren. |
| **Variablen** | Platzhalter f√ºr Werte. |

### Und jetzt?

Wir haben nun eine digitale Repr√§sentation unserer LED in Python. Wir k√∂nnen die LED jetzt zum Leuchten bringen, indem wir eine Methode der Klasse `BrickletRGBLEDV2`, die `set_rgb_value()` hei√üt, verwenden. Diese Methode erwartet drei Parameter: Rot, Gr√ºn und Blau. Mit diesen Parametern k√∂nnen wir die Farbe der LED einstellen.

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 255, 0) # <1>
```
1. Setzt die LED auf gr√ºn. R = 0, G = 255, B = 0. Logisch, oder?

Moment mal ‚Ä¶ Wo steht hier eigentlich *gr√ºn*? Steht da gar nicht. Stattdessen drei Zahlen. Willkommen bei der *RGB-Farbkodierung*\index{RGB-Farbkodierung}. Jede Farbe besteht aus drei Werten zwischen 0 und 255: Rot, Gr√ºn, Blau. Null ist nix. 255 ist volle Power. Alles 0? Schwarz. Alles 255? Wei√ü. Nur Gr√ºn auf 255? Na klar: gr√ºn.

Aber warum machen wir das mit Zahlen? Weil Computer nun mal mit Zahlen arbeiten. Das ist einer der zentralen Gedanken dieses Buches: Wie √ºbersetzen wir die Welt in etwas, das ein Computer versteht?

Warum aber ist das so? Warum kodieren wir in der Informatik jede Farbe mit *drei* Zahlen? Warum √ºberhaupt mit Zahlen? Hier kommen wir zu einer zentralen Frage dieses Buches: Wie bilden Computer Informationen ab?

Vorher m√ºssen wir aber kurz zur√ºck in die Schule.

## Farben und Licht

Physik ist vielleicht schon eine Weile her. Erinnern wir uns dennoch kurz, was Licht ist und wie Farben damit zusammenh√§ngen. Licht ist *elektromagnetische Strahlung*\index{elektromagnetische Strahlung}. Das bedeutet, es handelt sich um gekoppelte Schwingungen elektrischer und magnetischer Felder, die sich mit Lichtgeschwindigkeit ausbreiten. Vereinfacht k√∂nnen wir uns Licht als Wellen vorstellen, die sich durch den Raum bewegen. Diese Wellen haben unterschiedliche Frequenzen und Wellenl√§ngen. Das sichtbare Licht ist nur ein kleiner Teil des gesamten elektromagnetischen Spektrums, das von Radiowellen √ºber Infrarotstrahlung bis hin zu R√∂ntgenstrahlen und Gammastrahlen reicht.

Bei Wellen unterscheiden wir zwischen der Frequenz (wie oft die Welle pro Sekunde schwingt) und der Wellenl√§nge (der Abstand zwischen zwei aufeinanderfolgenden Wellenbergen). Die Frequenz und die Wellenl√§nge sind umgekehrt proportional: Je h√∂her die Frequenz, desto k√ºrzer die Wellenl√§nge und umgekehrt.

Frequenzen messen wir in Hertz (Hz), wobei 1 Hz einer Schwingung pro Sekunde entspricht. Das sichtbare Licht hat Frequenzen im Bereich von etwa 430 THz (Terahertz) bis 750 THz. Die Wellenl√§ngen des sichtbaren Lichts liegen zwischen etwa 400 nm (Nanometer) f√ºr violettes Licht und etwa 700 nm f√ºr rotes Licht. Um sich das vorzustellen: Ein Nanometer ist ein Milliardstel Meter. Zum Vergleich: Ein menschliches Haar hat einen Durchmesser von etwa 80.000 bis 100.000 Nanometern. Die Abst√§nde zwischen den Wellenl√§ngen des sichtbaren Lichts sind also extrem klein.

Was bedeutet das nun f√ºr eine LED? Eine LED (Light Emitting Diode) ist ein Halbleiterbauelement, das Licht erzeugt, wenn elektrischer Strom hindurchflie√üt. Die Farbe des Lichts h√§ngt von Eigenschaften des Halbleitermaterials ab, aus dem die LED besteht. Verschiedene Materialien emittieren Licht bei unterschiedlichen Wellenl√§ngen, was zu verschiedenen Farben f√ºhrt. Zum Beispiel emittiert eine rote LED Licht mit einer Wellenl√§nge von etwa 620-750 nm, w√§hrend eine gr√ºne LED Licht mit einer Wellenl√§nge von etwa 495-570 nm emittiert.

![Das elektromagnetische Spektrum, wovon das sichtbare Licht ein kleiner Teil ist. (Quelle: [Wikipedia](https://en.wikipedia.org/wiki/File:EM_Spectrum_Properties_edit.svg))](images/em_spectrum.png){#fig-em-spectrum fig-align="center" width="100%"}


Die RGB LED besteht in Wirklichkeit aus drei einzelnen LEDs: einer roten, einer gr√ºnen und einer blauen. Jede dieser LEDs kann unabh√§ngig voneinander angesteuert werden, um verschiedene Farben zu erzeugen. Mehr Stromst√§rke bedeutet mehr Intensit√§t der jeweiligen Farbe. Durch die Kombination der drei Grundfarben Rot, Gr√ºn und Blau in unterschiedlichen Intensit√§ten k√∂nnen wir eine Vielzahl von Farben mischen. Das ist das Prinzip der additiven Farbmischung: Wenn wir alle drei Farben mit voller Intensit√§t leuchten lassen, erhalten wir Wei√ü. Wenn wir keine Farbe leuchten lassen, erhalten wir Schwarz. Klar, die LED sind dann alle aus.

## Farben im Computer

Nun wissen wir, warum die Methode `set_rgb_value()` drei Parameter erwartet: Rot, Gr√ºn und Blau. Diese Parameter sind die Intensit√§ten der jeweiligen Farbe, die wir in unserem Programm angeben. Mit den Werten 0 bis 255 k√∂nnen wir jede Farbe im sichtbaren Spektrum erzeugen.

Wie kommt es aber zu der merkw√ºrdigen Zahl 255? Warum nicht einfach 0 bis 100? Das liegt daran, wie ein Computer grunds√§tzlich Werte speichert und wie dieser Speicher organisiert ist. Kurz gesagt: Der Wertebereich 0 bis 255 passt genau in ein sogenanntes *Byte*\index{Byte}. Ein Byte ist eine Speichereinheit, die aus 8 Bits besteht. Ein Bit kann entweder 0 oder 1 sein. Mit 8 Bits k√∂nnen wir also $2^8 = 256$ verschiedene Werte darstellen, von 0 bis 255. Das ist genau der Bereich, den wir f√ºr die RGB-Farbkodierung verwenden. Dazu lernen wir sp√§ter noch mehr.

Wir halten also fest, dass sich ein Farbwert im Computer aus drei Zahlen zusammensetzt, die jeweils zwischen 0 und 255 liegen. Das gilt f√ºr unsere LED, aber auch f√ºr Pixel in TVs, Smartphones, digitalen Foto oder Monitoren. All diese Dinge beleuchten wir sp√§ter noch genauer.

## Farben mischen

Klingt alles theoretisch sehr gut. Aber wie sieht es mit der Praxis aus? Probieren wir es aus und mischen zwei Farben mit voller Intensit√§t!

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 255, 0)
```

Was macht der Befehl? Welche Farbe kommt dabei heraus? Probiert es einfach mal aus!

### Additive Farbmischung

Ihr solltet alle eure LEDs in Gelb aufleuchten sehen. In der *additiven Farbmischung* mischen wir Rot und Gr√ºn und erhalten dadurch Gelb. Gelb ist heller als die beiden Farben Rot und Gr√ºn, was kein Zufall ist. Das ist das Prinzip der additiven Farbmischung: Wenn wir zwei Farben mit voller Intensit√§t leuchten lassen, erhalten wir eine neue Farbe, die stest heller ist als die Ursprungsfarben. Wir f√ºgen mehr Licht hinzu. Wenn wir alle drei Farben mit voller Intensit√§t mischen erhalten wir schlie√ülich Wei√ü.

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 255, 255)
```

Am anderen Ende des Spektrums erzeugen drei Nullen die Farbe Schwarz:

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 0, 0)
```

### Subtraktive Farbmischung

Ihr k√∂nnt euch merken, dass wir im Kontext von Computern oft von *additiver Farbmischung* sprechen, weil Bildschirme Licht erzeugen. Durch das Mischen der drei Farbkan√§le entstehen neue Farben gem√§√ü der additiven Farbmischung, also stets heller als ihre Grundfarben. Daneben gibt es aber noch die subtraktive Farbmischung. Sie funktioniert anders, n√§mlich genau umgekehrt. Statt beim Mischen Licht hinzuzuf√ºgen, nehmen wir Licht weg.

Erinnert ihr euch an euren Farbkasten aus der Grundschule? Dort habt ihr auch Farben gemischt, um neue Farben zu erzeugen, die euer Farbkasten nicht direkt mitgeliefert hat. Was hat im Farbenkasten die Mischung aus Rot und Gr√ºn ergeben? Sicher nicht Gelb - eher Braun. Eine dunklere Farbe. Das liegt daran, dass wir es hier nicht mit additiver, sondern mit subtraktiver Farbmischung zu tun haben. Bei der subtraktiven Farbmischung mischen wir Pigmente, die Licht *absorbieren* und *reflektieren*. Das Mischen von Farben fungiert hier wie ein Filter: Bestimmte Teile des Lichtspektrums werden nicht mehr reflektiert, sondern absorbiert und sind damit nicht mehr sichtbar. Das Ergebnis einer Mischung zweier Farben ergibt in der subtraktiven Farbmischung also stets eine dunklere Farbe. Genau umgekehrt zur additiven Farbmischung.

Was passiert mit dem absorbierten Licht? Es wird in eine andere Form der Energie umgewandelt, n√§mlich W√§rme. Deshalb wird eine schwarze Oberfl√§che auch besonders hei√ü, wenn die Sonne darauf knallt. Sie absorbiert das gesamte Lichtspektrum und wandelt es in W√§rme um. Dagegen wirken wei√üe Oberfl√§chen fast wie Klimaanlagen. Es ist kein Zufall, dass wir in sonnigen Erdteilen viele wei√üe Fassaden sehen.

Wenn wir alle Farben mischen ergibt die subtraktive Farbmischung Schwarz, weil kein Licht mehr reflektiert wird. Alles Licht wird aufgesogen und nichts kommt mehr zur√ºck. Das ist ein anderes Prinzip als bei der additiven Farbmischung, bei der wir Lichtquellen *kombinieren*, um neue Farben zu erhalten.

::: {#fig-color-mixing layout="[[1,1]]"}

![Additive Farbmischung](images/additive_color_mixing.png){#fig-additive-color-mixing .lightbox}

![Subtraktive Farbmischung](images/subtractive_color_mixing.png){#fig-subtractive-color-mixing .lightbox}

Additive und subtraktive Farbmischung.

:::

In @fig-color-mixing sehen wir die beiden Farbmischungsarten im Vergleich. In @fig-subtractive-color-mixing sehen wir die drei Grundfarben, die wir bei der subtraktiven Variante ben√∂tigen, um daraus alle weiteren Farben zu erhalten. Das sind Cyan, Magenta sowie Gelb. Im Englischen ist die Abk√ºrzung CMY, wo das "Y" f√ºr *Yellow* steht. In der additiven Farbmischung sind es, wie oben schon gesehen, Rot, Gr√ºn und Blau. Wenn ihr @fig-additive-color-mixing betrachtet dann erkennt ihr, dass genau diese drei Farben durch das Mischen jeweils zweier Grundfarben in der additiven Farbmischung entstehen. Und umgekehrt gilt das gleiche Prinzip! Ob das Zufall ist?

In der additiven Farbmischung entsteht Gelb durch das Mischen von Rot und Gr√ºn, wobei Blau fehlt. Im Umkehrschluss bedeutet das: Gelbes Licht enth√§lt keine blaue Komponente, es reflektiert also kein Blau. In der subtraktiven Farbmischung (wie beim Farbkasten) wird Gelb erzeugt, indem Blau aus wei√üem Licht herausgefiltert wird ‚Äì Gelb reflektiert also kein Blau, sondern absorbiert es. Gelb kann also auch als Blaufilter gesehen werden. Das erkl√§rt, warum ein gelber Gegenstand unter blauem Licht dunkel erscheint: Er kann das blaue Licht nicht reflektieren.

Jetzt k√∂nnen wir auch erkl√§ren, warum Farbdrucker vier unterschiedliche Kartuschen ben√∂tigen (@fig-toner-cmy). Mit den Grundfarben der subtraktiven Farbmischung Cyan, Magenta und Gelb k√∂nnen wir jede beliebige Farbe mischen. Zus√§tzlich haben Drucker eine Kartusche f√ºr Schwarz, um erstens ein sattes Schwarz drucken zu k√∂nnen und zweitens die Farbkartuschen zu schonen. Denn schlie√ülich m√ºssen alle drei Farben gemischt werden, um Schwarz zu erhalten. Und weil viele Drucksachen schwarz enthalten (oder sogar ausschlie√ülich) ist eine schwarze Kartusche einfach effizienter. Die Farbe Schwarz wird bei Druckerkartuschen als Key bezeichnet und mit "K" abgek√ºrzt. Wir sprechen daher auch von CMYK.

![Ein typisches Set mit CMY-Druckerkartuschen inklusive Schwarz.](images/toner-cmy.png){#fig-toner-cmy .lightbox}

Farben spielen eine so wichtige Rolle bei der Arbeit mit Computern. Deshalb lohnt es sich, ein wenig √ºber die Hintergr√ºnde von Farben und deren Mischung zu verstehen. Wir werden sp√§ter noch lernen, wie Bildschirme Farben darstellen. Sp√§testens dann wird uns das Thema der Farbmischung wieder begegnen.

Ab jetzt wollen wir weiter mit unserer LED experimentieren und den RGB-Code, mit dem Computer Farben abbilden, praxisnah verstehen. Bisher haben wir gelernt, dass wir die Farbe der LED √ºber die Methode `set_rgb_value()` ver√§ndern k√∂nnen, wenn wir wissen, welcher RGB-Code unsere gew√ºnschte Farbe repr√§sentiert. Da wir jetzt mehr √ºber die Farbmischung wissen, k√∂nnen wir die LED also ganz einfach in der Farbe Magenta leuchten lassen:

```{python}
#| code-line-numbers: false
led.set_rgb_value(255, 0, 255)
```

Gem√§√ü der Theorie der additiven Farbmischung (@fig-additive-color-mixing) m√ºsste Rot und Blau Magenta ergeben. Probiert es aus!

## Schleifen

Das deklarierte Ziel unseres ersten Experiments ist es, einen Regenbogenfarbverlauf zu erzeugen. Dazu m√ºssen wir die Farbe der LED kontinuierlich √§ndern, sodass sie von Rot √ºber Gelb, Gr√ºn, Cyan, Blau und Violett wieder zur√ºck zu Rot wechselt. Das erreichen wir mit einer *Schleife*\index{Schleife}. Eine Schleife ist ein Konstrukt in der Programmierung, das es uns erm√∂glicht, einen bestimmten Codeabschnitt mehrfach auszuf√ºhren, ohne ihn jedes Mal neu schreiben zu m√ºssen. Das spart Zeit und macht den Code √ºbersichtlicher.

### Abz√§hlbare Wiederholungen

Wir beginnen wie immer einfach und n√§hern uns dem Regenbogen schrittweise an. Zun√§chst w√§re es sch√∂n, wenn wir die LED einfach Rot pulsieren lassen k√∂nnten. Dazu m√ºssen wir n√§mlich nur den Rot-Kanal und nicht alle drei Kan√§le der LED ansteuern. Gleichzeitig lernen wir schon hier ein Problem kennen, das mit Schleifen gel√∂st werden kann.

Was bedeutet es, die LED pulsieren zu lassen? Und was m√ºssen wir daf√ºr tun? Pulsieren bedeutet, dass die LED langsam immer heller wird, kurz in der vollen Helligkeit verweilt, aber dann sofort wieder kontinuierlich dunkler wird. Sobald sie schwarz ist f√§ngt der Zyklus von Vorne an.

Den Ausdruck *immer heller werden* k√∂nnen wir bezogen auf die LED so √ºbersetzen, dass wir den Anteil des Rot-Kanals schrittweise erh√∂hen. Wenn die LED zu Beginn aus ist, also alle Kan√§le auf 0 stehen, k√∂nnen wir den Rot-Kanal von 0 auf 255 erh√∂hen und so die LED immer heller in Rot aufleuchten lassen.

Wir beginnen also mit einer schwarzen LED:

```{python}
#| code-line-numbers: false
led.set_rgb_value(0, 0, 0)
```

Anschlie√üend setzen wir den Wert f√ºr Rot auf 1:

```{python}
#| code-line-numbers: false
led.set_rgb_value(1, 0, 0)
```

Und erh√∂hen ihn schrittweise:

```{python}
#| code-line-numbers: false
led.set_rgb_value(2, 0, 0)
led.set_rgb_value(3, 0, 0)
led.set_rgb_value(4, 0, 0)
# ...
```

Wenn wir nach diesem Muster fortfahren, h√§tten wir bis zum vollen Rot 255 Zeilen Code geschrieben, eine f√ºr Zeile jeden Erh√∂hungschritt. Und anschlie√üend das gleiche nochmal r√ºckw√§rts, damit wir wieder zu Schwarz kommen. Mit 510 Zeilen Code h√§tten wir dann eine Pulsierungszyklus durchlaufen. Wollen wir die LED √∂fters pulsieren lassen vervielfacht sich unser Code entsprechend. Das kann doch nicht die L√∂sung f√ºr ein so einfaches Problem sein.

Und tats√§chlich gibt es in der Programmierung eine bessere M√∂glichkeit, um sich wiederholende Abl√§ufe abzubilden: die Schleife. In einem Fall, bei dem wir genau wissen, wie oft wir etwas wiederholen wollen, bietet sich eine Z√§hlerschleife an:

```{python}
#| code-line-numbers: false
for r in range(256):
    led.set_rgb_value(r, 0, 0)
```

Voil√°! Unsere 510 Zeilen Code k√∂nnen wir mit einer Schleife auf zwei Zeilen reduzieren! Dazu m√ºssen wir im Kopf der Schleife (`for ... in ...`) festlegen, wie oft der einger√ºckte Codeblock nach dem Doppelpunkt ausgef√ºhrt werden soll. In Python funktioniert das √ºber die Angabe einer Menge, f√ºr die jedes Element einmal durchlaufen wird. Das aktuelle Element ist in der Schleife als `r` verf√ºgbar. Und `r` nimmt nacheinander jeden Wert der Menge an, die nach dem Schl√ºsselwort `in` folgt. Diese Menge erzeugt hier die Funktion `range(256)`, die, wie der Name preisgibt, eine *Zahlensequenz* von 0 bis zum angegebenen Wert minus eins erzeugt. In unserem Fall also von 0 bis 255.

Um das besser nachvollziehen zu k√∂nnen, geben wir den Wert f√ºr `r` einfach mal aus:

```{python}
#| code-line-numbers: false
for r in range(256):
    led.set_rgb_value(r, 0, 0)
    print(r) # <1> 
```
1. Mit `print()` geben wir einen Wert auf der Konsole aus. 

Jetzt wird es deutlich: mit jedem Durchlauf der Schleife wird ein neuer Wert f√ºr `r` gesetzt und ausgegeben. Und zwar jeweils um eins erh√∂ht. Die Funktion `range(256)` erzeugt genau gesagt eine sortierte Reihe mit den Zahlen von 0 bis 255. Das sieht in Python dann so aus:

```{python}
#| eval: true
list_of_numbers = range(256)
print(list(list_of_numbers)) # <1>
```
1. Mit der `list()`-Funktion wandeln wir die von `range()` erzeugte Menge in eine Liste um, die wir dann ausgeben k√∂nnen.

R√ºckw√§rts erreichen wir das gleiche Ergebnis mit einer weiteren Schleife, deren Menge wir umkehren, so dass sie von 255 bis 0 geht:

```{python}
for r in range(255, -1, -1):
    led.set_rgb_value(r, 0, 0)
```

Warum hat `range()` auf einmal drei Argumente? Ganz einfach: Standardm√§√üig erstellt die Funktion eine Menge von 0 bis zur angegebenen Zahl minus eins. Wir k√∂nnen die Menge aber beeinflussen, indem wir einen Startwert und einen Schrittwert angeben. In unserem Fall oben beginnen wir bei 255 (erster Parameter) und gehen bis -1 (zweiter Parameter), wobei wir in jedem Schritt um -1 verringern (dritter Parameter). Warum z√§hlen wir bis -1, wo wir doch eigentlich die 0 als kleinste Zahl ben√∂tigen? Das liegt daran, dass die Menge von `range()` immer bis zum zweiten Parameter minus eins geht. Wenn wir also 0 als kleinste Zahl ben√∂tigen, m√ºssen wir bis -1 z√§hlen.

Fassen wir unsere Erkenntnis zusammen und lassen die LED pulsieren:

```{python}
import time

# Increase red step by step
for r in range(256):
    led.set_rgb_value(r, 0, 0)
    time.sleep(0.001)

# Stay at full brightness for a bit
time.sleep(0.25)

# Decrease red step by step
for r in range(255, -1, -1):
    led.set_rgb_value(r, 0, 0)
    time.sleep(0.001)
```

Soweit bekannt? Fast, eine kleine Neuerung habe ich gerade eingebaut, n√§mlich mit der Funktion `time.sleep()`. Diese Funktion pausiert das Programm f√ºr die angegebene Zeit in Sekunden. In unserem Fall pausieren wir f√ºr 0,001 Sekunden, also 1 Millisekunde. Dadurch wird die LED langsamer heller und dunkler, was den Pulsationseffekt verst√§rkt. Ohne diese Pause w√ºrde die LED so schnell aufleuchten, dass es f√ºr das menschliche Auge nicht mehr wahrnehmbar w√§re. Tats√§chlich w√ºrden wir auch die Hardware √ºberfordern, weil die LED gar nicht so schnell die Farbe wechseln kann. Das Programm w√ºrde abst√ºrzen.

Auf dem H√∂hepunkt warten wir erneut, dieses Mal eine Viertelsekunde, bevor wir die LED langsam ausgehen lassen und den Rotanteil schrittweise wieder auf Null setzen. Dann endet unser Programm, leider viel zu fr√ºh. Die LED soll doch eigentlich weiter pulsieren, bis... ja bis wann √ºberhaupt?

### Bedingte Wiederholungen

Beim L√∂sen von Problemen sto√üen wir h√§ufig auf Situationen, in denen wir bestimmte Schritte wiederholt ausf√ºhren m√∂chten, aber nur unter bestimmten Bedingungen. Hier kommen bedingte Wiederholungen ins Spiel, die es uns erm√∂glichen, Schleifen zu erstellen, die nur dann fortgesetzt werden, wenn eine bestimmte Bedingung noch erf√ºllt ist.

Das k√∂nnen wir auf unsere pulsierende LED anwenden. Sie soll ihren Pulsierzyklus Dunkel-Hell-Dunkel wiederholen, solange der Benutzer nicht unterbricht. Das ist zumindest ein pragmatisches Abbruchkriterium f√ºr unseren Fall. Wir definieren also hier keine feste Anzahl Wiederholungen, wie bei der `for ... in`-Schleife, sondern wir wollen festlegen, unter welcher *Bedingung* die Schleife fortgesetzt wird. Wir k√∂nnten also sagen: *solange* die Bedingung X erf√ºllt ist, wiederhole die aufgef√ºhrten Schritte. Und weil Programmiersprachen f√ºr Menschen gemacht sind, klingt es im echten Programm auch so √§hnlich:

```{python}
while 1==1:
    print("The condition is always true")
    time.sleep(1)
```

Das Schl√ºsselwort `while` f√ºhrt eine bedingte Schleife ein, gefolgt von der Bedingung, die die Schleife steuert. Die Bedingung wird vor jedem neuen Schleifendurchlauf gepr√ºft (auch vor dem ersten) und sollte sie falsch (`false`) sein, wird die Schleife beendet. 

Wann wird die Schleife oben also beendet? Richtig - niemals. Die Bedingung `1==1` ist immer wahr, die Schleife l√§uft somit endlos. Wir sprechen auch von einer Endlosschleife, die wir in der Programmierung unbedingt vermeiden wollen, es sei denn, sie ist explizit gewollt und nicht versehentlich entstanden. Das kurze Programm oben schreibt also in Abst√§nden von einer Sekunde den Text "The condition is always true" auf die Konsole.

Eine Bedingung ist in Python und anderen Programmiersprache ein wichtiges Konzept, das es uns erm√∂glicht, Entscheidungen zu treffen und den Programmfluss zu steuern. In unserem Fall k√∂nnte die Bedingung lauten: *solange der Benutzer nicht stoppt, wiederhole den Pulsierzyklus*. Eine Bedingung hat die Eigenschaft, dass sie jederzeit evaluiert werden kann und entweder den Wert wahr (true) oder falsch (false) annimmt. Wie aber dr√ºcken wir das in Python aus?

```{python}
import keyboard

while not keyboard.is_pressed('esc'):
    print("Nobody pressed ESC yet")
    time.sleep(1)
```

F√ºr Ereignisse, die die Tastatur betreffen, k√∂nnen wir uns der Bibliothek `keyboard` bedienen, die es uns erm√∂glicht, Tasteneingaben einfach zu √ºberwachen. Der Ausdruck oder die Bedingung `not keyboard.is_pressed('esc')` pr√ºft, ob die ESC-Taste gedr√ºckt ist. Wegen des `not` wird die Schleife fortgesetzt, solange die ESC-Taste *nicht* gedr√ºckt ist. Das Schl√ºsselwort verneint das Ergebnis einer Bedingung. Aus `True` wird `False`, und umgekehrt.

Die [Bibliothek](#bibliotheken) `keyboard` ist eine so genannte externe Bibliothek und muss vor der Verwendung installiert werden. Das k√∂nnt ihr √ºber den Paketmanager `pip` bewerkstelligen, der mit jeder Python-Installation mitgeliefert wird. Gebt auf der Kommandozeile dazu den folgenden Befehl ein:

```bash
pip install keyboard
```

Anschlie√üend ist die Bibliothek in eurer Python-Umgebung vorhanden und sollte mit dem `import`-Befehl erfolgreich geladen werden k√∂nnen.

Wenn wir jetzt unseren f√ºr einen Pulsierzyklus von Oben in die neue bedingte Schleife einf√ºgen, sind wir schon am Ziel. Der Pulsierzyklus wird wiederholt, solange der Benutzer nicht die Taste Escape dr√ºckt.

```{python}
import keyboard

while not keyboard.is_pressed('esc'):

    # Increase red step by step
    for r in range(256):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full brightness for a bit
    time.sleep(0.25)

    # Decrease red step by step
    for r in range(255, -1, -1):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full dark for a bit
    time.sleep(0.25)
```

F√ºr die Vollst√§ndigkeit das Ganze inklusive des [Boilerplate-Codes](#boilerplate-code) f√ºr die Verbindung zu den Tinkerforge-Ger√§ten:

```{python}
#| lst-label: lst-pulse-program
#| lst-cap: Das fertige Programm, das die LED rot pulsieren l√§sst.
import time
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223) 
led = BrickletRGBLEDV2('ZEP', ipcon)

# Turn LED off initially
led.set_rgb_value(0, 0, 0)

while not keyboard.is_pressed('esc'):

    # Increase red step by step
    for r in range(256):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full brightness for a bit
    time.sleep(0.25)

    # Decrease red step by step
    for r in range(255, -1, -1):
        led.set_rgb_value(r, 0, 0)
        time.sleep(0.001)

    # Stay at full dark for a bit
    time.sleep(0.25)
```

## Farbkreise

Das RGB-Farbschema ist f√ºr Computer optimal, weil sich damit mit nur drei Zahlen jede beliebige Farbe kodieren l√§sst. Zahlen sind schlie√ülich die Sprache, mit der Computer am besten umgehen k√∂nnen. F√ºr uns Menschen ist dieses Schema jedoch weniger intuitiv. Oder k√∂nntet ihr auf Anhieb sagen, welche Farbe hinter der Kombination (67, 201, 182) steckt?

Um Farben f√ºr uns leichter w√§hlbar zu machen, wurde der sogenannte Hue-Farbkreis entwickelt. Er ordnet die Farben auf einer Skala von 0 bis 360 Grad an ‚Äì √§hnlich wie die Winkel auf einem Kreis. Neben dem Farbton (Hue) lassen sich zus√§tzlich die S√§ttigung und die Helligkeit einstellen: Der Farbton bestimmt die eigentliche Farbe, die S√§ttigung, wie kr√§ftig oder blass sie wirkt, und die Helligkeit, wie hell oder dunkel sie erscheint.

::: {.content-visible when-format="html"}

![Die Farbauswahl in Google Slides funktioniert √ºber den Hue-Farbkreis.](images/hue_color_picker.gif){#fig-hue-color-picker .lightbox fig-align="center" width="33%"}

:::

::: {.content-visible when-format="pdf"}

![Die Farbauswahl in Google Slides funktioniert √ºber den Hue-Farbkreis.](images/hue_color_picker_still.png){#fig-hue-color-picker .lightbox fig-align="center" width="33%"}

:::

In @fig-hue-color-picker seht ihr, wie die Farbauswahl in Google Slides funktioniert. Mit dem Slider in der Mitte bestimmt ihr den Farbton. Habt ihr einen passenden Ton gefunden, k√∂nnt ihr im Rechteck dar√ºber durch Verschieben des kleinen Kreises die S√§ttigung und Helligkeit anpassen.

Beobachtet ihr dabei die RGB-Werte, erkennt ihr die Systematik der Farbton-Skala: Ausgehend von reinem Rot wird Schritt f√ºr Schritt Gr√ºn hinzugef√ºgt ‚Äì so entstehen Orange und Gelb. Danach nimmt der Rotanteil ab, w√§hrend Blau hinzukommt. √úber Cyan gelangen wir zu reinem Blau. Schlie√ülich wird wieder Rot beigemischt, wodurch Violett bis Pink entstehen. Auf diese Weise bildet der Kreis den gesamten Regenbogen ab.

Da die Skala am Ende wieder bei Rot ankommt, l√§sst sich der Farbverlauf nahtlos wiederholen ‚Äì ohne harte √úberg√§nge. Genau deshalb wird der Hue-Verlauf meist als Kreis dargestellt.

![Der Hue-Farbkreis mit HSV-Werten.](images/hue_color_circle_hsv.png){#fig-hue-color-circle .lightbox fig-align="center" width="50%"}

@fig-hue-color-circle zeigt den Hue-Farbkreis im HSV-Modell\index{HSV-Modell}. HSV steht f√ºr Hue, Saturation, Value (Farbton, S√§ttigung, Helligkeit). Der Wert Value gibt die Helligkeit auf einer Skala von 0 bis 100‚ÄØ% an. Im Bild ist die Helligkeit konstant bei 100‚ÄØ%, w√§hrend die S√§ttigung von innen nach au√üen zunimmt. In der Mitte sehen wir deshalb Wei√ü, w√§hrend am √§u√üeren Rand die Farben ihre volle Intensit√§t haben.

Wenn wir ein Programm schreiben, das die gesamte Hue-Farbskala durchl√§uft und die LED jeweils in der passenden Farbe aufleuchten l√§sst, erhalten wir unser Regenbogenprogramm. Da die LED RGB-Werte ben√∂tigt, m√ºssen wir den Verlauf des Hue-Farbkreises in RGB umsetzen. Ein Blick auf die Animation in @fig-hue-color-picker hilft: Der Farbverlauf l√§sst sich in sechs Phasen unterteilen, wie @fig-hue-rgb-diagram zeigt:

1. Rot = 255, Blau = 0, Gr√ºn steigt linear
2. Rot sinkt linear, Gr√ºn = 255, Blau = 0
3. Rot = 0, Gr√ºn = 255, Blau steigt linear
4. Rot = 0, Gr√ºn sinkt linear, Blau = 255
5. Rot steigt linear, Gr√ºn = 0, Blau = 255
6. Rot = 255, Gr√ºn = 0, Blau sinkt linear

Dann beginnt der Zyklus von vorn.

![Der Hue-Farbverlauf mit den Ver√§nderungen der RGB-Werte (Quelle: [Ronja's Tutorials](https://www.ronja-tutorials.com/post/041-hsv-colorspace/)).](images/hue_rgb_diagram.png){#fig-hue-rgb-diagram .lightbox fig-align="center" width="75%"}

### Farbkreis als Programm

Beginnen wir mit der ersten Phase und schreiben daf√ºr ein Python-Programm:

```{python}
for green in range(256):
    led.set_rgb_value(255, green, 0)
    time.sleep(0.01)
```

Weil wir genau wissen, wie oft wir die Schleife durchlaufen wollen, verwenden wir eine `for`-Schleife. Innerhalb der Schleife erh√∂hen wir die Variable `green` jeweils um 1, was effektiv den Gr√ºnanteil unseres RGB-Wertes erh√∂ht. Mit jedem Durchlauf f√ºgen wir somit mehr Gr√ºn hinzu, w√§hrend Rot und Blau konstant bleiben. Phase 1 ist damit abgeschlossen - machen wir weiter mit Phase 2:

```{python}
for red in range(255, -1, -1):
    led.set_rgb_value(red, 255, 0)
    time.sleep(0.01)
```

Wie wir mit einer `for`-Schleife r√ºckw√§rts z√§hlen, haben wir schon weiter oben kennengelernt. In Phase zwei verringern wir schrittweise den Rotanteil, w√§hrend die anderen beiden Farben konstant bleiben. Damit kommen wir zu Phase 3:

```{python}
for blue in range(256):
    led.set_rgb_value(0, 255, blue)
    time.sleep(0.01)
```

Ich glaube, ihr habt das Prinzip verstanden. Indem wir die sechs Phasen jeweils in einer eigenen Schleife abarbeiten, erhalten wir das vollst√§ndige Regenbogenprogramm:

```{python}
# phase 1
for green in range(256):
    led.set_rgb_value(255, green, 0)
    time.sleep(0.01)

# phase 2
for red in range(255, -1, -1):
    led.set_rgb_value(red, 255, 0)
    time.sleep(0.01)

# phase 3
for blue in range(256):
    led.set_rgb_value(0, 255, blue)
    time.sleep(0.01)

# phase 4
for green in range(255, -1, -1):
    led.set_rgb_value(0, green, 255)
    time.sleep(0.01)

# phase 5
for red in range(256):
    led.set_rgb_value(red, 0, 255)
    time.sleep(0.01)

# phase 6
for blue in range(255, -1, -1):
    led.set_rgb_value(255, 0, blue)
    time.sleep(0.01)

```

Wie sch√∂n üåà Eine Sache fehlt aber noch. 

### Der Zyklus wiederholt sich

Der Regenbogen soll am Ende wieder von Vorne beginnen. Wie schon beim Pulsieren der Farben k√∂nnen wir auch hier eine `while`-Schleife verwenden und  die Phasen kontinuierlich abspielen. Solange bis der Benutzer die Escape-Taste dr√ºckt:

```{python}
while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(0.01)

    # phase 2
    for red in range(255, -1, -1):
        led.set_rgb_value(red, 255, 0)
        time.sleep(0.01)

    # phase 3
    for blue in range(256):
        led.set_rgb_value(0, 255, blue)
        time.sleep(0.01)

    # phase 4
    for green in range(255, -1, -1):
        led.set_rgb_value(0, green, 255)
        time.sleep(0.01)

    # phase 5
    for red in range(256):
        led.set_rgb_value(red, 0, 255)
        time.sleep(0.01)

    # phase 6
    for blue in range(255, -1, -1):
        led.set_rgb_value(255, 0, blue)
        time.sleep(0.01)

```

Wir haben es fast geschafft! Eine Kleinigkeit wollen wir an unserem Programm noch verbessern. 

### Zeitsteuerung

Vielleicht habt ihr gemerkt, dass die Geschwindigkeit, mit der unsere LED den gesamten Regenbogen einmal durchl√§uft, nicht sehr hoch ist. Ich w√ºrde das gerne beschleunigen. Die Zeit steuern wir √ºber die `time.sleep()`-Funktion, sodass wir einfach den Wert in jedem Funktionsaufruf verringern k√∂nnten. Das w√§re aber nicht sehr effizient, weil wir ihn an sechs Stellen anpassen m√ºssen. Wenn wir danach merken, dass es zu schnell ist, m√ºsstem wir den Wert erneut √ºberall editieren. Das geht einfacher!

Der Trick liegt darin, den Wert f√ºr die Wartedauer als Variable zu definieren und nur einer an einer Stelle zu √§ndern.

```{python}
pause_duration = 0.01
while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # etc.
```

Schon besser! Wir gehen aber noch einen Schritt weiter. Statt dieses kleinteiligen Wertes einer Pause zwischen einer kleinen Farbver√§nderung, m√∂chte ich gerne die Gesamtdauer f√ºr den Durchlauf eine Regenbogens angeben. Der Wert `pause_duration` soll dann auf dieser Basis errechnet werden. Dazu m√ºssen wir nur die Anzahl der Pausen ingesamt kennen, was in jeder der sechs Phasen 256 sind. Macht also:

$$
6 \times 256 = 1536
$$

In unserem Programm teilen wir also die Gesamtdauer in Sekunden geteilt durch 1536:

```{python}
rainbow_duration = 5
pause_duration = rainbow_duration / 1536

while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # etc.
```

Und schon k√∂nnen wir unseren Regenbogen beliebig zeitlich steuern. Damit sind wir am Ende des Kapitels angekommen. Wir schlie√üen wir es mit dem vollst√§ndigen Code f√ºr unseren Regenbogenverlauf ab. Vergesst nicht den Wert f√ºr die UID eurer LED anzupassen, damit es auch bei euch funktioniert:

```{python}
import keyboard
import time
from tinkerforge.ip_connection import IPConnection
from tinkerforge.bricklet_rgb_led_v2 import BrickletRGBLEDV2

ipcon = IPConnection()
ipcon.connect('localhost', 4223) 
led = BrickletRGBLEDV2('ZEP', ipcon)

# Turn LED off initially
led.set_rgb_value(0, 0, 0)

rainbow_duration = 5
pause_duration = rainbow_duration / 1536

# Loop until user presses escape key
while not keyboard.is_pressed('esc'):

    # phase 1
    for green in range(256):
        led.set_rgb_value(255, green, 0)
        time.sleep(pause_duration)

    # phase 2
    for red in range(255, -1, -1):
        led.set_rgb_value(red, 255, 0)
        time.sleep(pause_duration)

    # phase 3
    for blue in range(256):
        led.set_rgb_value(0, 255, blue)
        time.sleep(pause_duration)

    # phase 4
    for green in range(255, -1, -1):
        led.set_rgb_value(0, green, 255)
        time.sleep(pause_duration)

    # phase 5
    for red in range(256):
        led.set_rgb_value(red, 0, 255)
        time.sleep(pause_duration)

    # phase 6
    for blue in range(255, -1, -1):
        led.set_rgb_value(255, 0, blue)
        time.sleep(pause_duration)

# Turn LED off
led.set_rgb_value(0, 0, 0)
```

Seid ihr bereit f√ºr das n√§chste Experiment?